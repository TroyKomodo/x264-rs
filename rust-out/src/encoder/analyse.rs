#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut)]
#![feature(extern_types, label_break_value, stdsimd)]
#[cfg(target_arch = "x86")]
pub use core::arch::x86::{__m128, _mm_setr_ps};
#[cfg(target_arch = "x86_64")]
pub use core::arch::x86_64::{__m128, _mm_setr_ps};
extern "C" {
    pub type _cl_mem;
    pub type _cl_kernel;
    pub type _cl_program;
    pub type _cl_command_queue;
    pub type _cl_device_id;
    pub type _cl_context;
    pub type _cl_platform_id;
    pub type _cl_event;
    pub type x264_ratecontrol_t;
    pub type x264_threadpool_t;
    fn abs(_: libc::c_int) -> libc::c_int;
    fn round(_: libc::c_double) -> libc::c_double;
    fn log2f(_: libc::c_float) -> libc::c_float;
    fn sqrtf(_: libc::c_float) -> libc::c_float;
    fn fabsf(_: libc::c_float) -> libc::c_float;
    fn x264_8_log(
        h: *mut x264_t,
        i_level: libc::c_int,
        psz_fmt: *const libc::c_char,
        _: ...
    );
    fn x264_8_threadpool_run(
        pool: *mut x264_threadpool_t,
        func: Option::<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
        arg: *mut libc::c_void,
    );
    fn x264_8_threadpool_wait(
        pool: *mut x264_threadpool_t,
        arg: *mut libc::c_void,
    ) -> *mut libc::c_void;
    static mut x264_8_level_token: [[vlc_large_t; 128]; 7];
    static mut x264_8_run_before: [uint32_t; 65536];
    fn x264_8_frame_expand_border_chroma(
        h: *mut x264_t,
        frame: *mut x264_frame_t,
        plane: libc::c_int,
    );
    fn x264_8_macroblock_deblock(h: *mut x264_t);
    fn x264_8_frame_cond_wait(
        frame: *mut x264_frame_t,
        i_lines_completed: libc::c_int,
    ) -> libc::c_int;
    fn x264_8_weight_scale_plane(
        h: *mut x264_t,
        dst: *mut pixel,
        i_dst_stride: intptr_t,
        src: *mut pixel,
        i_src_stride: intptr_t,
        i_width: libc::c_int,
        i_height: libc::c_int,
        w: *mut x264_weight_t,
    );
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
    fn x264_malloc(_: int64_t) -> *mut libc::c_void;
    fn x264_free(_: *mut libc::c_void);
    static x264_exp2_lut: [uint8_t; 64];
    static x264_log2_lut: [libc::c_float; 128];
    static x264_log2_lz_lut: [libc::c_float; 32];
    static x264_lambda_tab: [uint16_t; 82];
    static x264_lambda2_tab: [libc::c_int; 82];
    static x264_trellis_lambda2_tab: [[libc::c_int; 82]; 2];
    static x264_chroma_lambda2_offset_tab: [uint16_t; 37];
    static x264_dct4_weight_tab: [uint32_t; 16];
    static x264_dct8_weight_tab: [uint32_t; 64];
    static x264_dct4_weight2_tab: [uint32_t; 16];
    static x264_dct8_weight2_tab: [uint32_t; 64];
    static x264_cabac_transition: [[uint8_t; 2]; 128];
    static x264_cabac_entropy: [uint16_t; 128];
    static x264_significant_coeff_flag_offset_8x8: [[uint8_t; 64]; 2];
    static x264_last_coeff_flag_offset_8x8: [uint8_t; 63];
    static x264_coeff_flag_offset_chroma_422_dc: [uint8_t; 7];
    static x264_significant_coeff_flag_offset: [[uint16_t; 16]; 2];
    static x264_last_coeff_flag_offset: [[uint16_t; 16]; 2];
    static x264_coeff_abs_level_m1_offset: [uint16_t; 16];
    static x264_count_cat_m1: [uint8_t; 14];
    static x264_coeff0_token: [vlc_t; 6];
    static x264_coeff_token: [[[vlc_t; 4]; 16]; 6];
    static x264_total_zeros: [[vlc_t; 16]; 15];
    static x264_total_zeros_2x2_dc: [[vlc_t; 4]; 3];
    static x264_total_zeros_2x4_dc: [[vlc_t; 8]; 7];
    static mut x264_zero: [uint8_t; 1024];
    fn x264_8_mb_predict_mv_16x16(
        h: *mut x264_t,
        i_list: libc::c_int,
        i_ref: libc::c_int,
        mvp: *mut int16_t,
    );
    fn x264_8_mb_predict_mv(
        h: *mut x264_t,
        i_list: libc::c_int,
        idx: libc::c_int,
        i_width: libc::c_int,
        mvp: *mut int16_t,
    );
    fn x264_8_mb_predict_mv_direct16x16(
        h: *mut x264_t,
        b_changed: *mut libc::c_int,
    ) -> libc::c_int;
    fn x264_8_mb_predict_mv_ref16x16(
        h: *mut x264_t,
        i_list: libc::c_int,
        i_ref: libc::c_int,
        mvc: *mut [int16_t; 2],
        i_mvc: *mut libc::c_int,
    );
    fn x264_8_mb_mc(h: *mut x264_t);
    static mut x264_8_cache_mv_func_table: [Option::<
        unsafe extern "C" fn(*mut libc::c_void, uint32_t) -> (),
    >; 10];
    static mut x264_8_cache_mvd_func_table: [Option::<
        unsafe extern "C" fn(*mut libc::c_void, uint32_t) -> (),
    >; 10];
    static mut x264_8_cache_ref_func_table: [Option::<
        unsafe extern "C" fn(*mut libc::c_void, uint32_t) -> (),
    >; 10];
    fn x264_8_macroblock_probe_skip(h: *mut x264_t, b_bidir: libc::c_int) -> libc::c_int;
    fn x264_8_predict_lossless_4x4(
        h: *mut x264_t,
        p_dst: *mut pixel,
        p: libc::c_int,
        idx: libc::c_int,
        i_mode: libc::c_int,
    );
    fn x264_8_predict_lossless_8x8(
        h: *mut x264_t,
        p_dst: *mut pixel,
        p: libc::c_int,
        idx: libc::c_int,
        i_mode: libc::c_int,
        edge: *mut pixel,
    );
    fn x264_8_predict_lossless_16x16(
        h: *mut x264_t,
        p: libc::c_int,
        i_mode: libc::c_int,
    );
    fn x264_8_predict_lossless_chroma(h: *mut x264_t, i_mode: libc::c_int);
    fn x264_8_macroblock_encode(h: *mut x264_t);
    fn x264_8_macroblock_encode_p8x8(h: *mut x264_t, i8: libc::c_int);
    fn x264_8_macroblock_encode_p4x4(h: *mut x264_t, i4: libc::c_int);
    fn x264_8_mb_encode_chroma(h: *mut x264_t, b_inter: libc::c_int, i_qp: libc::c_int);
    fn x264_8_me_search_ref(
        h: *mut x264_t,
        m: *mut x264_me_t,
        mvc: *mut [int16_t; 2],
        i_mvc: libc::c_int,
        p_fullpel_thresh: *mut libc::c_int,
    );
    fn x264_8_me_refine_qpel(h: *mut x264_t, m: *mut x264_me_t);
    fn x264_8_me_refine_qpel_refdupe(
        h: *mut x264_t,
        m: *mut x264_me_t,
        p_halfpel_thresh: *mut libc::c_int,
    );
    fn x264_8_me_refine_qpel_rd(
        h: *mut x264_t,
        m: *mut x264_me_t,
        i_lambda2: libc::c_int,
        i4: libc::c_int,
        i_list: libc::c_int,
    );
    fn x264_8_me_refine_bidir_rd(
        h: *mut x264_t,
        m0: *mut x264_me_t,
        m1: *mut x264_me_t,
        i_weight: libc::c_int,
        i8: libc::c_int,
        i_lambda2: libc::c_int,
    );
    fn x264_8_me_refine_bidir_satd(
        h: *mut x264_t,
        m0: *mut x264_me_t,
        m1: *mut x264_me_t,
        i_weight: libc::c_int,
    );
    fn x264_8_ratecontrol_slice_type(
        _: *mut x264_t,
        i_frame: libc::c_int,
    ) -> libc::c_int;
    fn x264_8_ratecontrol_mb_qp(h: *mut x264_t) -> libc::c_int;
    fn x264_8_opencl_lowres_init(
        h: *mut x264_t,
        fenc: *mut x264_frame_t,
        lambda: libc::c_int,
    ) -> libc::c_int;
    fn x264_8_opencl_motionsearch(
        h: *mut x264_t,
        frames: *mut *mut x264_frame_t,
        b: libc::c_int,
        ref_0: libc::c_int,
        b_islist1: libc::c_int,
        lambda: libc::c_int,
        w: *const x264_weight_t,
    ) -> libc::c_int;
    fn x264_8_opencl_finalize_cost(
        h: *mut x264_t,
        lambda: libc::c_int,
        frames: *mut *mut x264_frame_t,
        p0: libc::c_int,
        p1: libc::c_int,
        b: libc::c_int,
        dist_scale_factor: libc::c_int,
    ) -> libc::c_int;
    fn x264_8_opencl_flush(h: *mut x264_t);
    fn x264_8_opencl_slicetype_prep(
        h: *mut x264_t,
        frames: *mut *mut x264_frame_t,
        num_frames: libc::c_int,
        lambda: libc::c_int,
    );
    fn x264_8_opencl_slicetype_end(h: *mut x264_t);
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type int8_t = __int8_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type intptr_t = libc::c_long;
pub type uintptr_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __atomic_wide_counter {
    pub __value64: libc::c_ulonglong,
    pub __value32: C2RustUnnamed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [libc::c_uint; 2],
    pub __g_size: [libc::c_uint; 2],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2],
}
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48],
    pub __align: libc::c_longlong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_t {
    pub param: x264_param_t,
    pub api: *mut libc::c_void,
    pub thread: [*mut x264_t; 129],
    pub lookahead_thread: [*mut x264_t; 16],
    pub b_thread_active: libc::c_int,
    pub i_thread_phase: libc::c_int,
    pub i_thread_idx: libc::c_int,
    pub i_threadslice_start: libc::c_int,
    pub i_threadslice_end: libc::c_int,
    pub i_threadslice_pass: libc::c_int,
    pub threadpool: *mut x264_threadpool_t,
    pub lookaheadpool: *mut x264_threadpool_t,
    pub mutex: pthread_mutex_t,
    pub cv: pthread_cond_t,
    pub out: C2RustUnnamed_19,
    pub nal_buffer: *mut uint8_t,
    pub nal_buffer_size: libc::c_int,
    pub reconfig_h: *mut x264_t,
    pub reconfig: libc::c_int,
    pub i_frame: libc::c_int,
    pub i_frame_num: libc::c_int,
    pub i_thread_frames: libc::c_int,
    pub i_nal_type: libc::c_int,
    pub i_nal_ref_idc: libc::c_int,
    pub i_disp_fields: int64_t,
    pub i_disp_fields_last_frame: libc::c_int,
    pub i_prev_duration: int64_t,
    pub i_coded_fields: int64_t,
    pub i_cpb_delay: int64_t,
    pub i_coded_fields_lookahead: int64_t,
    pub i_cpb_delay_lookahead: int64_t,
    pub i_cpb_delay_pir_offset: int64_t,
    pub i_cpb_delay_pir_offset_next: int64_t,
    pub b_queued_intra_refresh: libc::c_int,
    pub i_last_idr_pts: int64_t,
    pub i_idr_pic_id: libc::c_int,
    pub dequant4_mf: [*mut [libc::c_int; 16]; 4],
    pub dequant8_mf: [*mut [libc::c_int; 64]; 4],
    pub unquant4_mf: [*mut [libc::c_int; 16]; 4],
    pub unquant8_mf: [*mut [libc::c_int; 64]; 4],
    pub quant4_mf: [*mut [udctcoef; 16]; 4],
    pub quant8_mf: [*mut [udctcoef; 64]; 4],
    pub quant4_bias: [*mut [udctcoef; 16]; 4],
    pub quant8_bias: [*mut [udctcoef; 64]; 4],
    pub quant4_bias0: [*mut [udctcoef; 16]; 4],
    pub quant8_bias0: [*mut [udctcoef; 64]; 4],
    pub nr_offset_emergency: *mut [[udctcoef; 64]; 4],
    pub cost_mv: [*mut uint16_t; 70],
    pub cost_mv_fpel: [[*mut uint16_t; 4]; 70],
    pub cost_table: *mut C2RustUnnamed_18,
    pub chroma_qp_table: *const uint8_t,
    pub sh: x264_slice_header_t,
    pub sps: [x264_sps_t; 1],
    pub pps: [x264_pps_t; 1],
    pub b_sh_backup: libc::c_int,
    pub sh_backup: x264_slice_header_t,
    pub cabac: x264_cabac_t,
    pub frames: C2RustUnnamed_12,
    pub fenc: *mut x264_frame_t,
    pub fdec: *mut x264_frame_t,
    pub i_ref: [libc::c_int; 2],
    pub fref: [[*mut x264_frame_t; 19]; 2],
    pub fref_nearest: [*mut x264_frame_t; 2],
    pub b_ref_reorder: [libc::c_int; 2],
    pub initial_cpb_removal_delay: libc::c_int,
    pub initial_cpb_removal_delay_offset: libc::c_int,
    pub i_reordered_pts_delay: int64_t,
    pub dct: C2RustUnnamed_11,
    pub mb: C2RustUnnamed_8,
    pub rc: *mut x264_ratecontrol_t,
    pub stat: C2RustUnnamed_7,
    pub nr_offset: *mut [udctcoef; 64],
    pub nr_residual_sum: *mut [uint32_t; 64],
    pub nr_count: *mut uint32_t,
    pub nr_offset_denoise: [[udctcoef; 64]; 4],
    pub nr_residual_sum_buf: [[[uint32_t; 64]; 4]; 2],
    pub nr_count_buf: [[uint32_t; 4]; 2],
    pub luma2chroma_pixel: [uint8_t; 7],
    pub scratch_buffer: *mut libc::c_void,
    pub scratch_buffer2: *mut libc::c_void,
    pub intra_border_backup: [[*mut pixel; 3]; 5],
    pub deblock_strength: [*mut [[[uint8_t; 4]; 8]; 2]; 2],
    pub predict_16x16: [x264_predict_t; 7],
    pub predict_8x8: [x264_predict8x8_t; 12],
    pub predict_4x4: [x264_predict_t; 12],
    pub predict_chroma: [x264_predict_t; 7],
    pub predict_8x8c: [x264_predict_t; 7],
    pub predict_8x16c: [x264_predict_t; 7],
    pub predict_8x8_filter: x264_predict_8x8_filter_t,
    pub pixf: x264_pixel_function_t,
    pub mc: x264_mc_functions_t,
    pub dctf: x264_dct_function_t,
    pub zigzagf: x264_zigzag_function_t,
    pub zigzagf_interlaced: x264_zigzag_function_t,
    pub zigzagf_progressive: x264_zigzag_function_t,
    pub quantf: x264_quant_function_t,
    pub loopf: x264_deblock_function_t,
    pub bsf: x264_bitstream_function_t,
    pub lookahead: *mut x264_lookahead_t,
    pub opencl: x264_opencl_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_opencl_t {
    pub ocl: *mut x264_opencl_function_t,
    pub context: cl_context,
    pub device: cl_device_id,
    pub queue: cl_command_queue,
    pub lookahead_program: cl_program,
    pub last_buf: cl_int,
    pub page_locked_buffer: cl_mem,
    pub page_locked_ptr: *mut libc::c_char,
    pub pl_occupancy: libc::c_int,
    pub copies: [C2RustUnnamed_0; 1024],
    pub num_copies: libc::c_int,
    pub b_device_AMD_SI: libc::c_int,
    pub b_fatal_error: libc::c_int,
    pub lookahead_thread_pri: libc::c_int,
    pub opencl_thread_pri: libc::c_int,
    pub downscale_hpel_kernel: cl_kernel,
    pub downscale_kernel1: cl_kernel,
    pub downscale_kernel2: cl_kernel,
    pub luma_16x16_image: [cl_mem; 2],
    pub weightp_hpel_kernel: cl_kernel,
    pub weightp_scaled_images_kernel: cl_kernel,
    pub weighted_scaled_images: [cl_mem; 4],
    pub weighted_luma_hpel: cl_mem,
    pub memset_kernel: cl_kernel,
    pub intra_kernel: cl_kernel,
    pub rowsum_intra_kernel: cl_kernel,
    pub row_satds: [cl_mem; 2],
    pub hme_kernel: cl_kernel,
    pub subpel_refine_kernel: cl_kernel,
    pub mv_buffers: [cl_mem; 2],
    pub lowres_mv_costs: cl_mem,
    pub mvp_buffer: cl_mem,
    pub mode_select_kernel: cl_kernel,
    pub rowsum_inter_kernel: cl_kernel,
    pub lowres_costs: [cl_mem; 2],
    pub frame_stats: [cl_mem; 2],
}
pub type cl_mem = *mut _cl_mem;
pub type cl_kernel = *mut _cl_kernel;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub src: *mut libc::c_void,
    pub dest: *mut libc::c_void,
    pub bytes: libc::c_int,
}
pub type cl_int = int32_t;
pub type cl_program = *mut _cl_program;
pub type cl_command_queue = *mut _cl_command_queue;
pub type cl_device_id = *mut _cl_device_id;
pub type cl_context = *mut _cl_context;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_opencl_function_t {
    pub library: *mut libc::c_void,
    pub clBuildProgram: clBuildProgram_func,
    pub clCreateBuffer: clCreateBuffer_func,
    pub clCreateCommandQueue: clCreateCommandQueue_func,
    pub clCreateContext: clCreateContext_func,
    pub clCreateImage2D: clCreateImage2D_func,
    pub clCreateKernel: clCreateKernel_func,
    pub clCreateProgramWithBinary: clCreateProgramWithBinary_func,
    pub clCreateProgramWithSource: clCreateProgramWithSource_func,
    pub clEnqueueCopyBuffer: clEnqueueCopyBuffer_func,
    pub clEnqueueMapBuffer: clEnqueueMapBuffer_func,
    pub clEnqueueNDRangeKernel: clEnqueueNDRangeKernel_func,
    pub clEnqueueReadBuffer: clEnqueueReadBuffer_func,
    pub clEnqueueWriteBuffer: clEnqueueWriteBuffer_func,
    pub clFinish: clFinish_func,
    pub clGetCommandQueueInfo: clGetCommandQueueInfo_func,
    pub clGetDeviceIDs: clGetDeviceIDs_func,
    pub clGetDeviceInfo: clGetDeviceInfo_func,
    pub clGetKernelWorkGroupInfo: clGetKernelWorkGroupInfo_func,
    pub clGetPlatformIDs: clGetPlatformIDs_func,
    pub clGetProgramBuildInfo: clGetProgramBuildInfo_func,
    pub clGetProgramInfo: clGetProgramInfo_func,
    pub clGetSupportedImageFormats: clGetSupportedImageFormats_func,
    pub clReleaseCommandQueue: clReleaseCommandQueue_func,
    pub clReleaseContext: clReleaseContext_func,
    pub clReleaseKernel: clReleaseKernel_func,
    pub clReleaseMemObject: clReleaseMemObject_func,
    pub clReleaseProgram: clReleaseProgram_func,
    pub clSetKernelArg: clSetKernelArg_func,
}
pub type clSetKernelArg_func = Option::<
    unsafe extern "C" fn(cl_kernel, cl_uint, size_t, *const libc::c_void) -> cl_int,
>;
pub type cl_uint = uint32_t;
pub type clReleaseProgram_func = Option::<unsafe extern "C" fn(cl_program) -> cl_int>;
pub type clReleaseMemObject_func = Option::<unsafe extern "C" fn(cl_mem) -> cl_int>;
pub type clReleaseKernel_func = Option::<unsafe extern "C" fn(cl_kernel) -> cl_int>;
pub type clReleaseContext_func = Option::<unsafe extern "C" fn(cl_context) -> cl_int>;
pub type clReleaseCommandQueue_func = Option::<
    unsafe extern "C" fn(cl_command_queue) -> cl_int,
>;
pub type clGetSupportedImageFormats_func = Option::<
    unsafe extern "C" fn(
        cl_context,
        cl_mem_flags,
        cl_mem_object_type,
        cl_uint,
        *mut cl_image_format,
        *mut cl_uint,
    ) -> cl_int,
>;
pub type cl_image_format = _cl_image_format;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _cl_image_format {
    pub image_channel_order: cl_channel_order,
    pub image_channel_data_type: cl_channel_type,
}
pub type cl_channel_type = cl_uint;
pub type cl_channel_order = cl_uint;
pub type cl_mem_object_type = cl_uint;
pub type cl_mem_flags = cl_bitfield;
pub type cl_bitfield = cl_ulong;
pub type cl_ulong = uint64_t;
pub type clGetProgramInfo_func = Option::<
    unsafe extern "C" fn(
        cl_program,
        cl_program_info,
        size_t,
        *mut libc::c_void,
        *mut size_t,
    ) -> cl_int,
>;
pub type cl_program_info = cl_uint;
pub type clGetProgramBuildInfo_func = Option::<
    unsafe extern "C" fn(
        cl_program,
        cl_device_id,
        cl_program_build_info,
        size_t,
        *mut libc::c_void,
        *mut size_t,
    ) -> cl_int,
>;
pub type cl_program_build_info = cl_uint;
pub type clGetPlatformIDs_func = Option::<
    unsafe extern "C" fn(cl_uint, *mut cl_platform_id, *mut cl_uint) -> cl_int,
>;
pub type cl_platform_id = *mut _cl_platform_id;
pub type clGetKernelWorkGroupInfo_func = Option::<
    unsafe extern "C" fn(
        cl_kernel,
        cl_device_id,
        cl_kernel_work_group_info,
        size_t,
        *mut libc::c_void,
        *mut size_t,
    ) -> cl_int,
>;
pub type cl_kernel_work_group_info = cl_uint;
pub type clGetDeviceInfo_func = Option::<
    unsafe extern "C" fn(
        cl_device_id,
        cl_device_info,
        size_t,
        *mut libc::c_void,
        *mut size_t,
    ) -> cl_int,
>;
pub type cl_device_info = cl_uint;
pub type clGetDeviceIDs_func = Option::<
    unsafe extern "C" fn(
        cl_platform_id,
        cl_device_type,
        cl_uint,
        *mut cl_device_id,
        *mut cl_uint,
    ) -> cl_int,
>;
pub type cl_device_type = cl_bitfield;
pub type clGetCommandQueueInfo_func = Option::<
    unsafe extern "C" fn(
        cl_command_queue,
        cl_command_queue_info,
        size_t,
        *mut libc::c_void,
        *mut size_t,
    ) -> cl_int,
>;
pub type cl_command_queue_info = cl_uint;
pub type clFinish_func = Option::<unsafe extern "C" fn(cl_command_queue) -> cl_int>;
pub type clEnqueueWriteBuffer_func = Option::<
    unsafe extern "C" fn(
        cl_command_queue,
        cl_mem,
        cl_bool,
        size_t,
        size_t,
        *const libc::c_void,
        cl_uint,
        *const cl_event,
        *mut cl_event,
    ) -> cl_int,
>;
pub type cl_event = *mut _cl_event;
pub type cl_bool = cl_uint;
pub type clEnqueueReadBuffer_func = Option::<
    unsafe extern "C" fn(
        cl_command_queue,
        cl_mem,
        cl_bool,
        size_t,
        size_t,
        *mut libc::c_void,
        cl_uint,
        *const cl_event,
        *mut cl_event,
    ) -> cl_int,
>;
pub type clEnqueueNDRangeKernel_func = Option::<
    unsafe extern "C" fn(
        cl_command_queue,
        cl_kernel,
        cl_uint,
        *const size_t,
        *const size_t,
        *const size_t,
        cl_uint,
        *const cl_event,
        *mut cl_event,
    ) -> cl_int,
>;
pub type clEnqueueMapBuffer_func = Option::<
    unsafe extern "C" fn(
        cl_command_queue,
        cl_mem,
        cl_bool,
        cl_map_flags,
        size_t,
        size_t,
        cl_uint,
        *const cl_event,
        *mut cl_event,
        *mut cl_int,
    ) -> *mut libc::c_void,
>;
pub type cl_map_flags = cl_bitfield;
pub type clEnqueueCopyBuffer_func = Option::<
    unsafe extern "C" fn(
        cl_command_queue,
        cl_mem,
        cl_mem,
        size_t,
        size_t,
        size_t,
        cl_uint,
        *const cl_event,
        *mut cl_event,
    ) -> cl_int,
>;
pub type clCreateProgramWithSource_func = Option::<
    unsafe extern "C" fn(
        cl_context,
        cl_uint,
        *mut *const libc::c_char,
        *const size_t,
        *mut cl_int,
    ) -> cl_program,
>;
pub type clCreateProgramWithBinary_func = Option::<
    unsafe extern "C" fn(
        cl_context,
        cl_uint,
        *const cl_device_id,
        *const size_t,
        *mut *const libc::c_uchar,
        *mut cl_int,
        *mut cl_int,
    ) -> cl_program,
>;
pub type clCreateKernel_func = Option::<
    unsafe extern "C" fn(cl_program, *const libc::c_char, *mut cl_int) -> cl_kernel,
>;
pub type clCreateImage2D_func = Option::<
    unsafe extern "C" fn(
        cl_context,
        cl_mem_flags,
        *const cl_image_format,
        size_t,
        size_t,
        size_t,
        *mut libc::c_void,
        *mut cl_int,
    ) -> cl_mem,
>;
pub type clCreateContext_func = Option::<
    unsafe extern "C" fn(
        *const cl_context_properties,
        cl_uint,
        *const cl_device_id,
        Option::<
            unsafe extern "C" fn(
                *const libc::c_char,
                *const libc::c_void,
                size_t,
                *mut libc::c_void,
            ) -> (),
        >,
        *mut libc::c_void,
        *mut cl_int,
    ) -> cl_context,
>;
pub type cl_context_properties = intptr_t;
pub type clCreateCommandQueue_func = Option::<
    unsafe extern "C" fn(
        cl_context,
        cl_device_id,
        cl_command_queue_properties,
        *mut cl_int,
    ) -> cl_command_queue,
>;
pub type cl_command_queue_properties = cl_bitfield;
pub type clCreateBuffer_func = Option::<
    unsafe extern "C" fn(
        cl_context,
        cl_mem_flags,
        size_t,
        *mut libc::c_void,
        *mut cl_int,
    ) -> cl_mem,
>;
pub type clBuildProgram_func = Option::<
    unsafe extern "C" fn(
        cl_program,
        cl_uint,
        *const cl_device_id,
        *const libc::c_char,
        Option::<unsafe extern "C" fn(cl_program, *mut libc::c_void) -> ()>,
        *mut libc::c_void,
    ) -> cl_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_lookahead_t {
    pub b_exit_thread: uint8_t,
    pub b_thread_active: uint8_t,
    pub b_analyse_keyframe: uint8_t,
    pub i_last_keyframe: libc::c_int,
    pub i_slicetype_length: libc::c_int,
    pub last_nonb: *mut x264_frame_t,
    pub thread_handle: pthread_t,
    pub ifbuf: x264_sync_frame_list_t,
    pub next: x264_sync_frame_list_t,
    pub ofbuf: x264_sync_frame_list_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_sync_frame_list_t {
    pub list: *mut *mut x264_frame_t,
    pub i_max_size: libc::c_int,
    pub i_size: libc::c_int,
    pub mutex: pthread_mutex_t,
    pub cv_fill: pthread_cond_t,
    pub cv_empty: pthread_cond_t,
}
pub type x264_frame_t = x264_frame;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_frame {
    pub base: *mut uint8_t,
    pub i_poc: libc::c_int,
    pub i_delta_poc: [libc::c_int; 2],
    pub i_type: libc::c_int,
    pub i_forced_type: libc::c_int,
    pub i_qpplus1: libc::c_int,
    pub i_pts: int64_t,
    pub i_dts: int64_t,
    pub i_reordered_pts: int64_t,
    pub i_duration: int64_t,
    pub f_duration: libc::c_float,
    pub i_cpb_duration: int64_t,
    pub i_cpb_delay: int64_t,
    pub i_dpb_output_delay: int64_t,
    pub param: *mut x264_param_t,
    pub i_frame: libc::c_int,
    pub i_coded: libc::c_int,
    pub i_field_cnt: int64_t,
    pub i_frame_num: libc::c_int,
    pub b_kept_as_ref: libc::c_int,
    pub i_pic_struct: libc::c_int,
    pub b_keyframe: libc::c_int,
    pub b_fdec: uint8_t,
    pub b_last_minigop_bframe: uint8_t,
    pub i_bframes: uint8_t,
    pub f_qp_avg_rc: libc::c_float,
    pub f_qp_avg_aq: libc::c_float,
    pub f_crf_avg: libc::c_float,
    pub i_poc_l0ref0: libc::c_int,
    pub i_csp: libc::c_int,
    pub i_plane: libc::c_int,
    pub i_stride: [libc::c_int; 3],
    pub i_width: [libc::c_int; 3],
    pub i_lines: [libc::c_int; 3],
    pub i_stride_lowres: libc::c_int,
    pub i_width_lowres: libc::c_int,
    pub i_lines_lowres: libc::c_int,
    pub plane: [*mut pixel; 3],
    pub plane_fld: [*mut pixel; 3],
    pub filtered: [[*mut pixel; 4]; 3],
    pub filtered_fld: [[*mut pixel; 4]; 3],
    pub lowres: [*mut pixel; 4],
    pub integral: *mut uint16_t,
    pub buffer: [*mut pixel; 4],
    pub buffer_fld: [*mut pixel; 4],
    pub buffer_lowres: *mut pixel,
    pub weight: [[x264_weight_t; 3]; 16],
    pub weighted: [*mut pixel; 16],
    pub b_duplicate: libc::c_int,
    pub orig: *mut x264_frame,
    pub mb_type: *mut int8_t,
    pub mb_partition: *mut uint8_t,
    pub mv: [*mut [int16_t; 2]; 2],
    pub mv16x16: *mut [int16_t; 2],
    pub lowres_mvs: [[*mut [int16_t; 2]; 17]; 2],
    pub field: *mut uint8_t,
    pub effective_qp: *mut uint8_t,
    pub lowres_costs: [[*mut uint16_t; 18]; 18],
    pub lowres_mv_costs: [[*mut libc::c_int; 17]; 2],
    pub ref_0: [*mut int8_t; 2],
    pub i_ref: [libc::c_int; 2],
    pub ref_poc: [[libc::c_int; 16]; 2],
    pub inv_ref_poc: [int16_t; 2],
    pub i_cost_est: [[libc::c_int; 18]; 18],
    pub i_cost_est_aq: [[libc::c_int; 18]; 18],
    pub i_satd: libc::c_int,
    pub i_intra_mbs: [libc::c_int; 18],
    pub i_row_satds: [[*mut libc::c_int; 18]; 18],
    pub i_row_satd: *mut libc::c_int,
    pub i_row_bits: *mut libc::c_int,
    pub f_row_qp: *mut libc::c_float,
    pub f_row_qscale: *mut libc::c_float,
    pub f_qp_offset: *mut libc::c_float,
    pub f_qp_offset_aq: *mut libc::c_float,
    pub b_intra_calculated: libc::c_int,
    pub i_intra_cost: *mut uint16_t,
    pub i_propagate_cost: *mut uint16_t,
    pub i_inv_qscale_factor: *mut uint16_t,
    pub b_scenecut: libc::c_int,
    pub f_weighted_cost_delta: [libc::c_float; 18],
    pub i_pixel_sum: [uint32_t; 3],
    pub i_pixel_ssd: [uint64_t; 3],
    pub hrd_timing: x264_hrd_t,
    pub i_planned_type: [uint8_t; 251],
    pub i_planned_satd: [libc::c_int; 251],
    pub f_planned_cpb_duration: [libc::c_double; 251],
    pub i_coded_fields_lookahead: int64_t,
    pub i_cpb_delay_lookahead: int64_t,
    pub i_lines_completed: libc::c_int,
    pub i_lines_weighted: libc::c_int,
    pub i_reference_count: libc::c_int,
    pub mutex: pthread_mutex_t,
    pub cv: pthread_cond_t,
    pub i_slice_count: libc::c_int,
    pub f_pir_position: libc::c_float,
    pub i_pir_start_col: libc::c_int,
    pub i_pir_end_col: libc::c_int,
    pub i_frames_since_pir: libc::c_int,
    pub b_corrupt: libc::c_int,
    pub extra_sei: x264_sei_t,
    pub opaque: *mut libc::c_void,
    pub mb_info: *mut uint8_t,
    pub mb_info_free: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub opencl: x264_frame_opencl_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_frame_opencl_t {
    pub ocl: *mut x264_opencl_function_t,
    pub scaled_image2Ds: [cl_mem; 4],
    pub luma_hpel: cl_mem,
    pub inv_qscale_factor: cl_mem,
    pub intra_cost: cl_mem,
    pub lowres_mvs0: cl_mem,
    pub lowres_mvs1: cl_mem,
    pub lowres_mv_costs0: cl_mem,
    pub lowres_mv_costs1: cl_mem,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_sei_t {
    pub num_payloads: libc::c_int,
    pub payloads: *mut x264_sei_payload_t,
    pub sei_free: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_sei_payload_t {
    pub payload_size: libc::c_int,
    pub payload_type: libc::c_int,
    pub payload: *mut uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_hrd_t {
    pub cpb_initial_arrival_time: libc::c_double,
    pub cpb_final_arrival_time: libc::c_double,
    pub cpb_removal_time: libc::c_double,
    pub dpb_output_time: libc::c_double,
}
pub type pixel = uint8_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_weight_t {
    pub cachea: [int16_t; 8],
    pub cacheb: [int16_t; 8],
    pub i_denom: int32_t,
    pub i_scale: int32_t,
    pub i_offset: int32_t,
    pub weightfn: *mut weight_fn_t,
}
pub type weight_fn_t = Option::<
    unsafe extern "C" fn(
        *mut pixel,
        intptr_t,
        *mut pixel,
        intptr_t,
        *const x264_weight_t,
        libc::c_int,
    ) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_param_t {
    pub cpu: uint32_t,
    pub i_threads: libc::c_int,
    pub i_lookahead_threads: libc::c_int,
    pub b_sliced_threads: libc::c_int,
    pub b_deterministic: libc::c_int,
    pub b_cpu_independent: libc::c_int,
    pub i_sync_lookahead: libc::c_int,
    pub i_width: libc::c_int,
    pub i_height: libc::c_int,
    pub i_csp: libc::c_int,
    pub i_bitdepth: libc::c_int,
    pub i_level_idc: libc::c_int,
    pub i_frame_total: libc::c_int,
    pub i_nal_hrd: libc::c_int,
    pub vui: C2RustUnnamed_6,
    pub i_frame_reference: libc::c_int,
    pub i_dpb_size: libc::c_int,
    pub i_keyint_max: libc::c_int,
    pub i_keyint_min: libc::c_int,
    pub i_scenecut_threshold: libc::c_int,
    pub b_intra_refresh: libc::c_int,
    pub i_bframe: libc::c_int,
    pub i_bframe_adaptive: libc::c_int,
    pub i_bframe_bias: libc::c_int,
    pub i_bframe_pyramid: libc::c_int,
    pub b_open_gop: libc::c_int,
    pub b_bluray_compat: libc::c_int,
    pub i_avcintra_class: libc::c_int,
    pub i_avcintra_flavor: libc::c_int,
    pub b_deblocking_filter: libc::c_int,
    pub i_deblocking_filter_alphac0: libc::c_int,
    pub i_deblocking_filter_beta: libc::c_int,
    pub b_cabac: libc::c_int,
    pub i_cabac_init_idc: libc::c_int,
    pub b_interlaced: libc::c_int,
    pub b_constrained_intra: libc::c_int,
    pub i_cqm_preset: libc::c_int,
    pub psz_cqm_file: *mut libc::c_char,
    pub cqm_4iy: [uint8_t; 16],
    pub cqm_4py: [uint8_t; 16],
    pub cqm_4ic: [uint8_t; 16],
    pub cqm_4pc: [uint8_t; 16],
    pub cqm_8iy: [uint8_t; 64],
    pub cqm_8py: [uint8_t; 64],
    pub cqm_8ic: [uint8_t; 64],
    pub cqm_8pc: [uint8_t; 64],
    pub pf_log: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            libc::c_int,
            *const libc::c_char,
            ::core::ffi::VaList,
        ) -> (),
    >,
    pub p_log_private: *mut libc::c_void,
    pub i_log_level: libc::c_int,
    pub b_full_recon: libc::c_int,
    pub psz_dump_yuv: *mut libc::c_char,
    pub analyse: C2RustUnnamed_5,
    pub rc: C2RustUnnamed_4,
    pub crop_rect: C2RustUnnamed_3,
    pub i_frame_packing: libc::c_int,
    pub mastering_display: C2RustUnnamed_2,
    pub content_light_level: C2RustUnnamed_1,
    pub i_alternative_transfer: libc::c_int,
    pub b_aud: libc::c_int,
    pub b_repeat_headers: libc::c_int,
    pub b_annexb: libc::c_int,
    pub i_sps_id: libc::c_int,
    pub b_vfr_input: libc::c_int,
    pub b_pulldown: libc::c_int,
    pub i_fps_num: uint32_t,
    pub i_fps_den: uint32_t,
    pub i_timebase_num: uint32_t,
    pub i_timebase_den: uint32_t,
    pub b_tff: libc::c_int,
    pub b_pic_struct: libc::c_int,
    pub b_fake_interlaced: libc::c_int,
    pub b_stitchable: libc::c_int,
    pub b_opencl: libc::c_int,
    pub i_opencl_device: libc::c_int,
    pub opencl_device_id: *mut libc::c_void,
    pub psz_clbin_file: *mut libc::c_char,
    pub i_slice_max_size: libc::c_int,
    pub i_slice_max_mbs: libc::c_int,
    pub i_slice_min_mbs: libc::c_int,
    pub i_slice_count: libc::c_int,
    pub i_slice_count_max: libc::c_int,
    pub param_free: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub nalu_process: Option::<
        unsafe extern "C" fn(*mut x264_t, *mut x264_nal_t, *mut libc::c_void) -> (),
    >,
    pub opaque: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_nal_t {
    pub i_ref_idc: libc::c_int,
    pub i_type: libc::c_int,
    pub b_long_startcode: libc::c_int,
    pub i_first_mb: libc::c_int,
    pub i_last_mb: libc::c_int,
    pub i_payload: libc::c_int,
    pub p_payload: *mut uint8_t,
    pub i_padding: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub b_cll: libc::c_int,
    pub i_max_cll: libc::c_int,
    pub i_max_fall: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub b_mastering_display: libc::c_int,
    pub i_green_x: libc::c_int,
    pub i_green_y: libc::c_int,
    pub i_blue_x: libc::c_int,
    pub i_blue_y: libc::c_int,
    pub i_red_x: libc::c_int,
    pub i_red_y: libc::c_int,
    pub i_white_x: libc::c_int,
    pub i_white_y: libc::c_int,
    pub i_display_max: int64_t,
    pub i_display_min: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub i_left: libc::c_int,
    pub i_top: libc::c_int,
    pub i_right: libc::c_int,
    pub i_bottom: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub i_rc_method: libc::c_int,
    pub i_qp_constant: libc::c_int,
    pub i_qp_min: libc::c_int,
    pub i_qp_max: libc::c_int,
    pub i_qp_step: libc::c_int,
    pub i_bitrate: libc::c_int,
    pub f_rf_constant: libc::c_float,
    pub f_rf_constant_max: libc::c_float,
    pub f_rate_tolerance: libc::c_float,
    pub i_vbv_max_bitrate: libc::c_int,
    pub i_vbv_buffer_size: libc::c_int,
    pub f_vbv_buffer_init: libc::c_float,
    pub f_ip_factor: libc::c_float,
    pub f_pb_factor: libc::c_float,
    pub b_filler: libc::c_int,
    pub i_aq_mode: libc::c_int,
    pub f_aq_strength: libc::c_float,
    pub b_mb_tree: libc::c_int,
    pub i_lookahead: libc::c_int,
    pub b_stat_write: libc::c_int,
    pub psz_stat_out: *mut libc::c_char,
    pub b_stat_read: libc::c_int,
    pub psz_stat_in: *mut libc::c_char,
    pub f_qcompress: libc::c_float,
    pub f_qblur: libc::c_float,
    pub f_complexity_blur: libc::c_float,
    pub zones: *mut x264_zone_t,
    pub i_zones: libc::c_int,
    pub psz_zones: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_zone_t {
    pub i_start: libc::c_int,
    pub i_end: libc::c_int,
    pub b_force_qp: libc::c_int,
    pub i_qp: libc::c_int,
    pub f_bitrate_factor: libc::c_float,
    pub param: *mut x264_param_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub intra: libc::c_uint,
    pub inter: libc::c_uint,
    pub b_transform_8x8: libc::c_int,
    pub i_weighted_pred: libc::c_int,
    pub b_weighted_bipred: libc::c_int,
    pub i_direct_mv_pred: libc::c_int,
    pub i_chroma_qp_offset: libc::c_int,
    pub i_me_method: libc::c_int,
    pub i_me_range: libc::c_int,
    pub i_mv_range: libc::c_int,
    pub i_mv_range_thread: libc::c_int,
    pub i_subpel_refine: libc::c_int,
    pub b_chroma_me: libc::c_int,
    pub b_mixed_references: libc::c_int,
    pub i_trellis: libc::c_int,
    pub b_fast_pskip: libc::c_int,
    pub b_dct_decimate: libc::c_int,
    pub i_noise_reduction: libc::c_int,
    pub f_psy_rd: libc::c_float,
    pub f_psy_trellis: libc::c_float,
    pub b_psy: libc::c_int,
    pub b_mb_info: libc::c_int,
    pub b_mb_info_update: libc::c_int,
    pub i_luma_deadzone: [libc::c_int; 2],
    pub b_psnr: libc::c_int,
    pub b_ssim: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub i_sar_height: libc::c_int,
    pub i_sar_width: libc::c_int,
    pub i_overscan: libc::c_int,
    pub i_vidformat: libc::c_int,
    pub b_fullrange: libc::c_int,
    pub i_colorprim: libc::c_int,
    pub i_transfer: libc::c_int,
    pub i_colmatrix: libc::c_int,
    pub i_chroma_loc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_bitstream_function_t {
    pub nal_escape: Option::<
        unsafe extern "C" fn(*mut uint8_t, *mut uint8_t, *mut uint8_t) -> *mut uint8_t,
    >,
    pub cabac_block_residual_internal: Option::<
        unsafe extern "C" fn(
            *mut dctcoef,
            libc::c_int,
            intptr_t,
            *mut x264_cabac_t,
        ) -> (),
    >,
    pub cabac_block_residual_rd_internal: Option::<
        unsafe extern "C" fn(
            *mut dctcoef,
            libc::c_int,
            intptr_t,
            *mut x264_cabac_t,
        ) -> (),
    >,
    pub cabac_block_residual_8x8_rd_internal: Option::<
        unsafe extern "C" fn(
            *mut dctcoef,
            libc::c_int,
            intptr_t,
            *mut x264_cabac_t,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_cabac_t {
    pub i_low: libc::c_int,
    pub i_range: libc::c_int,
    pub i_queue: libc::c_int,
    pub i_bytes_outstanding: libc::c_int,
    pub p_start: *mut uint8_t,
    pub p: *mut uint8_t,
    pub p_end: *mut uint8_t,
    pub f8_bits_encoded: libc::c_int,
    pub state: [uint8_t; 1024],
    pub padding: [uint8_t; 12],
}
pub type dctcoef = int16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_deblock_function_t {
    pub deblock_luma: [x264_deblock_inter_t; 2],
    pub deblock_chroma: [x264_deblock_inter_t; 2],
    pub deblock_h_chroma_420: x264_deblock_inter_t,
    pub deblock_h_chroma_422: x264_deblock_inter_t,
    pub deblock_luma_intra: [x264_deblock_intra_t; 2],
    pub deblock_chroma_intra: [x264_deblock_intra_t; 2],
    pub deblock_h_chroma_420_intra: x264_deblock_intra_t,
    pub deblock_h_chroma_422_intra: x264_deblock_intra_t,
    pub deblock_luma_mbaff: x264_deblock_inter_t,
    pub deblock_chroma_mbaff: x264_deblock_inter_t,
    pub deblock_chroma_420_mbaff: x264_deblock_inter_t,
    pub deblock_chroma_422_mbaff: x264_deblock_inter_t,
    pub deblock_luma_intra_mbaff: x264_deblock_intra_t,
    pub deblock_chroma_intra_mbaff: x264_deblock_intra_t,
    pub deblock_chroma_420_intra_mbaff: x264_deblock_intra_t,
    pub deblock_chroma_422_intra_mbaff: x264_deblock_intra_t,
    pub deblock_strength: Option::<
        unsafe extern "C" fn(
            *mut uint8_t,
            *mut [int8_t; 40],
            *mut [[int16_t; 2]; 40],
            *mut [[uint8_t; 4]; 8],
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
}
pub type x264_deblock_intra_t = Option::<
    unsafe extern "C" fn(*mut pixel, intptr_t, libc::c_int, libc::c_int) -> (),
>;
pub type x264_deblock_inter_t = Option::<
    unsafe extern "C" fn(
        *mut pixel,
        intptr_t,
        libc::c_int,
        libc::c_int,
        *mut int8_t,
    ) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_quant_function_t {
    pub quant_8x8: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut udctcoef, *mut udctcoef) -> libc::c_int,
    >,
    pub quant_4x4: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut udctcoef, *mut udctcoef) -> libc::c_int,
    >,
    pub quant_4x4x4: Option::<
        unsafe extern "C" fn(
            *mut [dctcoef; 16],
            *mut udctcoef,
            *mut udctcoef,
        ) -> libc::c_int,
    >,
    pub quant_4x4_dc: Option::<
        unsafe extern "C" fn(*mut dctcoef, libc::c_int, libc::c_int) -> libc::c_int,
    >,
    pub quant_2x2_dc: Option::<
        unsafe extern "C" fn(*mut dctcoef, libc::c_int, libc::c_int) -> libc::c_int,
    >,
    pub dequant_8x8: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut [libc::c_int; 64], libc::c_int) -> (),
    >,
    pub dequant_4x4: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut [libc::c_int; 16], libc::c_int) -> (),
    >,
    pub dequant_4x4_dc: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut [libc::c_int; 16], libc::c_int) -> (),
    >,
    pub idct_dequant_2x4_dc: Option::<
        unsafe extern "C" fn(
            *mut dctcoef,
            *mut [dctcoef; 16],
            *mut [libc::c_int; 16],
            libc::c_int,
        ) -> (),
    >,
    pub idct_dequant_2x4_dconly: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut [libc::c_int; 16], libc::c_int) -> (),
    >,
    pub optimize_chroma_2x2_dc: Option::<
        unsafe extern "C" fn(*mut dctcoef, libc::c_int) -> libc::c_int,
    >,
    pub optimize_chroma_2x4_dc: Option::<
        unsafe extern "C" fn(*mut dctcoef, libc::c_int) -> libc::c_int,
    >,
    pub denoise_dct: Option::<
        unsafe extern "C" fn(
            *mut dctcoef,
            *mut uint32_t,
            *mut udctcoef,
            libc::c_int,
        ) -> (),
    >,
    pub decimate_score15: Option::<unsafe extern "C" fn(*mut dctcoef) -> libc::c_int>,
    pub decimate_score16: Option::<unsafe extern "C" fn(*mut dctcoef) -> libc::c_int>,
    pub decimate_score64: Option::<unsafe extern "C" fn(*mut dctcoef) -> libc::c_int>,
    pub coeff_last: [Option::<unsafe extern "C" fn(*mut dctcoef) -> libc::c_int>; 14],
    pub coeff_last4: Option::<unsafe extern "C" fn(*mut dctcoef) -> libc::c_int>,
    pub coeff_last8: Option::<unsafe extern "C" fn(*mut dctcoef) -> libc::c_int>,
    pub coeff_level_run: [Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> libc::c_int,
    >; 13],
    pub coeff_level_run4: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> libc::c_int,
    >,
    pub coeff_level_run8: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> libc::c_int,
    >,
    pub trellis_cabac_4x4: Option::<
        unsafe extern "C" fn(
            *const libc::c_int,
            *const uint8_t,
            libc::c_int,
            libc::c_int,
            *mut dctcoef,
            *mut dctcoef,
            *mut dctcoef,
            *mut uint8_t,
            *mut uint8_t,
            uint64_t,
            uint16_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub trellis_cabac_8x8: Option::<
        unsafe extern "C" fn(
            *const libc::c_int,
            *const uint8_t,
            libc::c_int,
            libc::c_int,
            *mut dctcoef,
            *mut dctcoef,
            *mut dctcoef,
            *mut uint8_t,
            *mut uint8_t,
            uint64_t,
            uint16_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub trellis_cabac_4x4_psy: Option::<
        unsafe extern "C" fn(
            *const libc::c_int,
            *const uint8_t,
            libc::c_int,
            libc::c_int,
            *mut dctcoef,
            *mut dctcoef,
            *mut dctcoef,
            *mut uint8_t,
            *mut uint8_t,
            uint64_t,
            uint16_t,
            libc::c_int,
            *mut dctcoef,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub trellis_cabac_8x8_psy: Option::<
        unsafe extern "C" fn(
            *const libc::c_int,
            *const uint8_t,
            libc::c_int,
            libc::c_int,
            *mut dctcoef,
            *mut dctcoef,
            *mut dctcoef,
            *mut uint8_t,
            *mut uint8_t,
            uint64_t,
            uint16_t,
            libc::c_int,
            *mut dctcoef,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub trellis_cabac_dc: Option::<
        unsafe extern "C" fn(
            *const libc::c_int,
            *const uint8_t,
            libc::c_int,
            libc::c_int,
            *mut dctcoef,
            *mut dctcoef,
            *mut dctcoef,
            *mut uint8_t,
            *mut uint8_t,
            uint64_t,
            uint16_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub trellis_cabac_chroma_422_dc: Option::<
        unsafe extern "C" fn(
            *const libc::c_int,
            *const uint8_t,
            libc::c_int,
            libc::c_int,
            *mut dctcoef,
            *mut dctcoef,
            *mut dctcoef,
            *mut uint8_t,
            *mut uint8_t,
            uint64_t,
            uint16_t,
        ) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_run_level_t {
    pub last: int32_t,
    pub mask: int32_t,
    pub level: [dctcoef; 18],
}
pub type udctcoef = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_zigzag_function_t {
    pub scan_8x8: Option::<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
    pub scan_4x4: Option::<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
    pub sub_8x8: Option::<
        unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> libc::c_int,
    >,
    pub sub_4x4: Option::<
        unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> libc::c_int,
    >,
    pub sub_4x4ac: Option::<
        unsafe extern "C" fn(
            *mut dctcoef,
            *const pixel,
            *mut pixel,
            *mut dctcoef,
        ) -> libc::c_int,
    >,
    pub interleave_8x8_cavlc: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut dctcoef, *mut uint8_t) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_dct_function_t {
    pub sub4x4_dct: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> (),
    >,
    pub add4x4_idct: Option::<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
    pub sub8x8_dct: Option::<
        unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> (),
    >,
    pub sub8x8_dct_dc: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> (),
    >,
    pub add8x8_idct: Option::<
        unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> (),
    >,
    pub add8x8_idct_dc: Option::<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
    pub sub8x16_dct_dc: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> (),
    >,
    pub sub16x16_dct: Option::<
        unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> (),
    >,
    pub add16x16_idct: Option::<
        unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> (),
    >,
    pub add16x16_idct_dc: Option::<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
    pub sub8x8_dct8: Option::<
        unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> (),
    >,
    pub add8x8_idct8: Option::<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
    pub sub16x16_dct8: Option::<
        unsafe extern "C" fn(*mut [dctcoef; 64], *mut pixel, *mut pixel) -> (),
    >,
    pub add16x16_idct8: Option::<
        unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 64]) -> (),
    >,
    pub dct4x4dc: Option::<unsafe extern "C" fn(*mut dctcoef) -> ()>,
    pub idct4x4dc: Option::<unsafe extern "C" fn(*mut dctcoef) -> ()>,
    pub dct2x4dc: Option::<unsafe extern "C" fn(*mut dctcoef, *mut [dctcoef; 16]) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_mc_functions_t {
    pub mc_luma: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            *const x264_weight_t,
        ) -> (),
    >,
    pub get_ref: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            *mut intptr_t,
            *mut *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            *const x264_weight_t,
        ) -> *mut pixel,
    >,
    pub mc_chroma: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub avg: [Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> (),
    >; 12],
    pub copy: [Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> (),
    >; 7],
    pub copy_16x16_unaligned: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> (),
    >,
    pub store_interleave_chroma: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            *mut pixel,
            libc::c_int,
        ) -> (),
    >,
    pub load_deinterleave_chroma_fenc: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, libc::c_int) -> (),
    >,
    pub load_deinterleave_chroma_fdec: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, libc::c_int) -> (),
    >,
    pub plane_copy: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub plane_copy_swap: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub plane_copy_interleave: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub plane_copy_deinterleave: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub plane_copy_deinterleave_yuyv: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub plane_copy_deinterleave_rgb: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub plane_copy_deinterleave_v210: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *mut uint32_t,
            intptr_t,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub hpel_filter: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
            *mut int16_t,
        ) -> (),
    >,
    pub prefetch_fenc: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> (),
    >,
    pub prefetch_fenc_400: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> (),
    >,
    pub prefetch_fenc_420: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> (),
    >,
    pub prefetch_fenc_422: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> (),
    >,
    pub prefetch_ref: Option::<
        unsafe extern "C" fn(*mut pixel, intptr_t, libc::c_int) -> (),
    >,
    pub memcpy_aligned: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_void,
            size_t,
        ) -> *mut libc::c_void,
    >,
    pub memzero_aligned: Option::<unsafe extern "C" fn(*mut libc::c_void, size_t) -> ()>,
    pub integral_init4h: Option::<
        unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> (),
    >,
    pub integral_init8h: Option::<
        unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> (),
    >,
    pub integral_init4v: Option::<
        unsafe extern "C" fn(*mut uint16_t, *mut uint16_t, intptr_t) -> (),
    >,
    pub integral_init8v: Option::<unsafe extern "C" fn(*mut uint16_t, intptr_t) -> ()>,
    pub frame_init_lowres_core: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            intptr_t,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub weight: *mut weight_fn_t,
    pub offsetadd: *mut weight_fn_t,
    pub offsetsub: *mut weight_fn_t,
    pub weight_cache: Option::<
        unsafe extern "C" fn(*mut x264_t, *mut x264_weight_t) -> (),
    >,
    pub mbtree_propagate_cost: Option::<
        unsafe extern "C" fn(
            *mut int16_t,
            *mut uint16_t,
            *mut uint16_t,
            *mut uint16_t,
            *mut uint16_t,
            *mut libc::c_float,
            libc::c_int,
        ) -> (),
    >,
    pub mbtree_propagate_list: Option::<
        unsafe extern "C" fn(
            *mut x264_t,
            *mut uint16_t,
            *mut [int16_t; 2],
            *mut int16_t,
            *mut uint16_t,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> (),
    >,
    pub mbtree_fix8_pack: Option::<
        unsafe extern "C" fn(*mut uint16_t, *mut libc::c_float, libc::c_int) -> (),
    >,
    pub mbtree_fix8_unpack: Option::<
        unsafe extern "C" fn(*mut libc::c_float, *mut uint16_t, libc::c_int) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_pixel_function_t {
    pub sad: [x264_pixel_cmp_t; 8],
    pub ssd: [x264_pixel_cmp_t; 8],
    pub satd: [x264_pixel_cmp_t; 8],
    pub ssim: [x264_pixel_cmp_t; 7],
    pub sa8d: [x264_pixel_cmp_t; 4],
    pub mbcmp: [x264_pixel_cmp_t; 8],
    pub mbcmp_unaligned: [x264_pixel_cmp_t; 8],
    pub fpelcmp: [x264_pixel_cmp_t; 8],
    pub fpelcmp_x3: [x264_pixel_cmp_x3_t; 7],
    pub fpelcmp_x4: [x264_pixel_cmp_x4_t; 7],
    pub sad_aligned: [x264_pixel_cmp_t; 8],
    pub vsad: Option::<
        unsafe extern "C" fn(*mut pixel, intptr_t, libc::c_int) -> libc::c_int,
    >,
    pub asd8: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub sa8d_satd: [Option::<
        unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> uint64_t,
    >; 1],
    pub var: [Option::<unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t>; 4],
    pub var2: [Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> libc::c_int,
    >; 4],
    pub hadamard_ac: [Option::<
        unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t,
    >; 4],
    pub ssd_nv12_core: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            libc::c_int,
            libc::c_int,
            *mut uint64_t,
            *mut uint64_t,
        ) -> (),
    >,
    pub ssim_4x4x2_core: Option::<
        unsafe extern "C" fn(
            *const pixel,
            intptr_t,
            *const pixel,
            intptr_t,
            *mut [libc::c_int; 4],
        ) -> (),
    >,
    pub ssim_end4: Option::<
        unsafe extern "C" fn(
            *mut [libc::c_int; 4],
            *mut [libc::c_int; 4],
            libc::c_int,
        ) -> libc::c_float,
    >,
    pub sad_x3: [x264_pixel_cmp_x3_t; 7],
    pub sad_x4: [x264_pixel_cmp_x4_t; 7],
    pub satd_x3: [x264_pixel_cmp_x3_t; 7],
    pub satd_x4: [x264_pixel_cmp_x4_t; 7],
    pub ads: [Option::<
        unsafe extern "C" fn(
            *mut libc::c_int,
            *mut uint16_t,
            libc::c_int,
            *mut uint16_t,
            *mut int16_t,
            libc::c_int,
            libc::c_int,
        ) -> libc::c_int,
    >; 7],
    pub intra_mbcmp_x3_16x16: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_satd_x3_16x16: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_sad_x3_16x16: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_mbcmp_x3_4x4: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_satd_x3_4x4: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_sad_x3_4x4: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_mbcmp_x3_chroma: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_satd_x3_chroma: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_sad_x3_chroma: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_mbcmp_x3_8x16c: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_satd_x3_8x16c: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_sad_x3_8x16c: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_mbcmp_x3_8x8c: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_satd_x3_8x8c: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_sad_x3_8x8c: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_mbcmp_x3_8x8: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_sa8d_x3_8x8: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_sad_x3_8x8: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut libc::c_int) -> (),
    >,
    pub intra_mbcmp_x9_4x4: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> libc::c_int,
    >,
    pub intra_satd_x9_4x4: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> libc::c_int,
    >,
    pub intra_sad_x9_4x4: Option::<
        unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> libc::c_int,
    >,
    pub intra_mbcmp_x9_8x8: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut uint16_t,
            *mut uint16_t,
        ) -> libc::c_int,
    >,
    pub intra_sa8d_x9_8x8: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut uint16_t,
            *mut uint16_t,
        ) -> libc::c_int,
    >,
    pub intra_sad_x9_8x8: Option::<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut uint16_t,
            *mut uint16_t,
        ) -> libc::c_int,
    >,
}
pub type x264_pixel_cmp_x4_t = Option::<
    unsafe extern "C" fn(
        *mut pixel,
        *mut pixel,
        *mut pixel,
        *mut pixel,
        *mut pixel,
        intptr_t,
        *mut libc::c_int,
    ) -> (),
>;
pub type x264_pixel_cmp_x3_t = Option::<
    unsafe extern "C" fn(
        *mut pixel,
        *mut pixel,
        *mut pixel,
        *mut pixel,
        intptr_t,
        *mut libc::c_int,
    ) -> (),
>;
pub type x264_pixel_cmp_t = Option::<
    unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> libc::c_int,
>;
pub type x264_predict_8x8_filter_t = Option::<
    unsafe extern "C" fn(*mut pixel, *mut pixel, libc::c_int, libc::c_int) -> (),
>;
pub type x264_predict_t = Option::<unsafe extern "C" fn(*mut pixel) -> ()>;
pub type x264_predict8x8_t = Option::<
    unsafe extern "C" fn(*mut pixel, *mut pixel) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub i_frame_count: [libc::c_int; 3],
    pub i_frame_size: [int64_t; 3],
    pub f_frame_qp: [libc::c_double; 3],
    pub i_consecutive_bframes: [libc::c_int; 17],
    pub f_ssd_global: [libc::c_double; 3],
    pub f_psnr_average: [libc::c_double; 3],
    pub f_psnr_mean_y: [libc::c_double; 3],
    pub f_psnr_mean_u: [libc::c_double; 3],
    pub f_psnr_mean_v: [libc::c_double; 3],
    pub f_ssim_mean_y: [libc::c_double; 3],
    pub f_frame_duration: [libc::c_double; 3],
    pub i_mb_count: [[int64_t; 19]; 3],
    pub i_mb_partition: [[int64_t; 17]; 2],
    pub i_mb_count_8x8dct: [int64_t; 2],
    pub i_mb_count_ref: [[[int64_t; 32]; 2]; 2],
    pub i_mb_cbp: [int64_t; 6],
    pub i_mb_pred_mode: [[int64_t; 13]; 4],
    pub i_mb_field: [int64_t; 3],
    pub i_direct_score: [libc::c_int; 2],
    pub i_direct_frames: [libc::c_int; 2],
    pub i_wpred: [libc::c_int; 2],
    pub frame: x264_frame_stat_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_frame_stat_t {
    pub i_mv_bits: libc::c_int,
    pub i_tex_bits: libc::c_int,
    pub i_misc_bits: libc::c_int,
    pub i_mb_count: [libc::c_int; 19],
    pub i_mb_count_i: libc::c_int,
    pub i_mb_count_p: libc::c_int,
    pub i_mb_count_skip: libc::c_int,
    pub i_mb_count_8x8dct: [libc::c_int; 2],
    pub i_mb_count_ref: [[libc::c_int; 32]; 2],
    pub i_mb_partition: [libc::c_int; 17],
    pub i_mb_cbp: [libc::c_int; 6],
    pub i_mb_pred_mode: [[libc::c_int; 13]; 4],
    pub i_mb_field: [libc::c_int; 3],
    pub i_direct_score: [libc::c_int; 2],
    pub i_ssd: [int64_t; 3],
    pub f_ssim: libc::c_double,
    pub i_ssim_cnt: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub i_mb_width: libc::c_int,
    pub i_mb_height: libc::c_int,
    pub i_mb_count: libc::c_int,
    pub chroma_h_shift: libc::c_int,
    pub chroma_v_shift: libc::c_int,
    pub i_mb_stride: libc::c_int,
    pub i_b8_stride: libc::c_int,
    pub i_b4_stride: libc::c_int,
    pub left_b8: [libc::c_int; 2],
    pub left_b4: [libc::c_int; 2],
    pub i_mb_x: libc::c_int,
    pub i_mb_y: libc::c_int,
    pub i_mb_xy: libc::c_int,
    pub i_b8_xy: libc::c_int,
    pub i_b4_xy: libc::c_int,
    pub i_me_method: libc::c_int,
    pub i_subpel_refine: libc::c_int,
    pub b_chroma_me: libc::c_int,
    pub b_trellis: libc::c_int,
    pub b_noise_reduction: libc::c_int,
    pub b_dct_decimate: libc::c_int,
    pub i_psy_rd: libc::c_int,
    pub i_psy_trellis: libc::c_int,
    pub b_interlaced: libc::c_int,
    pub b_adaptive_mbaff: libc::c_int,
    pub mv_min: [libc::c_int; 2],
    pub mv_max: [libc::c_int; 2],
    pub mv_miny_row: [libc::c_int; 3],
    pub mv_maxy_row: [libc::c_int; 3],
    pub mv_min_spel: [libc::c_int; 2],
    pub mv_max_spel: [libc::c_int; 2],
    pub mv_miny_spel_row: [libc::c_int; 3],
    pub mv_maxy_spel_row: [libc::c_int; 3],
    pub mv_limit_fpel: [[int16_t; 2]; 2],
    pub mv_miny_fpel_row: [libc::c_int; 3],
    pub mv_maxy_fpel_row: [libc::c_int; 3],
    pub i_neighbour: libc::c_uint,
    pub i_neighbour8: [libc::c_uint; 4],
    pub i_neighbour4: [libc::c_uint; 16],
    pub i_neighbour_intra: libc::c_uint,
    pub i_neighbour_frame: libc::c_uint,
    pub i_mb_type_top: libc::c_int,
    pub i_mb_type_left: [libc::c_int; 2],
    pub i_mb_type_topleft: libc::c_int,
    pub i_mb_type_topright: libc::c_int,
    pub i_mb_prev_xy: libc::c_int,
    pub i_mb_left_xy: [libc::c_int; 2],
    pub i_mb_top_xy: libc::c_int,
    pub i_mb_topleft_xy: libc::c_int,
    pub i_mb_topright_xy: libc::c_int,
    pub i_mb_top_y: libc::c_int,
    pub i_mb_topleft_y: libc::c_int,
    pub i_mb_topright_y: libc::c_int,
    pub left_index_table: *const x264_left_table_t,
    pub i_mb_top_mbpair_xy: libc::c_int,
    pub topleft_partition: libc::c_int,
    pub b_allow_skip: libc::c_int,
    pub field_decoding_flag: libc::c_int,
    pub base: *mut uint8_t,
    pub type_0: *mut int8_t,
    pub partition: *mut uint8_t,
    pub qp: *mut int8_t,
    pub cbp: *mut int16_t,
    pub intra4x4_pred_mode: *mut [int8_t; 8],
    pub non_zero_count: *mut [uint8_t; 48],
    pub chroma_pred_mode: *mut int8_t,
    pub mv: [*mut [int16_t; 2]; 2],
    pub mvd: [*mut [[uint8_t; 2]; 8]; 2],
    pub ref_0: [*mut int8_t; 2],
    pub mvr: [[*mut [int16_t; 2]; 32]; 2],
    pub skipbp: *mut int8_t,
    pub mb_transform_size: *mut int8_t,
    pub slice_table: *mut int32_t,
    pub field: *mut uint8_t,
    pub p_weight_buf: [*mut pixel; 16],
    pub i_type: libc::c_int,
    pub i_partition: libc::c_int,
    pub i_sub_partition: [uint8_t; 4],
    pub b_transform_8x8: libc::c_int,
    pub i_cbp_luma: libc::c_int,
    pub i_cbp_chroma: libc::c_int,
    pub i_intra16x16_pred_mode: libc::c_int,
    pub i_chroma_pred_mode: libc::c_int,
    pub i_skip_intra: libc::c_int,
    pub b_skip_mc: libc::c_int,
    pub b_reencode_mb: libc::c_int,
    pub ip_offset: libc::c_int,
    pub b_deblock_rdo: libc::c_int,
    pub b_overflow: libc::c_int,
    pub pic: C2RustUnnamed_10,
    pub cache: C2RustUnnamed_9,
    pub i_qp: libc::c_int,
    pub i_chroma_qp: libc::c_int,
    pub i_last_qp: libc::c_int,
    pub i_last_dqp: libc::c_int,
    pub b_variable_qp: libc::c_int,
    pub b_lossless: libc::c_int,
    pub b_direct_auto_read: libc::c_int,
    pub b_direct_auto_write: libc::c_int,
    pub i_trellis_lambda2: [[libc::c_int; 2]; 2],
    pub i_psy_rd_lambda: libc::c_int,
    pub i_chroma_lambda2_offset: libc::c_int,
    pub dist_scale_factor_buf: [[[[int16_t; 4]; 32]; 2]; 2],
    pub dist_scale_factor: *mut [int16_t; 4],
    pub bipred_weight_buf: [[[[int8_t; 4]; 32]; 2]; 2],
    pub bipred_weight: *mut [int8_t; 4],
    pub map_col_to_list0: [int8_t; 18],
    pub ref_blind_dupe: libc::c_int,
    pub deblock_ref_table: [int8_t; 34],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub intra4x4_pred_mode: [int8_t; 40],
    pub non_zero_count: [uint8_t; 120],
    pub ref_0: [[int8_t; 40]; 2],
    pub mv: [[[int16_t; 2]; 40]; 2],
    pub mvd: [[[uint8_t; 2]; 40]; 2],
    pub skip: [int8_t; 40],
    pub direct_mv: [[[int16_t; 2]; 4]; 2],
    pub direct_ref: [[int8_t; 4]; 2],
    pub direct_partition: libc::c_int,
    pub pskip_mv: [int16_t; 2],
    pub i_neighbour_transform_size: libc::c_int,
    pub i_neighbour_skip: libc::c_int,
    pub i_cbp_top: libc::c_int,
    pub i_cbp_left: libc::c_int,
    pub topright_mv: [[[int16_t; 2]; 3]; 2],
    pub topright_ref: [[int8_t; 3]; 2],
    pub deblock_strength: *mut [[uint8_t; 4]; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub fenc_buf: [pixel; 768],
    pub fdec_buf: [pixel; 1728],
    pub i4x4_fdec_buf: [pixel; 256],
    pub i8x8_fdec_buf: [pixel; 256],
    pub i8x8_dct_buf: [[dctcoef; 64]; 3],
    pub i4x4_dct_buf: [[dctcoef; 16]; 15],
    pub i4x4_nnz_buf: [uint32_t; 4],
    pub i8x8_nnz_buf: [uint32_t; 4],
    pub fenc_dct8: [[dctcoef; 64]; 4],
    pub fenc_dct4: [[dctcoef; 16]; 16],
    pub fenc_satd_cache: [uint32_t; 32],
    pub fenc_hadamard_cache: [uint64_t; 9],
    pub i4x4_cbp: libc::c_int,
    pub i8x8_cbp: libc::c_int,
    pub p_fenc: [*mut pixel; 3],
    pub p_fenc_plane: [*mut pixel; 3],
    pub p_fdec: [*mut pixel; 3],
    pub i_fref: [libc::c_int; 2],
    pub p_fref: [[[*mut pixel; 12]; 32]; 2],
    pub p_fref_w: [*mut pixel; 32],
    pub p_integral: [[*mut uint16_t; 16]; 2],
    pub i_stride: [libc::c_int; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_left_table_t {
    pub intra: [uint8_t; 4],
    pub nnz: [uint8_t; 4],
    pub nnz_chroma: [uint8_t; 4],
    pub mv: [uint8_t; 4],
    pub ref_0: [uint8_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub luma16x16_dc: [[dctcoef; 16]; 3],
    pub chroma_dc: [[dctcoef; 8]; 2],
    pub luma8x8: [[dctcoef; 64]; 12],
    pub luma4x4: [[dctcoef; 16]; 48],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub current: *mut *mut x264_frame_t,
    pub unused: [*mut *mut x264_frame_t; 2],
    pub blank_unused: *mut *mut x264_frame_t,
    pub reference: [*mut x264_frame_t; 18],
    pub i_last_keyframe: libc::c_int,
    pub i_last_idr: libc::c_int,
    pub i_poc_last_open_gop: libc::c_int,
    pub i_input: libc::c_int,
    pub i_max_dpb: libc::c_int,
    pub i_max_ref0: libc::c_int,
    pub i_max_ref1: libc::c_int,
    pub i_delay: libc::c_int,
    pub i_bframe_delay: libc::c_int,
    pub i_bframe_delay_time: int64_t,
    pub i_first_pts: int64_t,
    pub i_prev_reordered_pts: [int64_t; 2],
    pub i_largest_pts: int64_t,
    pub i_second_largest_pts: int64_t,
    pub b_have_lowres: libc::c_int,
    pub b_have_sub8x8_esa: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_slice_header_t {
    pub sps: *mut x264_sps_t,
    pub pps: *mut x264_pps_t,
    pub i_type: libc::c_int,
    pub i_first_mb: libc::c_int,
    pub i_last_mb: libc::c_int,
    pub i_pps_id: libc::c_int,
    pub i_frame_num: libc::c_int,
    pub b_mbaff: libc::c_int,
    pub b_field_pic: libc::c_int,
    pub b_bottom_field: libc::c_int,
    pub i_idr_pic_id: libc::c_int,
    pub i_poc: libc::c_int,
    pub i_delta_poc_bottom: libc::c_int,
    pub i_delta_poc: [libc::c_int; 2],
    pub i_redundant_pic_cnt: libc::c_int,
    pub b_direct_spatial_mv_pred: libc::c_int,
    pub b_num_ref_idx_override: libc::c_int,
    pub i_num_ref_idx_l0_active: libc::c_int,
    pub i_num_ref_idx_l1_active: libc::c_int,
    pub b_ref_pic_list_reordering: [libc::c_int; 2],
    pub ref_pic_list_order: [[C2RustUnnamed_14; 16]; 2],
    pub b_weighted_pred: libc::c_int,
    pub weight: [[x264_weight_t; 3]; 32],
    pub i_mmco_remove_from_end: libc::c_int,
    pub i_mmco_command_count: libc::c_int,
    pub mmco: [C2RustUnnamed_13; 16],
    pub i_cabac_init_idc: libc::c_int,
    pub i_qp: libc::c_int,
    pub i_qp_delta: libc::c_int,
    pub b_sp_for_swidth: libc::c_int,
    pub i_qs_delta: libc::c_int,
    pub i_disable_deblocking_filter_idc: libc::c_int,
    pub i_alpha_c0_offset: libc::c_int,
    pub i_beta_offset: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub i_difference_of_pic_nums: libc::c_int,
    pub i_poc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub idc: libc::c_int,
    pub arg: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_pps_t {
    pub i_id: libc::c_int,
    pub i_sps_id: libc::c_int,
    pub b_cabac: libc::c_int,
    pub b_pic_order: libc::c_int,
    pub i_num_slice_groups: libc::c_int,
    pub i_num_ref_idx_l0_default_active: libc::c_int,
    pub i_num_ref_idx_l1_default_active: libc::c_int,
    pub b_weighted_pred: libc::c_int,
    pub b_weighted_bipred: libc::c_int,
    pub i_pic_init_qp: libc::c_int,
    pub i_pic_init_qs: libc::c_int,
    pub i_chroma_qp_index_offset: libc::c_int,
    pub b_deblocking_filter_control: libc::c_int,
    pub b_constrained_intra_pred: libc::c_int,
    pub b_redundant_pic_cnt: libc::c_int,
    pub b_transform_8x8_mode: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_sps_t {
    pub i_id: libc::c_int,
    pub i_profile_idc: libc::c_int,
    pub i_level_idc: libc::c_int,
    pub b_constraint_set0: libc::c_int,
    pub b_constraint_set1: libc::c_int,
    pub b_constraint_set2: libc::c_int,
    pub b_constraint_set3: libc::c_int,
    pub i_log2_max_frame_num: libc::c_int,
    pub i_poc_type: libc::c_int,
    pub i_log2_max_poc_lsb: libc::c_int,
    pub i_num_ref_frames: libc::c_int,
    pub b_gaps_in_frame_num_value_allowed: libc::c_int,
    pub i_mb_width: libc::c_int,
    pub i_mb_height: libc::c_int,
    pub b_frame_mbs_only: libc::c_int,
    pub b_mb_adaptive_frame_field: libc::c_int,
    pub b_direct8x8_inference: libc::c_int,
    pub b_crop: libc::c_int,
    pub crop: C2RustUnnamed_17,
    pub b_vui: libc::c_int,
    pub vui: C2RustUnnamed_15,
    pub b_qpprime_y_zero_transform_bypass: libc::c_int,
    pub i_chroma_format_idc: libc::c_int,
    pub b_avcintra_hd: libc::c_int,
    pub b_avcintra_4k: libc::c_int,
    pub i_cqm_preset: libc::c_int,
    pub scaling_list: [*const uint8_t; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_15 {
    pub b_aspect_ratio_info_present: libc::c_int,
    pub i_sar_width: libc::c_int,
    pub i_sar_height: libc::c_int,
    pub b_overscan_info_present: libc::c_int,
    pub b_overscan_info: libc::c_int,
    pub b_signal_type_present: libc::c_int,
    pub i_vidformat: libc::c_int,
    pub b_fullrange: libc::c_int,
    pub b_color_description_present: libc::c_int,
    pub i_colorprim: libc::c_int,
    pub i_transfer: libc::c_int,
    pub i_colmatrix: libc::c_int,
    pub b_chroma_loc_info_present: libc::c_int,
    pub i_chroma_loc_top: libc::c_int,
    pub i_chroma_loc_bottom: libc::c_int,
    pub b_timing_info_present: libc::c_int,
    pub i_num_units_in_tick: uint32_t,
    pub i_time_scale: uint32_t,
    pub b_fixed_frame_rate: libc::c_int,
    pub b_nal_hrd_parameters_present: libc::c_int,
    pub b_vcl_hrd_parameters_present: libc::c_int,
    pub hrd: C2RustUnnamed_16,
    pub b_pic_struct_present: libc::c_int,
    pub b_bitstream_restriction: libc::c_int,
    pub b_motion_vectors_over_pic_boundaries: libc::c_int,
    pub i_max_bytes_per_pic_denom: libc::c_int,
    pub i_max_bits_per_mb_denom: libc::c_int,
    pub i_log2_max_mv_length_horizontal: libc::c_int,
    pub i_log2_max_mv_length_vertical: libc::c_int,
    pub i_num_reorder_frames: libc::c_int,
    pub i_max_dec_frame_buffering: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub i_cpb_cnt: libc::c_int,
    pub i_bit_rate_scale: libc::c_int,
    pub i_cpb_size_scale: libc::c_int,
    pub i_bit_rate_value: libc::c_int,
    pub i_cpb_size_value: libc::c_int,
    pub i_bit_rate_unscaled: libc::c_int,
    pub i_cpb_size_unscaled: libc::c_int,
    pub b_cbr_hrd: libc::c_int,
    pub i_initial_cpb_removal_delay_length: libc::c_int,
    pub i_cpb_removal_delay_length: libc::c_int,
    pub i_dpb_output_delay_length: libc::c_int,
    pub i_time_offset_length: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub i_left: libc::c_int,
    pub i_right: libc::c_int,
    pub i_top: libc::c_int,
    pub i_bottom: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub ref_0: [[[uint16_t; 33]; 3]; 70],
    pub i4x4_mode: [[uint16_t; 17]; 70],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub i_nal: libc::c_int,
    pub i_nals_allocated: libc::c_int,
    pub nal: *mut x264_nal_t,
    pub i_bitstream: libc::c_int,
    pub p_bitstream: *mut uint8_t,
    pub bs: bs_t,
}
pub type bs_t = bs_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bs_s {
    pub p_start: *mut uint8_t,
    pub p: *mut uint8_t,
    pub p_end: *mut uint8_t,
    pub cur_bits: uintptr_t,
    pub i_left: libc::c_int,
    pub i_bits_encoded: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union x264_union16_t {
    pub i: uint16_t,
    pub b: [uint8_t; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union x264_union32_t {
    pub i: uint32_t,
    pub w: [uint16_t; 2],
    pub b: [uint8_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union x264_union64_t {
    pub i: uint64_t,
    pub d: [uint32_t; 2],
    pub w: [uint16_t; 4],
    pub b: [uint8_t; 8],
}
pub type profile_e = libc::c_uint;
pub const PROFILE_HIGH444_PREDICTIVE: profile_e = 244;
pub const PROFILE_HIGH422: profile_e = 122;
pub const PROFILE_HIGH10: profile_e = 110;
pub const PROFILE_HIGH: profile_e = 100;
pub const PROFILE_MAIN: profile_e = 77;
pub const PROFILE_BASELINE: profile_e = 66;
pub type chroma_format_e = libc::c_uint;
pub const CHROMA_444: chroma_format_e = 3;
pub const CHROMA_422: chroma_format_e = 2;
pub const CHROMA_420: chroma_format_e = 1;
pub const CHROMA_400: chroma_format_e = 0;
pub type slice_type_e = libc::c_uint;
pub const SLICE_TYPE_I: slice_type_e = 2;
pub const SLICE_TYPE_B: slice_type_e = 1;
pub const SLICE_TYPE_P: slice_type_e = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vlc_t {
    pub i_bits: uint8_t,
    pub i_size: uint8_t,
}
pub type pixel4 = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vlc_large_t {
    pub i_bits: uint16_t,
    pub i_size: uint8_t,
    pub i_next: uint8_t,
}
pub type cqm4_e = libc::c_uint;
pub const CQM_4PC: cqm4_e = 3;
pub const CQM_4IC: cqm4_e = 2;
pub const CQM_4PY: cqm4_e = 1;
pub const CQM_4IY: cqm4_e = 0;
pub type cqm8_e = libc::c_uint;
pub const CQM_8PC: cqm8_e = 3;
pub const CQM_8IC: cqm8_e = 2;
pub const CQM_8PY: cqm8_e = 1;
pub const CQM_8IY: cqm8_e = 0;
pub type intra_chroma_pred_e = libc::c_uint;
pub const I_PRED_CHROMA_DC_128: intra_chroma_pred_e = 6;
pub const I_PRED_CHROMA_DC_TOP: intra_chroma_pred_e = 5;
pub const I_PRED_CHROMA_DC_LEFT: intra_chroma_pred_e = 4;
pub const I_PRED_CHROMA_P: intra_chroma_pred_e = 3;
pub const I_PRED_CHROMA_V: intra_chroma_pred_e = 2;
pub const I_PRED_CHROMA_H: intra_chroma_pred_e = 1;
pub const I_PRED_CHROMA_DC: intra_chroma_pred_e = 0;
pub type intra16x16_pred_e = libc::c_uint;
pub const I_PRED_16x16_DC_128: intra16x16_pred_e = 6;
pub const I_PRED_16x16_DC_TOP: intra16x16_pred_e = 5;
pub const I_PRED_16x16_DC_LEFT: intra16x16_pred_e = 4;
pub const I_PRED_16x16_P: intra16x16_pred_e = 3;
pub const I_PRED_16x16_DC: intra16x16_pred_e = 2;
pub const I_PRED_16x16_H: intra16x16_pred_e = 1;
pub const I_PRED_16x16_V: intra16x16_pred_e = 0;
pub type intra4x4_pred_e = libc::c_uint;
pub const I_PRED_4x4_DC_128: intra4x4_pred_e = 11;
pub const I_PRED_4x4_DC_TOP: intra4x4_pred_e = 10;
pub const I_PRED_4x4_DC_LEFT: intra4x4_pred_e = 9;
pub const I_PRED_4x4_HU: intra4x4_pred_e = 8;
pub const I_PRED_4x4_VL: intra4x4_pred_e = 7;
pub const I_PRED_4x4_HD: intra4x4_pred_e = 6;
pub const I_PRED_4x4_VR: intra4x4_pred_e = 5;
pub const I_PRED_4x4_DDR: intra4x4_pred_e = 4;
pub const I_PRED_4x4_DDL: intra4x4_pred_e = 3;
pub const I_PRED_4x4_DC: intra4x4_pred_e = 2;
pub const I_PRED_4x4_H: intra4x4_pred_e = 1;
pub const I_PRED_4x4_V: intra4x4_pred_e = 0;
pub type C2RustUnnamed_20 = libc::c_uint;
pub const PIXEL_2x2: C2RustUnnamed_20 = 11;
pub const PIXEL_2x4: C2RustUnnamed_20 = 10;
pub const PIXEL_2x8: C2RustUnnamed_20 = 9;
pub const PIXEL_4x2: C2RustUnnamed_20 = 8;
pub const PIXEL_4x16: C2RustUnnamed_20 = 7;
pub const PIXEL_4x4: C2RustUnnamed_20 = 6;
pub const PIXEL_4x8: C2RustUnnamed_20 = 5;
pub const PIXEL_8x4: C2RustUnnamed_20 = 4;
pub const PIXEL_8x8: C2RustUnnamed_20 = 3;
pub const PIXEL_8x16: C2RustUnnamed_20 = 2;
pub const PIXEL_16x8: C2RustUnnamed_20 = 1;
pub const PIXEL_16x16: C2RustUnnamed_20 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub w: uint8_t,
    pub h: uint8_t,
}
pub type macroblock_position_e = libc::c_uint;
pub const ALL_NEIGHBORS: macroblock_position_e = 15;
pub const MB_PRIVATE: macroblock_position_e = 16;
pub const MB_TOPLEFT: macroblock_position_e = 8;
pub const MB_TOPRIGHT: macroblock_position_e = 4;
pub const MB_TOP: macroblock_position_e = 2;
pub const MB_LEFT: macroblock_position_e = 1;
pub type mb_class_e = libc::c_uint;
pub const X264_MBTYPE_MAX: mb_class_e = 19;
pub const B_SKIP: mb_class_e = 18;
pub const B_8x8: mb_class_e = 17;
pub const B_BI_BI: mb_class_e = 16;
pub const B_BI_L1: mb_class_e = 15;
pub const B_BI_L0: mb_class_e = 14;
pub const B_L1_BI: mb_class_e = 13;
pub const B_L1_L1: mb_class_e = 12;
pub const B_L1_L0: mb_class_e = 11;
pub const B_L0_BI: mb_class_e = 10;
pub const B_L0_L1: mb_class_e = 9;
pub const B_L0_L0: mb_class_e = 8;
pub const B_DIRECT: mb_class_e = 7;
pub const P_SKIP: mb_class_e = 6;
pub const P_8x8: mb_class_e = 5;
pub const P_L0: mb_class_e = 4;
pub const I_PCM: mb_class_e = 3;
pub const I_16x16: mb_class_e = 2;
pub const I_8x8: mb_class_e = 1;
pub const I_4x4: mb_class_e = 0;
pub type mb_partition_e = libc::c_uint;
pub const X264_PARTTYPE_MAX: mb_partition_e = 17;
pub const D_16x16: mb_partition_e = 16;
pub const D_8x16: mb_partition_e = 15;
pub const D_16x8: mb_partition_e = 14;
pub const D_8x8: mb_partition_e = 13;
pub const D_DIRECT_8x8: mb_partition_e = 12;
pub const D_BI_8x8: mb_partition_e = 11;
pub const D_BI_4x8: mb_partition_e = 10;
pub const D_BI_8x4: mb_partition_e = 9;
pub const D_BI_4x4: mb_partition_e = 8;
pub const D_L1_8x8: mb_partition_e = 7;
pub const D_L1_4x8: mb_partition_e = 6;
pub const D_L1_8x4: mb_partition_e = 5;
pub const D_L1_4x4: mb_partition_e = 4;
pub const D_L0_8x8: mb_partition_e = 3;
pub const D_L0_4x8: mb_partition_e = 2;
pub const D_L0_8x4: mb_partition_e = 1;
pub const D_L0_4x4: mb_partition_e = 0;
pub type cabac_ctx_block_cat_e = libc::c_uint;
pub const DCT_CHROMAV_8x8: cabac_ctx_block_cat_e = 13;
pub const DCT_CHROMAV_4x4: cabac_ctx_block_cat_e = 12;
pub const DCT_CHROMAV_AC: cabac_ctx_block_cat_e = 11;
pub const DCT_CHROMAV_DC: cabac_ctx_block_cat_e = 10;
pub const DCT_CHROMAU_8x8: cabac_ctx_block_cat_e = 9;
pub const DCT_CHROMAU_4x4: cabac_ctx_block_cat_e = 8;
pub const DCT_CHROMAU_AC: cabac_ctx_block_cat_e = 7;
pub const DCT_CHROMAU_DC: cabac_ctx_block_cat_e = 6;
pub const DCT_LUMA_8x8: cabac_ctx_block_cat_e = 5;
pub const DCT_CHROMA_AC: cabac_ctx_block_cat_e = 4;
pub const DCT_CHROMA_DC: cabac_ctx_block_cat_e = 3;
pub const DCT_LUMA_4x4: cabac_ctx_block_cat_e = 2;
pub const DCT_LUMA_AC: cabac_ctx_block_cat_e = 1;
pub const DCT_LUMA_DC: cabac_ctx_block_cat_e = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union x264_union128_sse_t {
    pub i: __m128,
    pub q: [uint64_t; 2],
    pub d: [uint32_t; 4],
    pub w: [uint16_t; 8],
    pub b: [uint8_t; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trellis_level_t {
    pub next: uint16_t,
    pub abs_level: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct trellis_node_t {
    pub score: uint64_t,
    pub level_idx: libc::c_int,
    pub cabac_state: [uint8_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_me_t {
    pub i_pixel: libc::c_int,
    pub p_cost_mv: *mut uint16_t,
    pub i_ref_cost: libc::c_int,
    pub i_ref: libc::c_int,
    pub weight: *const x264_weight_t,
    pub p_fref: [*mut pixel; 12],
    pub p_fref_w: *mut pixel,
    pub p_fenc: [*mut pixel; 3],
    pub integral: *mut uint16_t,
    pub i_stride: [libc::c_int; 3],
    pub mvp: [int16_t; 2],
    pub cost_mv: libc::c_int,
    pub cost: libc::c_int,
    pub mv: [int16_t; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_mb_analysis_t {
    pub i_lambda: libc::c_int,
    pub i_lambda2: libc::c_int,
    pub i_qp: libc::c_int,
    pub p_cost_mv: *mut uint16_t,
    pub p_cost_ref: [*mut uint16_t; 2],
    pub i_mbrd: libc::c_int,
    pub b_fast_intra: libc::c_int,
    pub b_force_intra: libc::c_int,
    pub b_avoid_topright: libc::c_int,
    pub b_try_skip: libc::c_int,
    pub i_satd_i16x16: libc::c_int,
    pub i_satd_i16x16_dir: [libc::c_int; 7],
    pub i_predict16x16: libc::c_int,
    pub i_satd_i8x8: libc::c_int,
    pub i_cbp_i8x8_luma: libc::c_int,
    pub i_satd_i8x8_dir: [[uint16_t; 16]; 4],
    pub i_predict8x8: [libc::c_int; 4],
    pub i_satd_i4x4: libc::c_int,
    pub i_predict4x4: [libc::c_int; 16],
    pub i_satd_pcm: libc::c_int,
    pub i_satd_chroma: libc::c_int,
    pub i_satd_chroma_dir: [libc::c_int; 7],
    pub i_predict8x8chroma: libc::c_int,
    pub l0: x264_mb_analysis_list_t,
    pub l1: x264_mb_analysis_list_t,
    pub i_cost16x16bi: libc::c_int,
    pub i_cost16x16direct: libc::c_int,
    pub i_cost8x8bi: libc::c_int,
    pub i_cost8x8direct: [libc::c_int; 4],
    pub i_satd8x8: [[libc::c_int; 4]; 3],
    pub i_cost_est16x8: [libc::c_int; 2],
    pub i_cost_est8x16: [libc::c_int; 2],
    pub i_cost16x8bi: libc::c_int,
    pub i_cost8x16bi: libc::c_int,
    pub i_rd16x16bi: libc::c_int,
    pub i_rd16x16direct: libc::c_int,
    pub i_rd16x8bi: libc::c_int,
    pub i_rd8x16bi: libc::c_int,
    pub i_rd8x8bi: libc::c_int,
    pub i_mb_partition16x8: [libc::c_int; 2],
    pub i_mb_partition8x16: [libc::c_int; 2],
    pub i_mb_type16x8: libc::c_int,
    pub i_mb_type8x16: libc::c_int,
    pub b_direct_available: libc::c_int,
    pub b_early_terminate: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_mb_analysis_list_t {
    pub me16x16: x264_me_t,
    pub bi16x16: x264_me_t,
    pub me8x8: [x264_me_t; 4],
    pub me4x4: [[x264_me_t; 4]; 4],
    pub me8x4: [[x264_me_t; 2]; 4],
    pub me4x8: [[x264_me_t; 2]; 4],
    pub me16x8: [x264_me_t; 2],
    pub me8x16: [x264_me_t; 2],
    pub i_rd16x16: libc::c_int,
    pub i_cost8x8: libc::c_int,
    pub i_cost4x4: [libc::c_int; 4],
    pub i_cost8x4: [libc::c_int; 4],
    pub i_cost4x8: [libc::c_int; 4],
    pub i_cost16x8: libc::c_int,
    pub i_cost8x16: libc::c_int,
    pub mvc: [[[int16_t; 2]; 6]; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct x264_slicetype_slice_t {
    pub h: *mut x264_t,
    pub a: *mut x264_mb_analysis_t,
    pub frames: *mut *mut x264_frame_t,
    pub p0: libc::c_int,
    pub p1: libc::c_int,
    pub b: libc::c_int,
    pub dist_scale_factor: libc::c_int,
    pub do_search: *mut libc::c_int,
    pub w: *const x264_weight_t,
    pub output_inter: *mut libc::c_int,
    pub output_intra: *mut libc::c_int,
}
static mut x264_b_pyramid_names: [*const libc::c_char; 4] = [
    b"none\0" as *const u8 as *const libc::c_char,
    b"strict\0" as *const u8 as *const libc::c_char,
    b"normal\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
];
static mut x264_ue_size_tab: [uint8_t; 256] = [
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    13 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
    15 as libc::c_int as uint8_t,
];
#[inline(always)]
unsafe extern "C" fn bs_size_ue(mut val: libc::c_uint) -> libc::c_int {
    return x264_ue_size_tab[val.wrapping_add(1 as libc::c_int as libc::c_uint) as usize]
        as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn bs_size_ue_big(mut val: libc::c_uint) -> libc::c_int {
    if val < 255 as libc::c_int as libc::c_uint {
        return x264_ue_size_tab[val.wrapping_add(1 as libc::c_int as libc::c_uint)
            as usize] as libc::c_int
    } else {
        return x264_ue_size_tab[(val.wrapping_add(1 as libc::c_int as libc::c_uint)
            >> 8 as libc::c_int) as usize] as libc::c_int + 16 as libc::c_int
    };
}
#[inline(always)]
unsafe extern "C" fn bs_size_se(mut val: libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 1 as libc::c_int - val * 2 as libc::c_int;
    if tmp < 0 as libc::c_int {
        tmp = val * 2 as libc::c_int;
    }
    if tmp < 256 as libc::c_int {
        return x264_ue_size_tab[tmp as usize] as libc::c_int
    } else {
        return x264_ue_size_tab[(tmp >> 8 as libc::c_int) as usize] as libc::c_int
            + 16 as libc::c_int
    };
}
#[inline(always)]
unsafe extern "C" fn bs_size_te(
    mut x: libc::c_int,
    mut val: libc::c_int,
) -> libc::c_int {
    if x == 1 as libc::c_int {
        return 1 as libc::c_int
    } else {
        return x264_ue_size_tab[(val + 1 as libc::c_int) as usize] as libc::c_int
    };
}
#[inline(always)]
unsafe extern "C" fn x264_cabac_size_decision(
    mut cb: *mut x264_cabac_t,
    mut i_ctx: libc::c_long,
    mut b: libc::c_long,
) {
    let mut i_state: libc::c_int = (*cb).state[i_ctx as usize] as libc::c_int;
    (*cb).state[i_ctx as usize] = x264_cabac_transition[i_state as usize][b as usize];
    (*cb).f8_bits_encoded
        += x264_cabac_entropy[(i_state as libc::c_long ^ b) as usize] as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn x264_cabac_size_decision2(
    mut state: *mut uint8_t,
    mut b: libc::c_long,
) -> libc::c_int {
    let mut i_state: libc::c_int = *state as libc::c_int;
    *state = x264_cabac_transition[i_state as usize][b as usize];
    return x264_cabac_entropy[(i_state as libc::c_long ^ b) as usize] as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn x264_cabac_size_decision_noup(
    mut cb: *mut x264_cabac_t,
    mut i_ctx: libc::c_long,
    mut b: libc::c_long,
) {
    let mut i_state: libc::c_int = (*cb).state[i_ctx as usize] as libc::c_int;
    (*cb).f8_bits_encoded
        += x264_cabac_entropy[(i_state as libc::c_long ^ b) as usize] as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn x264_cabac_size_decision_noup2(
    mut state: *mut uint8_t,
    mut b: libc::c_long,
) -> libc::c_int {
    return x264_cabac_entropy[(*state as libc::c_long ^ b) as usize] as libc::c_int;
}
static mut x264_mb_chroma_pred_mode_fix: [uint8_t; 7] = [
    I_PRED_CHROMA_DC as libc::c_int as uint8_t,
    I_PRED_CHROMA_H as libc::c_int as uint8_t,
    I_PRED_CHROMA_V as libc::c_int as uint8_t,
    I_PRED_CHROMA_P as libc::c_int as uint8_t,
    I_PRED_CHROMA_DC as libc::c_int as uint8_t,
    I_PRED_CHROMA_DC as libc::c_int as uint8_t,
    I_PRED_CHROMA_DC as libc::c_int as uint8_t,
];
static mut x264_mb_pred_mode16x16_fix: [uint8_t; 7] = [
    I_PRED_16x16_V as libc::c_int as uint8_t,
    I_PRED_16x16_H as libc::c_int as uint8_t,
    I_PRED_16x16_DC as libc::c_int as uint8_t,
    I_PRED_16x16_P as libc::c_int as uint8_t,
    I_PRED_16x16_DC as libc::c_int as uint8_t,
    I_PRED_16x16_DC as libc::c_int as uint8_t,
    I_PRED_16x16_DC as libc::c_int as uint8_t,
];
static mut x264_mb_pred_mode4x4_fix: [int8_t; 13] = [
    -(1 as libc::c_int) as int8_t,
    I_PRED_4x4_V as libc::c_int as int8_t,
    I_PRED_4x4_H as libc::c_int as int8_t,
    I_PRED_4x4_DC as libc::c_int as int8_t,
    I_PRED_4x4_DDL as libc::c_int as int8_t,
    I_PRED_4x4_DDR as libc::c_int as int8_t,
    I_PRED_4x4_VR as libc::c_int as int8_t,
    I_PRED_4x4_HD as libc::c_int as int8_t,
    I_PRED_4x4_VL as libc::c_int as int8_t,
    I_PRED_4x4_HU as libc::c_int as int8_t,
    I_PRED_4x4_DC as libc::c_int as int8_t,
    I_PRED_4x4_DC as libc::c_int as int8_t,
    I_PRED_4x4_DC as libc::c_int as int8_t,
];
static mut x264_pixel_size: [C2RustUnnamed_21; 12] = [
    {
        let mut init = C2RustUnnamed_21 {
            w: 16 as libc::c_int as uint8_t,
            h: 16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 16 as libc::c_int as uint8_t,
            h: 8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 8 as libc::c_int as uint8_t,
            h: 16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 8 as libc::c_int as uint8_t,
            h: 8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 8 as libc::c_int as uint8_t,
            h: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 4 as libc::c_int as uint8_t,
            h: 8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 4 as libc::c_int as uint8_t,
            h: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 4 as libc::c_int as uint8_t,
            h: 16 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 4 as libc::c_int as uint8_t,
            h: 2 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 2 as libc::c_int as uint8_t,
            h: 8 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 2 as libc::c_int as uint8_t,
            h: 4 as libc::c_int as uint8_t,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_21 {
            w: 2 as libc::c_int as uint8_t,
            h: 2 as libc::c_int as uint8_t,
        };
        init
    },
];
#[inline(always)]
unsafe extern "C" fn x264_ctz_4bit(mut x: uint32_t) -> libc::c_int {
    static mut lut: [uint8_t; 16] = [
        4 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
    ];
    return lut[x as usize] as libc::c_int;
}
static mut x264_scan8: [uint8_t; 51] = [
    (4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 2 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 2 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 2 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 2 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 3 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 3 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 4 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 4 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 3 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 3 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 4 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 4 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 6 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 6 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 7 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 7 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 6 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 6 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 7 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 7 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 8 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 8 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 9 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 9 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 8 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 8 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 9 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 9 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 11 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 11 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 12 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 12 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 11 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 11 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 12 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 12 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 13 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 13 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (4 as libc::c_int + 14 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (5 as libc::c_int + 14 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 13 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 13 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (6 as libc::c_int + 14 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (7 as libc::c_int + 14 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (0 as libc::c_int + 0 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (0 as libc::c_int + 5 as libc::c_int * 8 as libc::c_int) as uint8_t,
    (0 as libc::c_int + 10 as libc::c_int * 8 as libc::c_int) as uint8_t,
];
#[inline(always)]
unsafe extern "C" fn x264_clip3(
    mut v: libc::c_int,
    mut i_min: libc::c_int,
    mut i_max: libc::c_int,
) -> libc::c_int {
    return if v < i_min { i_min } else if v > i_max { i_max } else { v };
}
#[inline(always)]
unsafe extern "C" fn x264_clip3f(
    mut v: libc::c_double,
    mut f_min: libc::c_double,
    mut f_max: libc::c_double,
) -> libc::c_double {
    return if v < f_min { f_min } else if v > f_max { f_max } else { v };
}
#[inline(always)]
unsafe extern "C" fn x264_exp2fix8(mut x: libc::c_float) -> libc::c_int {
    let mut i: libc::c_int = (x * (-64.0f32 / 6.0f32) + 512.5f32) as libc::c_int;
    if i < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if i > 1023 as libc::c_int {
        return 0xffff as libc::c_int;
    }
    return (x264_exp2_lut[(i & 63 as libc::c_int) as usize] as libc::c_int
        + 256 as libc::c_int) << (i >> 6 as libc::c_int) >> 8 as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn x264_log2(mut x: uint32_t) -> libc::c_float {
    let mut lz: libc::c_int = x.leading_zeros() as i32;
    return x264_log2_lut[(x << lz >> 24 as libc::c_int & 0x7f as libc::c_int as uint32_t)
        as usize] + x264_log2_lz_lut[lz as usize];
}
#[inline(always)]
unsafe extern "C" fn x264_median(
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
) -> libc::c_int {
    let mut t: libc::c_int = a - b & a - b >> 31 as libc::c_int;
    a -= t;
    b += t;
    b -= b - c & b - c >> 31 as libc::c_int;
    b += a - b & a - b >> 31 as libc::c_int;
    return b;
}
#[inline(always)]
unsafe extern "C" fn x264_median_mv(
    mut dst: *mut int16_t,
    mut a: *mut int16_t,
    mut b: *mut int16_t,
    mut c: *mut int16_t,
) {
    *dst
        .offset(
            0 as libc::c_int as isize,
        ) = x264_median(
        *a.offset(0 as libc::c_int as isize) as libc::c_int,
        *b.offset(0 as libc::c_int as isize) as libc::c_int,
        *c.offset(0 as libc::c_int as isize) as libc::c_int,
    ) as int16_t;
    *dst
        .offset(
            1 as libc::c_int as isize,
        ) = x264_median(
        *a.offset(1 as libc::c_int as isize) as libc::c_int,
        *b.offset(1 as libc::c_int as isize) as libc::c_int,
        *c.offset(1 as libc::c_int as isize) as libc::c_int,
    ) as int16_t;
}
#[inline(always)]
unsafe extern "C" fn x264_cabac_mvd_sum(
    mut mvdleft: *mut uint8_t,
    mut mvdtop: *mut uint8_t,
) -> uint16_t {
    let mut amvd0: libc::c_int = *mvdleft.offset(0 as libc::c_int as isize)
        as libc::c_int + *mvdtop.offset(0 as libc::c_int as isize) as libc::c_int;
    let mut amvd1: libc::c_int = *mvdleft.offset(1 as libc::c_int as isize)
        as libc::c_int + *mvdtop.offset(1 as libc::c_int as isize) as libc::c_int;
    amvd0 = (amvd0 > 2 as libc::c_int) as libc::c_int
        + (amvd0 > 32 as libc::c_int) as libc::c_int;
    amvd1 = (amvd1 > 2 as libc::c_int) as libc::c_int
        + (amvd1 > 32 as libc::c_int) as libc::c_int;
    return (amvd0 + (amvd1 << 8 as libc::c_int)) as uint16_t;
}
static mut x264_pred_i4x4_neighbors: [uint8_t; 12] = [
    MB_TOP as libc::c_int as uint8_t,
    MB_LEFT as libc::c_int as uint8_t,
    (MB_LEFT as libc::c_int | MB_TOP as libc::c_int) as uint8_t,
    (MB_TOP as libc::c_int | MB_TOPRIGHT as libc::c_int) as uint8_t,
    (MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int | MB_TOP as libc::c_int)
        as uint8_t,
    (MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int | MB_TOP as libc::c_int)
        as uint8_t,
    (MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int | MB_TOP as libc::c_int)
        as uint8_t,
    (MB_TOP as libc::c_int | MB_TOPRIGHT as libc::c_int) as uint8_t,
    MB_LEFT as libc::c_int as uint8_t,
    MB_LEFT as libc::c_int as uint8_t,
    MB_TOP as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
];
static mut x264_mb_type_list_table: [[[uint8_t; 2]; 2]; 19] = [
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [1 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [1 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
    ],
    [
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
        [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
    [
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
        [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
    ],
];
static mut x264_mb_partition_listX_table: [[uint8_t; 17]; 2] = [
    [
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
    ],
    [
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
    ],
];
static mut x264_zigzag_scan4: [[uint8_t; 16]; 2] = [
    [
        0 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        5 as libc::c_int as uint8_t,
        8 as libc::c_int as uint8_t,
        12 as libc::c_int as uint8_t,
        9 as libc::c_int as uint8_t,
        6 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
        10 as libc::c_int as uint8_t,
        13 as libc::c_int as uint8_t,
        14 as libc::c_int as uint8_t,
        11 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
    ],
    [
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        5 as libc::c_int as uint8_t,
        6 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
        8 as libc::c_int as uint8_t,
        9 as libc::c_int as uint8_t,
        10 as libc::c_int as uint8_t,
        11 as libc::c_int as uint8_t,
        12 as libc::c_int as uint8_t,
        13 as libc::c_int as uint8_t,
        14 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
    ],
];
static mut x264_zigzag_scan8: [[uint8_t; 64]; 2] = [
    [
        0 as libc::c_int as uint8_t,
        8 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        9 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        24 as libc::c_int as uint8_t,
        17 as libc::c_int as uint8_t,
        10 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        11 as libc::c_int as uint8_t,
        18 as libc::c_int as uint8_t,
        25 as libc::c_int as uint8_t,
        32 as libc::c_int as uint8_t,
        40 as libc::c_int as uint8_t,
        33 as libc::c_int as uint8_t,
        26 as libc::c_int as uint8_t,
        19 as libc::c_int as uint8_t,
        12 as libc::c_int as uint8_t,
        5 as libc::c_int as uint8_t,
        6 as libc::c_int as uint8_t,
        13 as libc::c_int as uint8_t,
        20 as libc::c_int as uint8_t,
        27 as libc::c_int as uint8_t,
        34 as libc::c_int as uint8_t,
        41 as libc::c_int as uint8_t,
        48 as libc::c_int as uint8_t,
        56 as libc::c_int as uint8_t,
        49 as libc::c_int as uint8_t,
        42 as libc::c_int as uint8_t,
        35 as libc::c_int as uint8_t,
        28 as libc::c_int as uint8_t,
        21 as libc::c_int as uint8_t,
        14 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
        22 as libc::c_int as uint8_t,
        29 as libc::c_int as uint8_t,
        36 as libc::c_int as uint8_t,
        43 as libc::c_int as uint8_t,
        50 as libc::c_int as uint8_t,
        57 as libc::c_int as uint8_t,
        58 as libc::c_int as uint8_t,
        51 as libc::c_int as uint8_t,
        44 as libc::c_int as uint8_t,
        37 as libc::c_int as uint8_t,
        30 as libc::c_int as uint8_t,
        23 as libc::c_int as uint8_t,
        31 as libc::c_int as uint8_t,
        38 as libc::c_int as uint8_t,
        45 as libc::c_int as uint8_t,
        52 as libc::c_int as uint8_t,
        59 as libc::c_int as uint8_t,
        60 as libc::c_int as uint8_t,
        53 as libc::c_int as uint8_t,
        46 as libc::c_int as uint8_t,
        39 as libc::c_int as uint8_t,
        47 as libc::c_int as uint8_t,
        54 as libc::c_int as uint8_t,
        61 as libc::c_int as uint8_t,
        62 as libc::c_int as uint8_t,
        55 as libc::c_int as uint8_t,
        63 as libc::c_int as uint8_t,
    ],
    [
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        8 as libc::c_int as uint8_t,
        9 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        10 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        11 as libc::c_int as uint8_t,
        5 as libc::c_int as uint8_t,
        6 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
        12 as libc::c_int as uint8_t,
        17 as libc::c_int as uint8_t,
        24 as libc::c_int as uint8_t,
        18 as libc::c_int as uint8_t,
        13 as libc::c_int as uint8_t,
        14 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
        19 as libc::c_int as uint8_t,
        25 as libc::c_int as uint8_t,
        32 as libc::c_int as uint8_t,
        26 as libc::c_int as uint8_t,
        20 as libc::c_int as uint8_t,
        21 as libc::c_int as uint8_t,
        22 as libc::c_int as uint8_t,
        23 as libc::c_int as uint8_t,
        27 as libc::c_int as uint8_t,
        33 as libc::c_int as uint8_t,
        40 as libc::c_int as uint8_t,
        34 as libc::c_int as uint8_t,
        28 as libc::c_int as uint8_t,
        29 as libc::c_int as uint8_t,
        30 as libc::c_int as uint8_t,
        31 as libc::c_int as uint8_t,
        35 as libc::c_int as uint8_t,
        41 as libc::c_int as uint8_t,
        48 as libc::c_int as uint8_t,
        42 as libc::c_int as uint8_t,
        36 as libc::c_int as uint8_t,
        37 as libc::c_int as uint8_t,
        38 as libc::c_int as uint8_t,
        39 as libc::c_int as uint8_t,
        43 as libc::c_int as uint8_t,
        49 as libc::c_int as uint8_t,
        50 as libc::c_int as uint8_t,
        44 as libc::c_int as uint8_t,
        45 as libc::c_int as uint8_t,
        46 as libc::c_int as uint8_t,
        47 as libc::c_int as uint8_t,
        51 as libc::c_int as uint8_t,
        56 as libc::c_int as uint8_t,
        57 as libc::c_int as uint8_t,
        52 as libc::c_int as uint8_t,
        53 as libc::c_int as uint8_t,
        54 as libc::c_int as uint8_t,
        55 as libc::c_int as uint8_t,
        58 as libc::c_int as uint8_t,
        59 as libc::c_int as uint8_t,
        60 as libc::c_int as uint8_t,
        61 as libc::c_int as uint8_t,
        62 as libc::c_int as uint8_t,
        63 as libc::c_int as uint8_t,
    ],
];
static mut block_idx_x: [uint8_t; 16] = [
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
];
static mut block_idx_y: [uint8_t; 16] = [
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
];
static mut block_idx_xy_fenc: [uint8_t; 16] = [
    (0 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (0 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (0 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (0 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 16 as libc::c_int) as uint8_t,
];
static mut block_idx_xy_fdec: [uint16_t; 16] = [
    (0 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (0 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 0 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 1 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (0 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (0 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (1 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 2 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (2 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
    (3 as libc::c_int * 4 as libc::c_int
        + 3 as libc::c_int * 4 as libc::c_int * 32 as libc::c_int) as uint16_t,
];
static mut ctx_cat_plane: [[uint8_t; 3]; 6] = [
    [
        DCT_LUMA_DC as libc::c_int as uint8_t,
        DCT_CHROMAU_DC as libc::c_int as uint8_t,
        DCT_CHROMAV_DC as libc::c_int as uint8_t,
    ],
    [
        DCT_LUMA_AC as libc::c_int as uint8_t,
        DCT_CHROMAU_AC as libc::c_int as uint8_t,
        DCT_CHROMAV_AC as libc::c_int as uint8_t,
    ],
    [
        DCT_LUMA_4x4 as libc::c_int as uint8_t,
        DCT_CHROMAU_4x4 as libc::c_int as uint8_t,
        DCT_CHROMAV_4x4 as libc::c_int as uint8_t,
    ],
    [0 as libc::c_int as uint8_t, 0, 0],
    [0 as libc::c_int as uint8_t, 0, 0],
    [
        DCT_LUMA_8x8 as libc::c_int as uint8_t,
        DCT_CHROMAU_8x8 as libc::c_int as uint8_t,
        DCT_CHROMAV_8x8 as libc::c_int as uint8_t,
    ],
];
#[inline(always)]
unsafe extern "C" fn pack16to32(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
    return a.wrapping_add(b << 16 as libc::c_int);
}
#[inline(always)]
unsafe extern "C" fn pack8to16(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
    return a.wrapping_add(b << 8 as libc::c_int);
}
#[inline(always)]
unsafe extern "C" fn x264_mb_predict_intra4x4_mode(
    mut h: *mut x264_t,
    mut idx: libc::c_int,
) -> libc::c_int {
    let ma: libc::c_int = (*h)
        .mb
        .cache
        .intra4x4_pred_mode[(x264_scan8[idx as usize] as libc::c_int - 1 as libc::c_int)
        as usize] as libc::c_int;
    let mb: libc::c_int = (*h)
        .mb
        .cache
        .intra4x4_pred_mode[(x264_scan8[idx as usize] as libc::c_int - 8 as libc::c_int)
        as usize] as libc::c_int;
    let m: libc::c_int = if (x264_mb_pred_mode4x4_fix[(ma + 1 as libc::c_int) as usize]
        as libc::c_int)
        < x264_mb_pred_mode4x4_fix[(mb + 1 as libc::c_int) as usize] as libc::c_int
    {
        x264_mb_pred_mode4x4_fix[(ma + 1 as libc::c_int) as usize] as libc::c_int
    } else {
        x264_mb_pred_mode4x4_fix[(mb + 1 as libc::c_int) as usize] as libc::c_int
    };
    if m < 0 as libc::c_int {
        return I_PRED_4x4_DC as libc::c_int;
    }
    return m;
}
#[inline(always)]
unsafe extern "C" fn x264_mb_predict_non_zero_code(
    mut h: *mut x264_t,
    mut idx: libc::c_int,
) -> libc::c_int {
    let za: libc::c_int = (*h)
        .mb
        .cache
        .non_zero_count[(x264_scan8[idx as usize] as libc::c_int - 1 as libc::c_int)
        as usize] as libc::c_int;
    let zb: libc::c_int = (*h)
        .mb
        .cache
        .non_zero_count[(x264_scan8[idx as usize] as libc::c_int - 8 as libc::c_int)
        as usize] as libc::c_int;
    let mut i_ret: libc::c_int = za + zb;
    if i_ret < 0x80 as libc::c_int {
        i_ret = i_ret + 1 as libc::c_int >> 1 as libc::c_int;
    }
    return i_ret & 0x7f as libc::c_int;
}
static mut x264_transform_allowed: [uint8_t; 19] = [
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
];
#[inline(always)]
unsafe extern "C" fn x264_mb_transform_8x8_allowed(mut h: *mut x264_t) -> libc::c_int {
    if (*((*h).pps).as_mut_ptr()).b_transform_8x8_mode == 0 {
        return 0 as libc::c_int;
    }
    if (*h).mb.i_type != P_8x8 as libc::c_int {
        return x264_transform_allowed[(*h).mb.i_type as usize] as libc::c_int;
    }
    return ((*(((*h).mb.i_sub_partition).as_mut_ptr() as *mut x264_union32_t)).i
        == (D_L0_8x8 as libc::c_int * 0x1010101 as libc::c_int) as uint32_t)
        as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn x264_macroblock_cache_rect(
    mut dst: *mut libc::c_void,
    mut w: libc::c_int,
    mut h: libc::c_int,
    mut s: libc::c_int,
    mut v: uint32_t,
) {
    let mut d: *mut uint8_t = dst as *mut uint8_t;
    let mut v2: uint16_t = (if s >= 2 as libc::c_int {
        v
    } else {
        v * 0x101 as libc::c_int as uint32_t
    }) as uint16_t;
    let mut v4: uint32_t = if s >= 4 as libc::c_int {
        v
    } else if s >= 2 as libc::c_int {
        v * 0x10001 as libc::c_int as uint32_t
    } else {
        v * 0x1010101 as libc::c_int as uint32_t
    };
    let mut v8: uint64_t = (v4 as uint64_t)
        .wrapping_add((v4 as uint64_t) << 32 as libc::c_int);
    s *= 8 as libc::c_int;
    if w == 2 as libc::c_int {
        (*(d.offset((s * 0 as libc::c_int) as isize) as *mut x264_union16_t)).i = v2;
        if h == 1 as libc::c_int {
            return;
        }
        (*(d.offset((s * 1 as libc::c_int) as isize) as *mut x264_union16_t)).i = v2;
        if h == 2 as libc::c_int {
            return;
        }
        (*(d.offset((s * 2 as libc::c_int) as isize) as *mut x264_union16_t)).i = v2;
        (*(d.offset((s * 3 as libc::c_int) as isize) as *mut x264_union16_t)).i = v2;
    } else if w == 4 as libc::c_int {
        (*(d.offset((s * 0 as libc::c_int) as isize) as *mut x264_union32_t)).i = v4;
        if h == 1 as libc::c_int {
            return;
        }
        (*(d.offset((s * 1 as libc::c_int) as isize) as *mut x264_union32_t)).i = v4;
        if h == 2 as libc::c_int {
            return;
        }
        (*(d.offset((s * 2 as libc::c_int) as isize) as *mut x264_union32_t)).i = v4;
        (*(d.offset((s * 3 as libc::c_int) as isize) as *mut x264_union32_t)).i = v4;
    } else if w == 8 as libc::c_int {
        if ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
            == 8 as libc::c_int as libc::c_ulong
        {
            (*(d.offset((s * 0 as libc::c_int) as isize) as *mut x264_union64_t)).i = v8;
            if h == 1 as libc::c_int {
                return;
            }
            (*(d.offset((s * 1 as libc::c_int) as isize) as *mut x264_union64_t)).i = v8;
            if h == 2 as libc::c_int {
                return;
            }
            (*(d.offset((s * 2 as libc::c_int) as isize) as *mut x264_union64_t)).i = v8;
            (*(d.offset((s * 3 as libc::c_int) as isize) as *mut x264_union64_t)).i = v8;
        } else {
            (*(d
                .offset((s * 0 as libc::c_int) as isize)
                .offset(0 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
            (*(d
                .offset((s * 0 as libc::c_int) as isize)
                .offset(4 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
            if h == 1 as libc::c_int {
                return;
            }
            (*(d
                .offset((s * 1 as libc::c_int) as isize)
                .offset(0 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
            (*(d
                .offset((s * 1 as libc::c_int) as isize)
                .offset(4 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
            if h == 2 as libc::c_int {
                return;
            }
            (*(d
                .offset((s * 2 as libc::c_int) as isize)
                .offset(0 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
            (*(d
                .offset((s * 2 as libc::c_int) as isize)
                .offset(4 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
            (*(d
                .offset((s * 3 as libc::c_int) as isize)
                .offset(0 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
            (*(d
                .offset((s * 3 as libc::c_int) as isize)
                .offset(4 as libc::c_int as isize) as *mut x264_union32_t))
                .i = v4;
        }
    } else if w == 16 as libc::c_int {
        if h != 1 as libc::c_int {} else {
            __assert_fail(
                b"h != 1\0" as *const u8 as *const libc::c_char,
                b"./common/rectangle.h\0" as *const u8 as *const libc::c_char,
                82 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 65],
                    &[libc::c_char; 65],
                >(b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0"))
                    .as_ptr(),
            );
        }
        'c_27091: {
            if h != 1 as libc::c_int {} else {
                __assert_fail(
                    b"h != 1\0" as *const u8 as *const libc::c_char,
                    b"./common/rectangle.h\0" as *const u8 as *const libc::c_char,
                    82 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 65],
                        &[libc::c_char; 65],
                    >(
                        b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                    ))
                        .as_ptr(),
                );
            }
        };
        if ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
            == 8 as libc::c_int as libc::c_ulong
        {
            loop {
                (*(d
                    .offset((s * 0 as libc::c_int) as isize)
                    .offset(0 as libc::c_int as isize) as *mut x264_union64_t))
                    .i = v8;
                (*(d
                    .offset((s * 0 as libc::c_int) as isize)
                    .offset(8 as libc::c_int as isize) as *mut x264_union64_t))
                    .i = v8;
                (*(d
                    .offset((s * 1 as libc::c_int) as isize)
                    .offset(0 as libc::c_int as isize) as *mut x264_union64_t))
                    .i = v8;
                (*(d
                    .offset((s * 1 as libc::c_int) as isize)
                    .offset(8 as libc::c_int as isize) as *mut x264_union64_t))
                    .i = v8;
                h -= 2 as libc::c_int;
                d = d.offset((s * 2 as libc::c_int) as isize);
                if !(h != 0) {
                    break;
                }
            }
        } else {
            loop {
                (*(d.offset(0 as libc::c_int as isize) as *mut x264_union32_t)).i = v4;
                (*(d.offset(4 as libc::c_int as isize) as *mut x264_union32_t)).i = v4;
                (*(d.offset(8 as libc::c_int as isize) as *mut x264_union32_t)).i = v4;
                (*(d.offset(12 as libc::c_int as isize) as *mut x264_union32_t)).i = v4;
                d = d.offset(s as isize);
                h -= 1;
                if !(h != 0) {
                    break;
                }
            }
        }
    } else {
        __assert_fail(
            b"0\0" as *const u8 as *const libc::c_char,
            b"./common/rectangle.h\0" as *const u8 as *const libc::c_char,
            118 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 65],
                &[libc::c_char; 65],
            >(b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0"))
                .as_ptr(),
        );
        'c_26858: {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"./common/rectangle.h\0" as *const u8 as *const libc::c_char,
                118 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 65],
                    &[libc::c_char; 65],
                >(b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0"))
                    .as_ptr(),
            );
        };
    };
}
#[inline(always)]
unsafe extern "C" fn x264_macroblock_cache_mv(
    mut h: *mut x264_t,
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut width: libc::c_int,
    mut height: libc::c_int,
    mut i_list: libc::c_int,
    mut mv: uint32_t,
) {
    let mut mv_cache: *mut libc::c_void = &mut *(*((*h).mb.cache.mv)
        .as_mut_ptr()
        .offset(i_list as isize))
        .as_mut_ptr()
        .offset(
            (4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int + x
                + 8 as libc::c_int * y) as isize,
        ) as *mut [int16_t; 2] as *mut libc::c_void;
    if 0 == 0 || 0 == 0 {
        (x264_8_cache_mv_func_table[(width + (height << 1 as libc::c_int)
            - 3 as libc::c_int) as usize])
            .expect("non-null function pointer")(mv_cache, mv);
    } else {
        x264_macroblock_cache_rect(
            mv_cache,
            width * 4 as libc::c_int,
            height,
            4 as libc::c_int,
            mv,
        );
    };
}
#[inline(always)]
unsafe extern "C" fn x264_macroblock_cache_mvd(
    mut h: *mut x264_t,
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut width: libc::c_int,
    mut height: libc::c_int,
    mut i_list: libc::c_int,
    mut mvd: uint16_t,
) {
    let mut mvd_cache: *mut libc::c_void = &mut *(*((*h).mb.cache.mvd)
        .as_mut_ptr()
        .offset(i_list as isize))
        .as_mut_ptr()
        .offset(
            (4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int + x
                + 8 as libc::c_int * y) as isize,
        ) as *mut [uint8_t; 2] as *mut libc::c_void;
    if 0 == 0 || 0 == 0 {
        (x264_8_cache_mvd_func_table[(width + (height << 1 as libc::c_int)
            - 3 as libc::c_int) as usize])
            .expect("non-null function pointer")(mvd_cache, mvd as uint32_t);
    } else {
        x264_macroblock_cache_rect(
            mvd_cache,
            width * 2 as libc::c_int,
            height,
            2 as libc::c_int,
            mvd as uint32_t,
        );
    };
}
#[inline(always)]
unsafe extern "C" fn x264_macroblock_cache_ref(
    mut h: *mut x264_t,
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut width: libc::c_int,
    mut height: libc::c_int,
    mut i_list: libc::c_int,
    mut ref_0: int8_t,
) {
    let mut ref_cache: *mut libc::c_void = &mut *(*((*h).mb.cache.ref_0)
        .as_mut_ptr()
        .offset(i_list as isize))
        .as_mut_ptr()
        .offset(
            (4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int + x
                + 8 as libc::c_int * y) as isize,
        ) as *mut int8_t as *mut libc::c_void;
    if 0 == 0 || 0 == 0 {
        (x264_8_cache_ref_func_table[(width + (height << 1 as libc::c_int)
            - 3 as libc::c_int) as usize])
            .expect(
                "non-null function pointer",
            )(ref_cache, ref_0 as uint8_t as uint32_t);
    } else {
        x264_macroblock_cache_rect(
            ref_cache,
            width,
            height,
            1 as libc::c_int,
            ref_0 as uint8_t as uint32_t,
        );
    };
}
#[inline(always)]
unsafe extern "C" fn x264_macroblock_cache_skip(
    mut h: *mut x264_t,
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut width: libc::c_int,
    mut height: libc::c_int,
    mut b_skip: libc::c_int,
) {
    x264_macroblock_cache_rect(
        &mut *((*h).mb.cache.skip)
            .as_mut_ptr()
            .offset(
                (4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int + x
                    + 8 as libc::c_int * y) as isize,
            ) as *mut int8_t as *mut libc::c_void,
        width,
        height,
        1 as libc::c_int,
        b_skip as uint32_t,
    );
}
#[inline(always)]
unsafe extern "C" fn x264_macroblock_cache_intra8x8_pred(
    mut h: *mut x264_t,
    mut x: libc::c_int,
    mut y: libc::c_int,
    mut i_mode: libc::c_int,
) {
    x264_macroblock_cache_rect(
        &mut *((*h).mb.cache.intra4x4_pred_mode)
            .as_mut_ptr()
            .offset(
                (4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int + x
                    + 8 as libc::c_int * y) as isize,
            ) as *mut int8_t as *mut libc::c_void,
        2 as libc::c_int,
        2 as libc::c_int,
        1 as libc::c_int,
        i_mode as uint32_t,
    );
}
#[no_mangle]
pub static mut x264_8_cabac_transition_unary: [[uint8_t; 128]; 15] = [[0; 128]; 15];
#[no_mangle]
pub static mut x264_8_cabac_size_unary: [[uint16_t; 128]; 15] = [[0; 128]; 15];
static mut cabac_transition_5ones: [uint8_t; 128] = [0; 128];
static mut cabac_size_5ones: [uint16_t; 128] = [0; 128];
#[inline(always)]
unsafe extern "C" fn cached_hadamard(
    mut h: *mut x264_t,
    mut size: libc::c_int,
    mut x: libc::c_int,
    mut y: libc::c_int,
) -> uint64_t {
    static mut hadamard_shift_x: [uint8_t; 4] = [
        4 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
    ];
    static mut hadamard_shift_y: [uint8_t; 4] = [
        (4 as libc::c_int - 0 as libc::c_int) as uint8_t,
        (3 as libc::c_int - 0 as libc::c_int) as uint8_t,
        (4 as libc::c_int - 1 as libc::c_int) as uint8_t,
        (3 as libc::c_int - 1 as libc::c_int) as uint8_t,
    ];
    static mut hadamard_offset: [uint8_t; 4] = [
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        5 as libc::c_int as uint8_t,
    ];
    let mut cache_index: libc::c_int = (x
        >> hadamard_shift_x[size as usize] as libc::c_int)
        + (y >> hadamard_shift_y[size as usize] as libc::c_int)
        + hadamard_offset[size as usize] as libc::c_int;
    let mut res: uint64_t = (*h).mb.pic.fenc_hadamard_cache[cache_index as usize];
    if res != 0 {
        return res.wrapping_sub(1 as libc::c_int as uint64_t)
    } else {
        let mut fenc: *mut pixel = ((*h).mb.pic.p_fenc[0 as libc::c_int as usize])
            .offset(x as isize)
            .offset((y * 16 as libc::c_int) as isize);
        res = ((*h).pixf.hadamard_ac[size as usize])
            .expect("non-null function pointer")(fenc, 16 as libc::c_int as intptr_t);
        (*h)
            .mb
            .pic
            .fenc_hadamard_cache[cache_index
            as usize] = res.wrapping_add(1 as libc::c_int as uint64_t);
        return res;
    };
}
#[inline(always)]
unsafe extern "C" fn cached_satd(
    mut h: *mut x264_t,
    mut size: libc::c_int,
    mut x: libc::c_int,
    mut y: libc::c_int,
) -> libc::c_int {
    static mut satd_shift_x: [uint8_t; 3] = [
        3 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
    ];
    static mut satd_shift_y: [uint8_t; 3] = [
        (2 as libc::c_int - 1 as libc::c_int) as uint8_t,
        (3 as libc::c_int - 2 as libc::c_int) as uint8_t,
        (2 as libc::c_int - 2 as libc::c_int) as uint8_t,
    ];
    static mut satd_offset: [uint8_t; 3] = [
        0 as libc::c_int as uint8_t,
        8 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
    ];
    let mut cache_index: libc::c_int = (x
        >> satd_shift_x[(size - PIXEL_8x4 as libc::c_int) as usize] as libc::c_int)
        + (y >> satd_shift_y[(size - PIXEL_8x4 as libc::c_int) as usize] as libc::c_int)
        + satd_offset[(size - PIXEL_8x4 as libc::c_int) as usize] as libc::c_int;
    let mut res: libc::c_int = (*h).mb.pic.fenc_satd_cache[cache_index as usize]
        as libc::c_int;
    if res != 0 {
        return res - 1 as libc::c_int
    } else {
        let mut fenc: *mut pixel = ((*h).mb.pic.p_fenc[0 as libc::c_int as usize])
            .offset(x as isize)
            .offset((y * 16 as libc::c_int) as isize);
        let mut dc: libc::c_int = ((*h).pixf.sad[size as usize])
            .expect(
                "non-null function pointer",
            )(
            fenc,
            16 as libc::c_int as intptr_t,
            x264_zero.as_mut_ptr() as *mut pixel,
            0 as libc::c_int as intptr_t,
        ) >> 1 as libc::c_int;
        res = ((*h).pixf.satd[size as usize])
            .expect(
                "non-null function pointer",
            )(
            fenc,
            16 as libc::c_int as intptr_t,
            x264_zero.as_mut_ptr() as *mut pixel,
            0 as libc::c_int as intptr_t,
        ) - dc;
        (*h)
            .mb
            .pic
            .fenc_satd_cache[cache_index
            as usize] = (res + 1 as libc::c_int) as uint32_t;
        return res;
    };
}
#[inline]
unsafe extern "C" fn ssd_plane(
    mut h: *mut x264_t,
    mut size: libc::c_int,
    mut p: libc::c_int,
    mut x: libc::c_int,
    mut y: libc::c_int,
) -> libc::c_int {
    let mut satd: libc::c_int = 0 as libc::c_int;
    let mut fdec: *mut pixel = ((*h).mb.pic.p_fdec[p as usize])
        .offset(x as isize)
        .offset((y * 32 as libc::c_int) as isize);
    let mut fenc: *mut pixel = ((*h).mb.pic.p_fenc[p as usize])
        .offset(x as isize)
        .offset((y * 16 as libc::c_int) as isize);
    if p == 0 as libc::c_int && (*h).mb.i_psy_rd != 0 {
        if size <= PIXEL_8x8 as libc::c_int {
            let mut fdec_acs: uint64_t = ((*h).pixf.hadamard_ac[size as usize])
                .expect(
                    "non-null function pointer",
                )(fdec, 32 as libc::c_int as intptr_t);
            let mut fenc_acs: uint64_t = cached_hadamard(h, size, x, y);
            satd = abs(fdec_acs as int32_t - fenc_acs as int32_t)
                + abs(
                    (fdec_acs >> 32 as libc::c_int) as int32_t
                        - (fenc_acs >> 32 as libc::c_int) as int32_t,
                );
            satd >>= 1 as libc::c_int;
        } else {
            let mut dc: libc::c_int = ((*h).pixf.sad[size as usize])
                .expect(
                    "non-null function pointer",
                )(
                fdec,
                32 as libc::c_int as intptr_t,
                x264_zero.as_mut_ptr() as *mut pixel,
                0 as libc::c_int as intptr_t,
            ) >> 1 as libc::c_int;
            satd = abs(
                ((*h).pixf.satd[size as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    fdec,
                    32 as libc::c_int as intptr_t,
                    x264_zero.as_mut_ptr() as *mut pixel,
                    0 as libc::c_int as intptr_t,
                ) - dc - cached_satd(h, size, x, y),
            );
        }
        let mut tmp: int64_t = satd as int64_t * (*h).mb.i_psy_rd as int64_t
            * (*h).mb.i_psy_rd_lambda as int64_t + 128 as libc::c_int as int64_t
            >> 8 as libc::c_int;
        satd = (if tmp < ((1 as libc::c_int) << 28 as libc::c_int) as int64_t {
            tmp
        } else {
            ((1 as libc::c_int) << 28 as libc::c_int) as int64_t
        }) as libc::c_int;
    }
    return ((*h).pixf.ssd[size as usize])
        .expect(
            "non-null function pointer",
        )(fenc, 16 as libc::c_int as intptr_t, fdec, 32 as libc::c_int as intptr_t)
        + satd;
}
#[inline]
unsafe extern "C" fn ssd_mb(mut h: *mut x264_t) -> libc::c_int {
    let mut i_ssd: libc::c_int = ssd_plane(
        h,
        PIXEL_16x16 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
        let mut chroma_size: libc::c_int = (*h)
            .luma2chroma_pixel[PIXEL_16x16 as libc::c_int as usize] as libc::c_int;
        let mut chroma_ssd: libc::c_int = ssd_plane(
            h,
            chroma_size,
            1 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        )
            + ssd_plane(
                h,
                chroma_size,
                2 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            );
        i_ssd = (i_ssd as uint64_t)
            .wrapping_add(
                (chroma_ssd as uint64_t * (*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int,
            ) as libc::c_int as libc::c_int;
    }
    return i_ssd;
}
unsafe extern "C" fn rd_cost_mb(
    mut h: *mut x264_t,
    mut i_lambda2: libc::c_int,
) -> libc::c_int {
    let mut b_transform_bak: libc::c_int = (*h).mb.b_transform_8x8;
    let mut i_ssd: libc::c_int = 0;
    let mut i_bits: libc::c_int = 0;
    let mut type_bak: libc::c_int = (*h).mb.i_type;
    x264_8_macroblock_encode(h);
    if (*h).mb.b_deblock_rdo != 0 {
        x264_8_macroblock_deblock(h);
    }
    i_ssd = ssd_mb(h);
    if (*h).mb.i_type == P_SKIP as libc::c_int || (*h).mb.i_type == B_SKIP as libc::c_int
    {
        i_bits = 1 as libc::c_int * i_lambda2 + 128 as libc::c_int >> 8 as libc::c_int;
    } else if (*h).param.b_cabac != 0 {
        let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
            i_low: 0,
            i_range: 0,
            i_queue: 0,
            i_bytes_outstanding: 0,
            p_start: 0 as *mut uint8_t,
            p: 0 as *mut uint8_t,
            p_end: 0 as *mut uint8_t,
            f8_bits_encoded: 0,
            state: [0; 1024],
            padding: [0; 12],
        };
        ((*h).mc.memcpy_aligned)
            .expect(
                "non-null function pointer",
            )(
            &mut cabac_tmp.f8_bits_encoded as *mut libc::c_int as *mut libc::c_void,
            &mut (*h).cabac.f8_bits_encoded as *mut libc::c_int as *const libc::c_void,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_add(
                    (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as libc::c_int
                    {
                        1024 as libc::c_int + 12 as libc::c_int
                    } else {
                        460 as libc::c_int
                    }) as libc::c_ulong,
                ),
        );
        macroblock_size_cabac(h, &mut cabac_tmp);
        i_bits = ((cabac_tmp.f8_bits_encoded as uint64_t * i_lambda2 as uint64_t)
            .wrapping_add(32768 as libc::c_int as uint64_t) >> 16 as libc::c_int)
            as libc::c_int;
    } else {
        macroblock_size_cavlc(h);
        i_bits = (((*h).out.bs.i_bits_encoded as uint64_t * i_lambda2 as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int)
            as libc::c_int;
    }
    (*h).mb.b_transform_8x8 = b_transform_bak;
    (*h).mb.i_type = type_bak;
    return if i_ssd + i_bits < (1 as libc::c_int) << 28 as libc::c_int {
        i_ssd + i_bits
    } else {
        (1 as libc::c_int) << 28 as libc::c_int
    };
}
unsafe extern "C" fn rd_cost_subpart(
    mut h: *mut x264_t,
    mut i_lambda2: libc::c_int,
    mut i4: libc::c_int,
    mut i_pixel: libc::c_int,
) -> uint64_t {
    let mut i_ssd: uint64_t = 0;
    let mut i_bits: uint64_t = 0;
    x264_8_macroblock_encode_p4x4(h, i4);
    if i_pixel == PIXEL_8x4 as libc::c_int {
        x264_8_macroblock_encode_p4x4(h, i4 + 1 as libc::c_int);
    }
    if i_pixel == PIXEL_4x8 as libc::c_int {
        x264_8_macroblock_encode_p4x4(h, i4 + 2 as libc::c_int);
    }
    i_ssd = ssd_plane(
        h,
        i_pixel,
        0 as libc::c_int,
        block_idx_x[i4 as usize] as libc::c_int * 4 as libc::c_int,
        block_idx_y[i4 as usize] as libc::c_int * 4 as libc::c_int,
    ) as uint64_t;
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
        let mut chromassd: libc::c_int = ssd_plane(
            h,
            i_pixel,
            1 as libc::c_int,
            block_idx_x[i4 as usize] as libc::c_int * 4 as libc::c_int,
            block_idx_y[i4 as usize] as libc::c_int * 4 as libc::c_int,
        )
            + ssd_plane(
                h,
                i_pixel,
                2 as libc::c_int,
                block_idx_x[i4 as usize] as libc::c_int * 4 as libc::c_int,
                block_idx_y[i4 as usize] as libc::c_int * 4 as libc::c_int,
            );
        chromassd = ((chromassd as uint64_t
            * (*h).mb.i_chroma_lambda2_offset as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int)
            as libc::c_int;
        i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
    }
    if (*h).param.b_cabac != 0 {
        let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
            i_low: 0,
            i_range: 0,
            i_queue: 0,
            i_bytes_outstanding: 0,
            p_start: 0 as *mut uint8_t,
            p: 0 as *mut uint8_t,
            p_end: 0 as *mut uint8_t,
            f8_bits_encoded: 0,
            state: [0; 1024],
            padding: [0; 12],
        };
        ((*h).mc.memcpy_aligned)
            .expect(
                "non-null function pointer",
            )(
            &mut cabac_tmp.f8_bits_encoded as *mut libc::c_int as *mut libc::c_void,
            &mut (*h).cabac.f8_bits_encoded as *mut libc::c_int as *const libc::c_void,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_add(
                    (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as libc::c_int
                    {
                        1024 as libc::c_int + 12 as libc::c_int
                    } else {
                        460 as libc::c_int
                    }) as libc::c_ulong,
                ),
        );
        subpartition_size_cabac(h, &mut cabac_tmp, i4, i_pixel);
        i_bits = (cabac_tmp.f8_bits_encoded as uint64_t * i_lambda2 as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int;
    } else {
        i_bits = subpartition_size_cavlc(h, i4, i_pixel) as uint64_t;
    }
    return (i_ssd << 8 as libc::c_int).wrapping_add(i_bits);
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_rd_cost_part(
    mut h: *mut x264_t,
    mut i_lambda2: libc::c_int,
    mut i4: libc::c_int,
    mut i_pixel: libc::c_int,
) -> uint64_t {
    let mut i_ssd: uint64_t = 0;
    let mut i_bits: uint64_t = 0;
    let mut i8: libc::c_int = i4 >> 2 as libc::c_int;
    if i_pixel == PIXEL_16x16 as libc::c_int {
        let mut i_cost: libc::c_int = rd_cost_mb(h, i_lambda2);
        return i_cost as uint64_t;
    }
    if i_pixel > PIXEL_8x8 as libc::c_int {
        return rd_cost_subpart(h, i_lambda2, i4, i_pixel);
    }
    (*h).mb.i_cbp_luma = 0 as libc::c_int;
    x264_8_macroblock_encode_p8x8(h, i8);
    if i_pixel == PIXEL_16x8 as libc::c_int {
        x264_8_macroblock_encode_p8x8(h, i8 + 1 as libc::c_int);
    }
    if i_pixel == PIXEL_8x16 as libc::c_int {
        x264_8_macroblock_encode_p8x8(h, i8 + 2 as libc::c_int);
    }
    let mut ssd_x: libc::c_int = 8 as libc::c_int * (i8 & 1 as libc::c_int);
    let mut ssd_y: libc::c_int = 8 as libc::c_int * (i8 >> 1 as libc::c_int);
    i_ssd = ssd_plane(h, i_pixel, 0 as libc::c_int, ssd_x, ssd_y) as uint64_t;
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
        let mut chroma_size: libc::c_int = (*h).luma2chroma_pixel[i_pixel as usize]
            as libc::c_int;
        let mut chroma_ssd: libc::c_int = ssd_plane(
            h,
            chroma_size,
            1 as libc::c_int,
            ssd_x >> (*h).mb.chroma_h_shift,
            ssd_y >> (*h).mb.chroma_v_shift,
        )
            + ssd_plane(
                h,
                chroma_size,
                2 as libc::c_int,
                ssd_x >> (*h).mb.chroma_h_shift,
                ssd_y >> (*h).mb.chroma_v_shift,
            );
        i_ssd = i_ssd
            .wrapping_add(
                (chroma_ssd as uint64_t * (*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int,
            );
    }
    if (*h).param.b_cabac != 0 {
        let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
            i_low: 0,
            i_range: 0,
            i_queue: 0,
            i_bytes_outstanding: 0,
            p_start: 0 as *mut uint8_t,
            p: 0 as *mut uint8_t,
            p_end: 0 as *mut uint8_t,
            f8_bits_encoded: 0,
            state: [0; 1024],
            padding: [0; 12],
        };
        ((*h).mc.memcpy_aligned)
            .expect(
                "non-null function pointer",
            )(
            &mut cabac_tmp.f8_bits_encoded as *mut libc::c_int as *mut libc::c_void,
            &mut (*h).cabac.f8_bits_encoded as *mut libc::c_int as *const libc::c_void,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_add(
                    (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as libc::c_int
                    {
                        1024 as libc::c_int + 12 as libc::c_int
                    } else {
                        460 as libc::c_int
                    }) as libc::c_ulong,
                ),
        );
        partition_size_cabac(h, &mut cabac_tmp, i8, i_pixel);
        i_bits = (cabac_tmp.f8_bits_encoded as uint64_t * i_lambda2 as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int;
    } else {
        i_bits = partition_size_cavlc(h, i8, i_pixel) as uint64_t
            * i_lambda2 as uint64_t;
    }
    return (i_ssd << 8 as libc::c_int).wrapping_add(i_bits);
}
unsafe extern "C" fn rd_cost_i8x8(
    mut h: *mut x264_t,
    mut i_lambda2: libc::c_int,
    mut i8: libc::c_int,
    mut i_mode: libc::c_int,
    mut edge: *mut [pixel; 32],
) -> uint64_t {
    let mut i_ssd: uint64_t = 0;
    let mut i_bits: uint64_t = 0;
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    let mut i_qp: libc::c_int = (*h).mb.i_qp;
    (*h).mb.i_cbp_luma &= !((1 as libc::c_int) << i8);
    (*h).mb.b_transform_8x8 = 1 as libc::c_int;
    let mut p: libc::c_int = 0 as libc::c_int;
    while p < plane_count {
        x264_mb_encode_i8x8(
            h,
            p,
            i8,
            i_qp,
            i_mode,
            (*edge.offset(p as isize)).as_mut_ptr(),
            1 as libc::c_int,
        );
        i_qp = (*h).mb.i_chroma_qp;
        p += 1;
        p;
    }
    i_ssd = ssd_plane(
        h,
        PIXEL_8x8 as libc::c_int,
        0 as libc::c_int,
        (i8 & 1 as libc::c_int) * 8 as libc::c_int,
        (i8 >> 1 as libc::c_int) * 8 as libc::c_int,
    ) as uint64_t;
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
        let mut chromassd: libc::c_int = ssd_plane(
            h,
            PIXEL_8x8 as libc::c_int,
            1 as libc::c_int,
            (i8 & 1 as libc::c_int) * 8 as libc::c_int,
            (i8 >> 1 as libc::c_int) * 8 as libc::c_int,
        )
            + ssd_plane(
                h,
                PIXEL_8x8 as libc::c_int,
                2 as libc::c_int,
                (i8 & 1 as libc::c_int) * 8 as libc::c_int,
                (i8 >> 1 as libc::c_int) * 8 as libc::c_int,
            );
        chromassd = ((chromassd as uint64_t
            * (*h).mb.i_chroma_lambda2_offset as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int)
            as libc::c_int;
        i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
    }
    if (*h).param.b_cabac != 0 {
        let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
            i_low: 0,
            i_range: 0,
            i_queue: 0,
            i_bytes_outstanding: 0,
            p_start: 0 as *mut uint8_t,
            p: 0 as *mut uint8_t,
            p_end: 0 as *mut uint8_t,
            f8_bits_encoded: 0,
            state: [0; 1024],
            padding: [0; 12],
        };
        ((*h).mc.memcpy_aligned)
            .expect(
                "non-null function pointer",
            )(
            &mut cabac_tmp.f8_bits_encoded as *mut libc::c_int as *mut libc::c_void,
            &mut (*h).cabac.f8_bits_encoded as *mut libc::c_int as *const libc::c_void,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_add(
                    (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as libc::c_int
                    {
                        1024 as libc::c_int + 12 as libc::c_int
                    } else {
                        460 as libc::c_int
                    }) as libc::c_ulong,
                ),
        );
        partition_i8x8_size_cabac(h, &mut cabac_tmp, i8, i_mode);
        i_bits = (cabac_tmp.f8_bits_encoded as uint64_t * i_lambda2 as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int;
    } else {
        i_bits = partition_i8x8_size_cavlc(h, i8, i_mode) as uint64_t
            * i_lambda2 as uint64_t;
    }
    return (i_ssd << 8 as libc::c_int).wrapping_add(i_bits);
}
unsafe extern "C" fn rd_cost_i4x4(
    mut h: *mut x264_t,
    mut i_lambda2: libc::c_int,
    mut i4: libc::c_int,
    mut i_mode: libc::c_int,
) -> uint64_t {
    let mut i_ssd: uint64_t = 0;
    let mut i_bits: uint64_t = 0;
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    let mut i_qp: libc::c_int = (*h).mb.i_qp;
    let mut p: libc::c_int = 0 as libc::c_int;
    while p < plane_count {
        x264_mb_encode_i4x4(h, p, i4, i_qp, i_mode, 1 as libc::c_int);
        i_qp = (*h).mb.i_chroma_qp;
        p += 1;
        p;
    }
    i_ssd = ssd_plane(
        h,
        PIXEL_4x4 as libc::c_int,
        0 as libc::c_int,
        block_idx_x[i4 as usize] as libc::c_int * 4 as libc::c_int,
        block_idx_y[i4 as usize] as libc::c_int * 4 as libc::c_int,
    ) as uint64_t;
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
        let mut chromassd: libc::c_int = ssd_plane(
            h,
            PIXEL_4x4 as libc::c_int,
            1 as libc::c_int,
            block_idx_x[i4 as usize] as libc::c_int * 4 as libc::c_int,
            block_idx_y[i4 as usize] as libc::c_int * 4 as libc::c_int,
        )
            + ssd_plane(
                h,
                PIXEL_4x4 as libc::c_int,
                2 as libc::c_int,
                block_idx_x[i4 as usize] as libc::c_int * 4 as libc::c_int,
                block_idx_y[i4 as usize] as libc::c_int * 4 as libc::c_int,
            );
        chromassd = ((chromassd as uint64_t
            * (*h).mb.i_chroma_lambda2_offset as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int)
            as libc::c_int;
        i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
    }
    if (*h).param.b_cabac != 0 {
        let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
            i_low: 0,
            i_range: 0,
            i_queue: 0,
            i_bytes_outstanding: 0,
            p_start: 0 as *mut uint8_t,
            p: 0 as *mut uint8_t,
            p_end: 0 as *mut uint8_t,
            f8_bits_encoded: 0,
            state: [0; 1024],
            padding: [0; 12],
        };
        ((*h).mc.memcpy_aligned)
            .expect(
                "non-null function pointer",
            )(
            &mut cabac_tmp.f8_bits_encoded as *mut libc::c_int as *mut libc::c_void,
            &mut (*h).cabac.f8_bits_encoded as *mut libc::c_int as *const libc::c_void,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_add(
                    (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as libc::c_int
                    {
                        1024 as libc::c_int + 12 as libc::c_int
                    } else {
                        460 as libc::c_int
                    }) as libc::c_ulong,
                ),
        );
        partition_i4x4_size_cabac(h, &mut cabac_tmp, i4, i_mode);
        i_bits = (cabac_tmp.f8_bits_encoded as uint64_t * i_lambda2 as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int;
    } else {
        i_bits = partition_i4x4_size_cavlc(h, i4, i_mode) as uint64_t
            * i_lambda2 as uint64_t;
    }
    return (i_ssd << 8 as libc::c_int).wrapping_add(i_bits);
}
unsafe extern "C" fn rd_cost_chroma(
    mut h: *mut x264_t,
    mut i_lambda2: libc::c_int,
    mut i_mode: libc::c_int,
    mut b_dct: libc::c_int,
) -> uint64_t {
    let mut i_ssd: uint64_t = 0;
    let mut i_bits: uint64_t = 0;
    if b_dct != 0 {
        x264_8_mb_encode_chroma(h, 0 as libc::c_int, (*h).mb.i_chroma_qp);
    }
    let mut chromapix: libc::c_int = (*h)
        .luma2chroma_pixel[PIXEL_16x16 as libc::c_int as usize] as libc::c_int;
    i_ssd = (ssd_plane(
        h,
        chromapix,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) + ssd_plane(h, chromapix, 2 as libc::c_int, 0 as libc::c_int, 0 as libc::c_int))
        as uint64_t;
    (*h).mb.i_chroma_pred_mode = i_mode;
    if (*h).param.b_cabac != 0 {
        let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
            i_low: 0,
            i_range: 0,
            i_queue: 0,
            i_bytes_outstanding: 0,
            p_start: 0 as *mut uint8_t,
            p: 0 as *mut uint8_t,
            p_end: 0 as *mut uint8_t,
            f8_bits_encoded: 0,
            state: [0; 1024],
            padding: [0; 12],
        };
        ((*h).mc.memcpy_aligned)
            .expect(
                "non-null function pointer",
            )(
            &mut cabac_tmp.f8_bits_encoded as *mut libc::c_int as *mut libc::c_void,
            &mut (*h).cabac.f8_bits_encoded as *mut libc::c_int as *const libc::c_void,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_add(
                    (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as libc::c_int
                    {
                        1024 as libc::c_int + 12 as libc::c_int
                    } else {
                        460 as libc::c_int
                    }) as libc::c_ulong,
                ),
        );
        chroma_size_cabac(h, &mut cabac_tmp);
        i_bits = (cabac_tmp.f8_bits_encoded as uint64_t * i_lambda2 as uint64_t)
            .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int;
    } else {
        i_bits = chroma_size_cavlc(h) as uint64_t * i_lambda2 as uint64_t;
    }
    return (i_ssd << 8 as libc::c_int).wrapping_add(i_bits);
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_rdo_init() {
    let mut i_prefix: libc::c_int = 0 as libc::c_int;
    while i_prefix < 15 as libc::c_int {
        let mut i_ctx: libc::c_int = 0 as libc::c_int;
        while i_ctx < 128 as libc::c_int {
            let mut f8_bits: libc::c_int = 0 as libc::c_int;
            let mut ctx: uint8_t = i_ctx as uint8_t;
            let mut i: libc::c_int = 1 as libc::c_int;
            while i < i_prefix {
                f8_bits
                    += x264_cabac_size_decision2(
                        &mut ctx,
                        1 as libc::c_int as libc::c_long,
                    );
                i += 1;
                i;
            }
            if i_prefix > 0 as libc::c_int && i_prefix < 14 as libc::c_int {
                f8_bits
                    += x264_cabac_size_decision2(
                        &mut ctx,
                        0 as libc::c_int as libc::c_long,
                    );
            }
            f8_bits += (1 as libc::c_int) << 8 as libc::c_int;
            x264_8_cabac_size_unary[i_prefix
                as usize][i_ctx as usize] = f8_bits as uint16_t;
            x264_8_cabac_transition_unary[i_prefix as usize][i_ctx as usize] = ctx;
            i_ctx += 1;
            i_ctx;
        }
        i_prefix += 1;
        i_prefix;
    }
    let mut i_ctx_0: libc::c_int = 0 as libc::c_int;
    while i_ctx_0 < 128 as libc::c_int {
        let mut f8_bits_0: libc::c_int = 0 as libc::c_int;
        let mut ctx_0: uint8_t = i_ctx_0 as uint8_t;
        let mut i_0: libc::c_int = 0 as libc::c_int;
        while i_0 < 5 as libc::c_int {
            f8_bits_0
                += x264_cabac_size_decision2(
                    &mut ctx_0,
                    1 as libc::c_int as libc::c_long,
                );
            i_0 += 1;
            i_0;
        }
        f8_bits_0 += (1 as libc::c_int) << 8 as libc::c_int;
        cabac_size_5ones[i_ctx_0 as usize] = f8_bits_0 as uint16_t;
        cabac_transition_5ones[i_ctx_0 as usize] = ctx_0;
        i_ctx_0 += 1;
        i_ctx_0;
    }
}
#[inline(never)]
unsafe extern "C" fn trellis_dc_shortcut(
    mut sign_coef: libc::c_int,
    mut quant_coef: libc::c_int,
    mut unquant_mf: libc::c_int,
    mut coef_weight: libc::c_int,
    mut lambda2: libc::c_int,
    mut cabac_state: *mut uint8_t,
    mut cost_sig: libc::c_int,
) -> libc::c_int {
    let mut bscore: uint64_t = !(0 as libc::c_ulonglong) as uint64_t;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut q: libc::c_int = abs(quant_coef);
    let mut abs_level: libc::c_int = q - 1 as libc::c_int;
    while abs_level <= q {
        let mut unquant_abs_level: libc::c_int = unquant_mf * abs_level
            + 128 as libc::c_int >> 8 as libc::c_int;
        let mut d: libc::c_int = sign_coef
            - ((unquant_abs_level ^ sign_coef >> 31 as libc::c_int)
                - (sign_coef >> 31 as libc::c_int) + 8 as libc::c_int
                & !(15 as libc::c_int));
        let mut score: uint64_t = (d as int64_t * d as int64_t * coef_weight as int64_t)
            as uint64_t;
        if abs_level != 0 {
            let mut f8_bits: libc::c_uint = cost_sig as libc::c_uint;
            let mut prefix: libc::c_int = if (abs_level - 1 as libc::c_int)
                < 14 as libc::c_int
            {
                abs_level - 1 as libc::c_int
            } else {
                14 as libc::c_int
            };
            f8_bits = f8_bits
                .wrapping_add(
                    x264_cabac_size_decision_noup2(
                        cabac_state.offset(1 as libc::c_int as isize),
                        (prefix > 0 as libc::c_int) as libc::c_int as libc::c_long,
                    ) as libc::c_uint,
                );
            f8_bits = f8_bits
                .wrapping_add(
                    x264_8_cabac_size_unary[prefix
                        as usize][*cabac_state.offset(5 as libc::c_int as isize)
                        as usize] as libc::c_uint,
                );
            if abs_level >= 15 as libc::c_int {
                f8_bits = f8_bits
                    .wrapping_add(
                        (bs_size_ue_big((abs_level - 15 as libc::c_int) as libc::c_uint)
                            << 8 as libc::c_int) as libc::c_uint,
                    );
            }
            score = score
                .wrapping_add(
                    f8_bits as uint64_t * lambda2 as uint64_t
                        >> 8 as libc::c_int - 4 as libc::c_int,
                );
        }
        if score < bscore {
            bscore = score;
            ret = abs_level;
        }
        abs_level += 1;
        abs_level;
    }
    return (ret ^ sign_coef >> 31 as libc::c_int) - (sign_coef >> 31 as libc::c_int);
}
#[inline(always)]
unsafe extern "C" fn trellis_coef(
    mut j: libc::c_int,
    mut const_level: libc::c_int,
    mut abs_level: libc::c_int,
    mut prefix: libc::c_int,
    mut suffix_cost: libc::c_int,
    mut node_ctx: libc::c_int,
    mut level1_ctx: libc::c_int,
    mut levelgt1_ctx: libc::c_int,
    mut ssd: uint64_t,
    mut cost_siglast: *mut libc::c_int,
    mut nodes_cur: *mut trellis_node_t,
    mut nodes_prev: *mut trellis_node_t,
    mut level_tree: *mut trellis_level_t,
    mut levels_used: libc::c_int,
    mut lambda2: libc::c_int,
    mut level_state: *mut uint8_t,
) -> libc::c_int {
    let mut score: uint64_t = ((*nodes_prev.offset(j as isize)).score).wrapping_add(ssd);
    let mut f8_bits: libc::c_uint = *cost_siglast
        .offset((if j != 0 { 1 as libc::c_int } else { 2 as libc::c_int }) as isize)
        as libc::c_uint;
    let mut level1_state: uint8_t = (if j >= 3 as libc::c_int {
        (*nodes_prev.offset(j as isize))
            .cabac_state[(level1_ctx >> 2 as libc::c_int) as usize] as libc::c_int
    } else {
        *level_state.offset(level1_ctx as isize) as libc::c_int
    }) as uint8_t;
    f8_bits = f8_bits
        .wrapping_add(
            x264_cabac_entropy[(level1_state as libc::c_int
                ^ (const_level > 1 as libc::c_int) as libc::c_int) as usize]
                as libc::c_uint,
        );
    let mut levelgt1_state: uint8_t = 0;
    if const_level > 1 as libc::c_int {
        levelgt1_state = (if j >= 6 as libc::c_int {
            (*nodes_prev.offset(j as isize))
                .cabac_state[(levelgt1_ctx - 6 as libc::c_int) as usize] as libc::c_int
        } else {
            *level_state.offset(levelgt1_ctx as isize) as libc::c_int
        }) as uint8_t;
        f8_bits = f8_bits
            .wrapping_add(
                (x264_8_cabac_size_unary[prefix as usize][levelgt1_state as usize]
                    as libc::c_int + suffix_cost) as libc::c_uint,
            );
    } else {
        f8_bits = f8_bits
            .wrapping_add(((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint);
    }
    score = score
        .wrapping_add(
            f8_bits as uint64_t * lambda2 as uint64_t
                >> 8 as libc::c_int - 4 as libc::c_int,
        );
    if score < (*nodes_cur.offset(node_ctx as isize)).score {
        (*nodes_cur.offset(node_ctx as isize)).score = score;
        if j == 2 as libc::c_int || j <= 3 as libc::c_int && node_ctx == 4 as libc::c_int
        {
            (*(((*nodes_cur.offset(node_ctx as isize)).cabac_state).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*(level_state.offset(12 as libc::c_int as isize)
                as *mut x264_union32_t))
                .i;
        } else if j >= 3 as libc::c_int {
            (*(((*nodes_cur.offset(node_ctx as isize)).cabac_state).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*(((*nodes_prev.offset(j as isize)).cabac_state).as_mut_ptr()
                as *mut x264_union32_t))
                .i;
        }
        if j >= 3 as libc::c_int {
            (*nodes_cur.offset(node_ctx as isize))
                .cabac_state[(level1_ctx >> 2 as libc::c_int)
                as usize] = x264_cabac_transition[level1_state
                as usize][(const_level > 1 as libc::c_int) as libc::c_int as usize];
        }
        if const_level > 1 as libc::c_int && node_ctx == 7 as libc::c_int {
            (*nodes_cur.offset(node_ctx as isize))
                .cabac_state[(levelgt1_ctx - 6 as libc::c_int)
                as usize] = x264_8_cabac_transition_unary[prefix
                as usize][levelgt1_state as usize];
        }
        (*nodes_cur.offset(node_ctx as isize))
            .level_idx = (*nodes_prev.offset(j as isize)).level_idx;
        if ::core::mem::size_of::<trellis_level_t>() as libc::c_ulong
            == ::core::mem::size_of::<uint32_t>() as libc::c_ulong
        {
            (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                as *mut x264_union32_t))
                .i = pack16to32(
                (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                abs_level as uint32_t,
            );
        } else {
            *level_tree
                .offset(
                    levels_used as isize,
                ) = {
                let mut init = trellis_level_t {
                    next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                    abs_level: abs_level as uint16_t,
                };
                init
            };
        }
        (*nodes_cur.offset(node_ctx as isize)).level_idx = levels_used;
        levels_used += 1;
        levels_used;
    }
    return levels_used;
}
#[inline(never)]
unsafe extern "C" fn trellis_coef0_0(
    mut ssd0: uint64_t,
    mut nodes_cur: *mut trellis_node_t,
    mut nodes_prev: *mut trellis_node_t,
    mut level_tree: *mut trellis_level_t,
    mut levels_used: libc::c_int,
) -> libc::c_int {
    (*nodes_cur.offset(0 as libc::c_int as isize))
        .score = ((*nodes_prev.offset(0 as libc::c_int as isize)).score)
        .wrapping_add(ssd0);
    (*nodes_cur.offset(0 as libc::c_int as isize))
        .level_idx = (*nodes_prev.offset(0 as libc::c_int as isize)).level_idx;
    let mut j: libc::c_int = 1 as libc::c_int;
    while j < 4 as libc::c_int
        && (*nodes_prev.offset(j as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        (*nodes_cur.offset(j as isize)).score = (*nodes_prev.offset(j as isize)).score;
        if j >= 3 as libc::c_int {
            (*(((*nodes_cur.offset(j as isize)).cabac_state).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*(((*nodes_prev.offset(j as isize)).cabac_state).as_mut_ptr()
                as *mut x264_union32_t))
                .i;
        }
        if ::core::mem::size_of::<trellis_level_t>() as libc::c_ulong
            == ::core::mem::size_of::<uint32_t>() as libc::c_ulong
        {
            (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                as *mut x264_union32_t))
                .i = pack16to32(
                (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                0 as libc::c_int as uint32_t,
            );
        } else {
            *level_tree
                .offset(
                    levels_used as isize,
                ) = {
                let mut init = trellis_level_t {
                    next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                    abs_level: 0 as libc::c_int as uint16_t,
                };
                init
            };
        }
        (*nodes_cur.offset(j as isize)).level_idx = levels_used;
        levels_used += 1;
        levels_used;
        j += 1;
        j;
    }
    return levels_used;
}
#[inline(never)]
unsafe extern "C" fn trellis_coef0_1(
    mut ssd0: uint64_t,
    mut nodes_cur: *mut trellis_node_t,
    mut nodes_prev: *mut trellis_node_t,
    mut level_tree: *mut trellis_level_t,
    mut levels_used: libc::c_int,
) -> libc::c_int {
    let mut j: libc::c_int = 1 as libc::c_int;
    while j < 8 as libc::c_int {
        if (*nodes_prev.offset(j as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
        {
            (*nodes_cur.offset(j as isize))
                .score = (*nodes_prev.offset(j as isize)).score;
            if j >= 3 as libc::c_int {
                (*(((*nodes_cur.offset(j as isize)).cabac_state).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*(((*nodes_prev.offset(j as isize)).cabac_state).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
            }
            if ::core::mem::size_of::<trellis_level_t>() as libc::c_ulong
                == ::core::mem::size_of::<uint32_t>() as libc::c_ulong
            {
                (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                    as *mut x264_union32_t))
                    .i = pack16to32(
                    (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                    0 as libc::c_int as uint32_t,
                );
            } else {
                *level_tree
                    .offset(
                        levels_used as isize,
                    ) = {
                    let mut init = trellis_level_t {
                        next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                        abs_level: 0 as libc::c_int as uint16_t,
                    };
                    init
                };
            }
            (*nodes_cur.offset(j as isize)).level_idx = levels_used;
            levels_used += 1;
            levels_used;
        }
        j += 1;
        j;
    }
    return levels_used;
}
#[inline(never)]
unsafe extern "C" fn trellis_coef1_0(
    mut ssd0: uint64_t,
    mut ssd1: uint64_t,
    mut cost_siglast: *mut libc::c_int,
    mut nodes_cur: *mut trellis_node_t,
    mut nodes_prev: *mut trellis_node_t,
    mut level_tree: *mut trellis_level_t,
    mut levels_used: libc::c_int,
    mut lambda2: libc::c_int,
    mut level_state: *mut uint8_t,
) -> libc::c_int {
    let mut abs_level: libc::c_int = 1 as libc::c_int;
    let mut prefix: libc::c_int = 1 as libc::c_int;
    let mut suffix_cost: libc::c_int = 0 as libc::c_int;
    if 0 as libc::c_int == 0
        || (*nodes_prev.offset(0 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            0 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
            if 0 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    if 1 as libc::c_int == 0
        || (*nodes_prev.offset(1 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            1 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            2 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            if 1 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    if 2 as libc::c_int == 0
        || (*nodes_prev.offset(2 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            2 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            3 as libc::c_int,
            3 as libc::c_int,
            0 as libc::c_int,
            if 2 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    if 3 as libc::c_int == 0
        || (*nodes_prev.offset(3 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            3 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            3 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            if 3 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    return levels_used;
}
#[inline(never)]
unsafe extern "C" fn trellis_coef1_1(
    mut ssd0: uint64_t,
    mut ssd1: uint64_t,
    mut cost_siglast: *mut libc::c_int,
    mut nodes_cur: *mut trellis_node_t,
    mut nodes_prev: *mut trellis_node_t,
    mut level_tree: *mut trellis_level_t,
    mut levels_used: libc::c_int,
    mut lambda2: libc::c_int,
    mut level_state: *mut uint8_t,
) -> libc::c_int {
    let mut abs_level: libc::c_int = 1 as libc::c_int;
    let mut prefix: libc::c_int = 1 as libc::c_int;
    let mut suffix_cost: libc::c_int = 0 as libc::c_int;
    if 1 as libc::c_int == 0
        || (*nodes_prev.offset(1 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            1 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            2 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            if 1 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 2 as libc::c_int == 0
        || (*nodes_prev.offset(2 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            2 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            3 as libc::c_int,
            3 as libc::c_int,
            0 as libc::c_int,
            if 2 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 3 as libc::c_int == 0
        || (*nodes_prev.offset(3 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            3 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            3 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            if 3 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 4 as libc::c_int == 0
        || (*nodes_prev.offset(4 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            4 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            if 4 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 5 as libc::c_int == 0
        || (*nodes_prev.offset(5 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            5 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            5 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            if 5 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 6 as libc::c_int == 0
        || (*nodes_prev.offset(6 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            6 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            6 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            if 6 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 7 as libc::c_int == 0
        || (*nodes_prev.offset(7 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            7 as libc::c_int,
            1 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            7 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            if 7 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    return levels_used;
}
#[inline(never)]
unsafe extern "C" fn trellis_coefn_0(
    mut abs_level: libc::c_int,
    mut ssd0: uint64_t,
    mut ssd1: uint64_t,
    mut cost_siglast: *mut libc::c_int,
    mut nodes_cur: *mut trellis_node_t,
    mut nodes_prev: *mut trellis_node_t,
    mut level_tree: *mut trellis_level_t,
    mut levels_used: libc::c_int,
    mut lambda2: libc::c_int,
    mut level_state: *mut uint8_t,
    mut levelgt1_ctx: libc::c_int,
) -> libc::c_int {
    let mut prefix: libc::c_int = if (abs_level - 1 as libc::c_int) < 14 as libc::c_int {
        abs_level - 1 as libc::c_int
    } else {
        14 as libc::c_int
    };
    let mut suffix_cost: libc::c_int = if abs_level >= 15 as libc::c_int {
        bs_size_ue_big((abs_level - 15 as libc::c_int) as libc::c_uint)
            << 8 as libc::c_int
    } else {
        0 as libc::c_int
    };
    if 0 as libc::c_int == 0
        || (*nodes_prev.offset(0 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            0 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            1 as libc::c_int,
            5 as libc::c_int,
            if 0 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    if 1 as libc::c_int == 0
        || (*nodes_prev.offset(1 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            1 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            2 as libc::c_int,
            5 as libc::c_int,
            if 1 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    if 2 as libc::c_int == 0
        || (*nodes_prev.offset(2 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            2 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            3 as libc::c_int,
            5 as libc::c_int,
            if 2 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    if 3 as libc::c_int == 0
        || (*nodes_prev.offset(3 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            3 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            4 as libc::c_int,
            5 as libc::c_int,
            if 3 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 0 as libc::c_int == 0 {
        return levels_used
    }
    return levels_used;
}
#[inline(never)]
unsafe extern "C" fn trellis_coefn_1(
    mut abs_level: libc::c_int,
    mut ssd0: uint64_t,
    mut ssd1: uint64_t,
    mut cost_siglast: *mut libc::c_int,
    mut nodes_cur: *mut trellis_node_t,
    mut nodes_prev: *mut trellis_node_t,
    mut level_tree: *mut trellis_level_t,
    mut levels_used: libc::c_int,
    mut lambda2: libc::c_int,
    mut level_state: *mut uint8_t,
    mut levelgt1_ctx: libc::c_int,
) -> libc::c_int {
    let mut prefix: libc::c_int = if (abs_level - 1 as libc::c_int) < 14 as libc::c_int {
        abs_level - 1 as libc::c_int
    } else {
        14 as libc::c_int
    };
    let mut suffix_cost: libc::c_int = if abs_level >= 15 as libc::c_int {
        bs_size_ue_big((abs_level - 15 as libc::c_int) as libc::c_uint)
            << 8 as libc::c_int
    } else {
        0 as libc::c_int
    };
    if 1 as libc::c_int == 0
        || (*nodes_prev.offset(1 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            1 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            2 as libc::c_int,
            5 as libc::c_int,
            if 1 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 2 as libc::c_int == 0
        || (*nodes_prev.offset(2 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            2 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            3 as libc::c_int,
            5 as libc::c_int,
            if 2 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 3 as libc::c_int == 0
        || (*nodes_prev.offset(3 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            3 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            4 as libc::c_int,
            4 as libc::c_int,
            5 as libc::c_int,
            if 3 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 4 as libc::c_int == 0
        || (*nodes_prev.offset(4 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            4 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            5 as libc::c_int,
            0 as libc::c_int,
            6 as libc::c_int,
            if 4 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 5 as libc::c_int == 0
        || (*nodes_prev.offset(5 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            5 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            6 as libc::c_int,
            0 as libc::c_int,
            7 as libc::c_int,
            if 5 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 6 as libc::c_int == 0
        || (*nodes_prev.offset(6 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            6 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            7 as libc::c_int,
            0 as libc::c_int,
            8 as libc::c_int,
            if 6 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    if 7 as libc::c_int == 0
        || (*nodes_prev.offset(7 as libc::c_int as isize)).score as int64_t
            >= 0 as libc::c_int as int64_t
    {
        levels_used = trellis_coef(
            7 as libc::c_int,
            2 as libc::c_int,
            abs_level,
            prefix,
            suffix_cost,
            7 as libc::c_int,
            0 as libc::c_int,
            levelgt1_ctx,
            if 7 as libc::c_int != 0 { ssd1 } else { ssd0 },
            cost_siglast,
            nodes_cur,
            nodes_prev,
            level_tree,
            levels_used,
            lambda2,
            level_state,
        );
    } else if 1 as libc::c_int == 0 {
        return levels_used
    }
    return levels_used;
}
#[inline(always)]
unsafe extern "C" fn quant_trellis_cabac(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut quant_mf: *mut udctcoef,
    mut quant_bias: *mut udctcoef,
    mut unquant_mf: *const libc::c_int,
    mut zigzag: *const uint8_t,
    mut ctx_block_cat: libc::c_int,
    mut lambda2: libc::c_int,
    mut b_ac: libc::c_int,
    mut b_chroma: libc::c_int,
    mut dc: libc::c_int,
    mut num_coefs: libc::c_int,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut orig_coefs: [dctcoef; 64] = [0; 64];
    let mut quant_coefs: [dctcoef; 64] = [0; 64];
    let mut coef_weight1: *const uint32_t = if num_coefs == 64 as libc::c_int {
        x264_dct8_weight_tab.as_ptr()
    } else {
        x264_dct4_weight_tab.as_ptr()
    };
    let mut coef_weight2: *const uint32_t = if num_coefs == 64 as libc::c_int {
        x264_dct8_weight2_tab.as_ptr()
    } else {
        x264_dct4_weight2_tab.as_ptr()
    };
    let b_interlaced: libc::c_int = (*h).mb.b_interlaced;
    let mut cabac_state_sig: *mut uint8_t = &mut *((*h).cabac.state)
        .as_mut_ptr()
        .offset(
            *(*x264_significant_coeff_flag_offset.as_ptr().offset(b_interlaced as isize))
                .as_ptr()
                .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
    let mut cabac_state_last: *mut uint8_t = &mut *((*h).cabac.state)
        .as_mut_ptr()
        .offset(
            *(*x264_last_coeff_flag_offset.as_ptr().offset(b_interlaced as isize))
                .as_ptr()
                .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
    let mut levelgt1_ctx: libc::c_int = if b_chroma != 0 && dc != 0 {
        8 as libc::c_int
    } else {
        9 as libc::c_int
    };
    if dc != 0 {
        if num_coefs == 16 as libc::c_int {
            memcpy(
                orig_coefs.as_mut_ptr() as *mut libc::c_void,
                dct as *const libc::c_void,
                (::core::mem::size_of::<dctcoef>() as libc::c_ulong)
                    .wrapping_mul(16 as libc::c_int as libc::c_ulong),
            );
            if ((*h).quantf.quant_4x4_dc)
                .expect(
                    "non-null function pointer",
                )(
                dct,
                *quant_mf.offset(0 as libc::c_int as isize) as libc::c_int
                    >> 1 as libc::c_int,
                (*quant_bias.offset(0 as libc::c_int as isize) as libc::c_int)
                    << 1 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            ((*h).zigzagf.scan_4x4)
                .expect("non-null function pointer")(quant_coefs.as_mut_ptr(), dct);
        } else {
            memcpy(
                orig_coefs.as_mut_ptr() as *mut libc::c_void,
                dct as *const libc::c_void,
                (::core::mem::size_of::<dctcoef>() as libc::c_ulong)
                    .wrapping_mul(num_coefs as libc::c_ulong),
            );
            let mut nz: libc::c_int = ((*h).quantf.quant_2x2_dc)
                .expect(
                    "non-null function pointer",
                )(
                &mut *dct.offset(0 as libc::c_int as isize),
                *quant_mf.offset(0 as libc::c_int as isize) as libc::c_int
                    >> 1 as libc::c_int,
                (*quant_bias.offset(0 as libc::c_int as isize) as libc::c_int)
                    << 1 as libc::c_int,
            );
            if num_coefs == 8 as libc::c_int {
                nz
                    |= ((*h).quantf.quant_2x2_dc)
                        .expect(
                            "non-null function pointer",
                        )(
                        &mut *dct.offset(4 as libc::c_int as isize),
                        *quant_mf.offset(0 as libc::c_int as isize) as libc::c_int
                            >> 1 as libc::c_int,
                        (*quant_bias.offset(0 as libc::c_int as isize) as libc::c_int)
                            << 1 as libc::c_int,
                    );
            }
            if nz == 0 {
                return 0 as libc::c_int;
            }
            let mut i: libc::c_int = 0 as libc::c_int;
            while i < num_coefs {
                quant_coefs[i
                    as usize] = *dct.offset(*zigzag.offset(i as isize) as isize);
                i += 1;
                i;
            }
        }
    } else if num_coefs == 64 as libc::c_int {
        ((*h).mc.memcpy_aligned)
            .expect(
                "non-null function pointer",
            )(
            orig_coefs.as_mut_ptr() as *mut libc::c_void,
            dct as *const libc::c_void,
            (::core::mem::size_of::<dctcoef>() as libc::c_ulong)
                .wrapping_mul(64 as libc::c_int as libc::c_ulong),
        );
        if ((*h).quantf.quant_8x8)
            .expect("non-null function pointer")(dct, quant_mf, quant_bias) == 0
        {
            return 0 as libc::c_int;
        }
        ((*h).zigzagf.scan_8x8)
            .expect("non-null function pointer")(quant_coefs.as_mut_ptr(), dct);
    } else {
        memcpy(
            orig_coefs.as_mut_ptr() as *mut libc::c_void,
            dct as *const libc::c_void,
            (::core::mem::size_of::<dctcoef>() as libc::c_ulong)
                .wrapping_mul(16 as libc::c_int as libc::c_ulong),
        );
        if ((*h).quantf.quant_4x4)
            .expect("non-null function pointer")(dct, quant_mf, quant_bias) == 0
        {
            return 0 as libc::c_int;
        }
        ((*h).zigzagf.scan_4x4)
            .expect("non-null function pointer")(quant_coefs.as_mut_ptr(), dct);
    }
    let mut last_nnz: libc::c_int = ((*h).quantf.coeff_last[ctx_block_cat as usize])
        .expect(
            "non-null function pointer",
        )(quant_coefs.as_mut_ptr().offset(b_ac as isize)) + b_ac;
    let mut cabac_state: *mut uint8_t = &mut *((*h).cabac.state)
        .as_mut_ptr()
        .offset(
            *x264_coeff_abs_level_m1_offset.as_ptr().offset(ctx_block_cat as isize)
                as isize,
        ) as *mut uint8_t;
    if last_nnz == 0 as libc::c_int && dc == 0 {
        let mut cost_sig: libc::c_int = x264_cabac_size_decision_noup2(
            &mut *cabac_state_sig.offset(0 as libc::c_int as isize),
            1 as libc::c_int as libc::c_long,
        )
            + x264_cabac_size_decision_noup2(
                &mut *cabac_state_last.offset(0 as libc::c_int as isize),
                1 as libc::c_int as libc::c_long,
            );
        *dct
            .offset(
                0 as libc::c_int as isize,
            ) = trellis_dc_shortcut(
            orig_coefs[0 as libc::c_int as usize] as libc::c_int,
            quant_coefs[0 as libc::c_int as usize] as libc::c_int,
            *unquant_mf.offset(0 as libc::c_int as isize),
            *coef_weight2.offset(0 as libc::c_int as isize) as libc::c_int,
            lambda2,
            cabac_state,
            cost_sig,
        ) as dctcoef;
        return (*dct.offset(0 as libc::c_int as isize) != 0) as libc::c_int;
    }
    let mut level_tree: [trellis_level_t; 1024] = [trellis_level_t {
        next: 0,
        abs_level: 0,
    }; 1024];
    let mut levels_used: libc::c_int = 1 as libc::c_int;
    let mut nodes: [[trellis_node_t; 8]; 2] = [
        [
            {
                let mut init = trellis_node_t {
                    score: 0 as libc::c_int as uint64_t,
                    level_idx: 0,
                    cabac_state: [0; 4],
                };
                init
            },
            trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            },
            trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            },
            trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            },
            trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            },
            trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            },
            trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            },
            trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            },
        ],
        [trellis_node_t {
            score: 0,
            level_idx: 0,
            cabac_state: [0; 4],
        }; 8],
    ];
    let mut nodes_cur: *mut trellis_node_t = (nodes[0 as libc::c_int as usize])
        .as_mut_ptr();
    let mut nodes_prev: *mut trellis_node_t = (nodes[1 as libc::c_int as usize])
        .as_mut_ptr();
    let mut bnode: *mut trellis_node_t = 0 as *mut trellis_node_t;
    let mut j: libc::c_int = 1 as libc::c_int;
    while j < 8 as libc::c_int {
        (*nodes_cur.offset(j as isize)).score = !(0 as libc::c_ulonglong) as uint64_t;
        j += 1;
        j;
    }
    (*nodes_cur.offset(0 as libc::c_int as isize))
        .score = ((1 as libc::c_ulonglong) << 60 as libc::c_int) as uint64_t;
    (*nodes_cur.offset(0 as libc::c_int as isize)).level_idx = 0 as libc::c_int;
    level_tree[0 as libc::c_int as usize].abs_level = 0 as libc::c_int as uint16_t;
    level_tree[0 as libc::c_int as usize].next = 0 as libc::c_int as uint16_t;
    let mut level_state: [uint8_t; 16] = [0; 16];
    memcpy(
        level_state.as_mut_ptr() as *mut libc::c_void,
        cabac_state as *const libc::c_void,
        10 as libc::c_int as libc::c_ulong,
    );
    level_state[12 as libc::c_int
        as usize] = *cabac_state.offset(0 as libc::c_int as isize);
    level_state[13 as libc::c_int
        as usize] = *cabac_state.offset(4 as libc::c_int as isize);
    level_state[14 as libc::c_int
        as usize] = *cabac_state.offset(8 as libc::c_int as isize);
    level_state[15 as libc::c_int
        as usize] = *cabac_state.offset(9 as libc::c_int as isize);
    idx
        &= if num_coefs == 64 as libc::c_int {
            3 as libc::c_int
        } else {
            15 as libc::c_int
        };
    let mut i_0: libc::c_int = last_nnz;
    loop {
        if !(i_0 >= b_ac) {
            current_block = 10369920510435091891;
            break;
        }
        if quant_coefs[i_0 as usize] == 0 {
            if 0 as libc::c_int == 0 {
                let mut sigindex: libc::c_int = if dc == 0
                    && num_coefs == 64 as libc::c_int
                {
                    x264_significant_coeff_flag_offset_8x8[b_interlaced
                        as usize][i_0 as usize] as libc::c_int
                } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as libc::c_int {
                    x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as libc::c_int
                } else {
                    i_0
                };
                let mut cost_sig0: uint64_t = x264_cabac_size_decision_noup2(
                    &mut *cabac_state_sig.offset(sigindex as isize),
                    0 as libc::c_int as libc::c_long,
                ) as uint64_t * lambda2 as uint64_t
                    >> 8 as libc::c_int - 4 as libc::c_int;
                let ref mut fresh0 = (*nodes_cur.offset(0 as libc::c_int as isize))
                    .score;
                *fresh0 = (*fresh0).wrapping_sub(cost_sig0);
            }
            let mut j_0: libc::c_int = 1 as libc::c_int;
            while j_0
                < (if 0 as libc::c_int != 0 {
                    8 as libc::c_int
                } else {
                    4 as libc::c_int
                })
            {
                if ::core::mem::size_of::<trellis_level_t>() as libc::c_ulong
                    == ::core::mem::size_of::<uint32_t>() as libc::c_ulong
                {
                    (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                        as *mut trellis_level_t as *mut x264_union32_t))
                        .i = pack16to32(
                        (*nodes_cur.offset(j_0 as isize)).level_idx as uint32_t,
                        0 as libc::c_int as uint32_t,
                    );
                } else {
                    level_tree[levels_used
                        as usize] = {
                        let mut init = trellis_level_t {
                            next: (*nodes_cur.offset(j_0 as isize)).level_idx
                                as uint16_t,
                            abs_level: 0 as libc::c_int as uint16_t,
                        };
                        init
                    };
                }
                (*nodes_cur.offset(j_0 as isize)).level_idx = levels_used;
                levels_used += 1;
                levels_used;
                j_0 += 1;
                j_0;
            }
        } else {
            let mut sign_coef: libc::c_int = orig_coefs[*zigzag.offset(i_0 as isize)
                as usize] as libc::c_int;
            let mut abs_coef: libc::c_int = abs(sign_coef);
            let mut q: libc::c_int = abs(quant_coefs[i_0 as usize] as libc::c_int);
            let mut cost_siglast: [libc::c_int; 3] = [0; 3];
            let mut t: *mut trellis_node_t = nodes_cur;
            nodes_cur = nodes_prev;
            nodes_prev = t;
            let mut j_1: libc::c_int = 0 as libc::c_int;
            while j_1 < 8 as libc::c_int {
                (*nodes_cur.offset(j_1 as isize))
                    .score = !(0 as libc::c_ulonglong) as uint64_t;
                j_1 += 1;
                j_1;
            }
            if i_0 < num_coefs - 1 as libc::c_int || 0 as libc::c_int != 0 {
                let mut sigindex_0: libc::c_int = if dc == 0
                    && num_coefs == 64 as libc::c_int
                {
                    x264_significant_coeff_flag_offset_8x8[b_interlaced
                        as usize][i_0 as usize] as libc::c_int
                } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as libc::c_int {
                    x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as libc::c_int
                } else {
                    i_0
                };
                let mut lastindex: libc::c_int = if dc == 0
                    && num_coefs == 64 as libc::c_int
                {
                    x264_last_coeff_flag_offset_8x8[i_0 as usize] as libc::c_int
                } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as libc::c_int {
                    x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as libc::c_int
                } else {
                    i_0
                };
                cost_siglast[0 as libc::c_int
                    as usize] = x264_cabac_size_decision_noup2(
                    &mut *cabac_state_sig.offset(sigindex_0 as isize),
                    0 as libc::c_int as libc::c_long,
                );
                let mut cost_sig1: libc::c_int = x264_cabac_size_decision_noup2(
                    &mut *cabac_state_sig.offset(sigindex_0 as isize),
                    1 as libc::c_int as libc::c_long,
                );
                cost_siglast[1 as libc::c_int
                    as usize] = x264_cabac_size_decision_noup2(
                    &mut *cabac_state_last.offset(lastindex as isize),
                    0 as libc::c_int as libc::c_long,
                ) + cost_sig1;
                if 0 as libc::c_int == 0 {
                    cost_siglast[2 as libc::c_int
                        as usize] = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_last.offset(lastindex as isize),
                        1 as libc::c_int as libc::c_long,
                    ) + cost_sig1;
                }
            } else {
                cost_siglast[2 as libc::c_int as usize] = 0 as libc::c_int;
                cost_siglast[1 as libc::c_int
                    as usize] = cost_siglast[2 as libc::c_int as usize];
                cost_siglast[0 as libc::c_int
                    as usize] = cost_siglast[1 as libc::c_int as usize];
            }
            let mut ssd0: [uint64_t; 2] = [0; 2];
            let mut ssd1: [uint64_t; 2] = [0; 2];
            let mut k: libc::c_int = 0 as libc::c_int;
            while k < 2 as libc::c_int {
                let mut abs_level: libc::c_int = q - 1 as libc::c_int + k;
                let mut unquant_abs_level: libc::c_int = (if dc != 0 {
                    *unquant_mf.offset(0 as libc::c_int as isize) << 1 as libc::c_int
                } else {
                    *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                }) * abs_level + 128 as libc::c_int >> 8 as libc::c_int;
                let mut d: libc::c_int = abs_coef - unquant_abs_level;
                if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0 && b_chroma == 0 {
                    let mut orig_coef: libc::c_int = if num_coefs == 64 as libc::c_int {
                        (*h)
                            .mb
                            .pic
                            .fenc_dct8[idx
                            as usize][*zigzag.offset(i_0 as isize) as usize]
                            as libc::c_int
                    } else {
                        (*h)
                            .mb
                            .pic
                            .fenc_dct4[idx
                            as usize][*zigzag.offset(i_0 as isize) as usize]
                            as libc::c_int
                    };
                    let mut predicted_coef: libc::c_int = orig_coef - sign_coef;
                    let mut psy_value: libc::c_int = abs(
                        unquant_abs_level
                            + ((predicted_coef ^ sign_coef >> 31 as libc::c_int)
                                - (sign_coef >> 31 as libc::c_int)),
                    );
                    let mut psy_weight: libc::c_int = (*coef_weight1
                        .offset(*zigzag.offset(i_0 as isize) as isize)
                        * (*h).mb.i_psy_trellis as uint32_t) as libc::c_int;
                    let mut tmp: int64_t = d as int64_t * d as int64_t
                        * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                            as int64_t - psy_weight as int64_t * psy_value as int64_t;
                    ssd1[k as usize] = tmp as uint64_t;
                } else {
                    ssd1[k
                        as usize] = (d as int64_t * d as int64_t
                        * (if dc != 0 {
                            256 as libc::c_int as uint32_t
                        } else {
                            *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                        }) as int64_t) as uint64_t;
                }
                ssd0[k as usize] = ssd1[k as usize];
                if i_0 == 0 && dc == 0 && 0 as libc::c_int == 0 {
                    d = sign_coef
                        - ((unquant_abs_level ^ sign_coef >> 31 as libc::c_int)
                            - (sign_coef >> 31 as libc::c_int) + 8 as libc::c_int
                            & !(15 as libc::c_int));
                    ssd0[k
                        as usize] = (d as int64_t * d as int64_t
                        * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                            as int64_t) as uint64_t;
                }
                k += 1;
                k;
            }
            match q {
                1 => {
                    ssd1[0 as libc::c_int
                        as usize] = (ssd1[0 as libc::c_int as usize])
                        .wrapping_add(
                            cost_siglast[0 as libc::c_int as usize] as uint64_t
                                * lambda2 as uint64_t >> 8 as libc::c_int - 4 as libc::c_int,
                        );
                    levels_used = trellis_coef0_0(
                        (ssd0[0 as libc::c_int as usize])
                            .wrapping_sub(ssd1[0 as libc::c_int as usize]),
                        nodes_cur,
                        nodes_prev,
                        level_tree.as_mut_ptr(),
                        levels_used,
                    );
                    levels_used = trellis_coef1_0(
                        (ssd0[1 as libc::c_int as usize])
                            .wrapping_sub(ssd1[0 as libc::c_int as usize]),
                        (ssd1[1 as libc::c_int as usize])
                            .wrapping_sub(ssd1[0 as libc::c_int as usize]),
                        cost_siglast.as_mut_ptr(),
                        nodes_cur,
                        nodes_prev,
                        level_tree.as_mut_ptr(),
                        levels_used,
                        lambda2,
                        level_state.as_mut_ptr(),
                    );
                }
                2 => {
                    levels_used = trellis_coef1_0(
                        ssd0[0 as libc::c_int as usize],
                        ssd1[0 as libc::c_int as usize],
                        cost_siglast.as_mut_ptr(),
                        nodes_cur,
                        nodes_prev,
                        level_tree.as_mut_ptr(),
                        levels_used,
                        lambda2,
                        level_state.as_mut_ptr(),
                    );
                    levels_used = trellis_coefn_0(
                        q,
                        ssd0[1 as libc::c_int as usize],
                        ssd1[1 as libc::c_int as usize],
                        cost_siglast.as_mut_ptr(),
                        nodes_cur,
                        nodes_prev,
                        level_tree.as_mut_ptr(),
                        levels_used,
                        lambda2,
                        level_state.as_mut_ptr(),
                        levelgt1_ctx,
                    );
                    current_block = 15622658527355336244;
                    break;
                }
                _ => {
                    levels_used = trellis_coefn_0(
                        q - 1 as libc::c_int,
                        ssd0[0 as libc::c_int as usize],
                        ssd1[0 as libc::c_int as usize],
                        cost_siglast.as_mut_ptr(),
                        nodes_cur,
                        nodes_prev,
                        level_tree.as_mut_ptr(),
                        levels_used,
                        lambda2,
                        level_state.as_mut_ptr(),
                        levelgt1_ctx,
                    );
                    levels_used = trellis_coefn_0(
                        q,
                        ssd0[1 as libc::c_int as usize],
                        ssd1[1 as libc::c_int as usize],
                        cost_siglast.as_mut_ptr(),
                        nodes_cur,
                        nodes_prev,
                        level_tree.as_mut_ptr(),
                        levels_used,
                        lambda2,
                        level_state.as_mut_ptr(),
                        levelgt1_ctx,
                    );
                    current_block = 15622658527355336244;
                    break;
                }
            }
        }
        i_0 -= 1;
        i_0;
    }
    match current_block {
        15622658527355336244 => {
            loop {
                i_0 -= 1;
                i_0;
                if !(i_0 >= b_ac) {
                    break;
                }
                if quant_coefs[i_0 as usize] == 0 {
                    if 1 as libc::c_int == 0 {
                        let mut sigindex_1: libc::c_int = if dc == 0
                            && num_coefs == 64 as libc::c_int
                        {
                            x264_significant_coeff_flag_offset_8x8[b_interlaced
                                as usize][i_0 as usize] as libc::c_int
                        } else if b_chroma != 0 && dc != 0
                            && num_coefs == 8 as libc::c_int
                        {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                as libc::c_int
                        } else {
                            i_0
                        };
                        let mut cost_sig0_0: uint64_t = x264_cabac_size_decision_noup2(
                            &mut *cabac_state_sig.offset(sigindex_1 as isize),
                            0 as libc::c_int as libc::c_long,
                        ) as uint64_t * lambda2 as uint64_t
                            >> 8 as libc::c_int - 4 as libc::c_int;
                        let ref mut fresh1 = (*nodes_cur
                            .offset(0 as libc::c_int as isize))
                            .score;
                        *fresh1 = (*fresh1).wrapping_sub(cost_sig0_0);
                    }
                    let mut j_3: libc::c_int = 1 as libc::c_int;
                    while j_3
                        < (if 1 as libc::c_int != 0 {
                            8 as libc::c_int
                        } else {
                            4 as libc::c_int
                        })
                    {
                        if ::core::mem::size_of::<trellis_level_t>() as libc::c_ulong
                            == ::core::mem::size_of::<uint32_t>() as libc::c_ulong
                        {
                            (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                                as *mut trellis_level_t as *mut x264_union32_t))
                                .i = pack16to32(
                                (*nodes_cur.offset(j_3 as isize)).level_idx as uint32_t,
                                0 as libc::c_int as uint32_t,
                            );
                        } else {
                            level_tree[levels_used
                                as usize] = {
                                let mut init = trellis_level_t {
                                    next: (*nodes_cur.offset(j_3 as isize)).level_idx
                                        as uint16_t,
                                    abs_level: 0 as libc::c_int as uint16_t,
                                };
                                init
                            };
                        }
                        (*nodes_cur.offset(j_3 as isize)).level_idx = levels_used;
                        levels_used += 1;
                        levels_used;
                        j_3 += 1;
                        j_3;
                    }
                } else {
                    let mut sign_coef_0: libc::c_int = orig_coefs[*zigzag
                        .offset(i_0 as isize) as usize] as libc::c_int;
                    let mut abs_coef_0: libc::c_int = abs(sign_coef_0);
                    let mut q_0: libc::c_int = abs(
                        quant_coefs[i_0 as usize] as libc::c_int,
                    );
                    let mut cost_siglast_0: [libc::c_int; 3] = [0; 3];
                    let mut t_0: *mut trellis_node_t = nodes_cur;
                    nodes_cur = nodes_prev;
                    nodes_prev = t_0;
                    let mut j_4: libc::c_int = 1 as libc::c_int;
                    while j_4 < 8 as libc::c_int {
                        (*nodes_cur.offset(j_4 as isize))
                            .score = !(0 as libc::c_ulonglong) as uint64_t;
                        j_4 += 1;
                        j_4;
                    }
                    if i_0 < num_coefs - 1 as libc::c_int || 1 as libc::c_int != 0 {
                        let mut sigindex_2: libc::c_int = if dc == 0
                            && num_coefs == 64 as libc::c_int
                        {
                            x264_significant_coeff_flag_offset_8x8[b_interlaced
                                as usize][i_0 as usize] as libc::c_int
                        } else if b_chroma != 0 && dc != 0
                            && num_coefs == 8 as libc::c_int
                        {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                as libc::c_int
                        } else {
                            i_0
                        };
                        let mut lastindex_0: libc::c_int = if dc == 0
                            && num_coefs == 64 as libc::c_int
                        {
                            x264_last_coeff_flag_offset_8x8[i_0 as usize] as libc::c_int
                        } else if b_chroma != 0 && dc != 0
                            && num_coefs == 8 as libc::c_int
                        {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                as libc::c_int
                        } else {
                            i_0
                        };
                        cost_siglast_0[0 as libc::c_int
                            as usize] = x264_cabac_size_decision_noup2(
                            &mut *cabac_state_sig.offset(sigindex_2 as isize),
                            0 as libc::c_int as libc::c_long,
                        );
                        let mut cost_sig1_0: libc::c_int = x264_cabac_size_decision_noup2(
                            &mut *cabac_state_sig.offset(sigindex_2 as isize),
                            1 as libc::c_int as libc::c_long,
                        );
                        cost_siglast_0[1 as libc::c_int
                            as usize] = x264_cabac_size_decision_noup2(
                            &mut *cabac_state_last.offset(lastindex_0 as isize),
                            0 as libc::c_int as libc::c_long,
                        ) + cost_sig1_0;
                        if 1 as libc::c_int == 0 {
                            cost_siglast_0[2 as libc::c_int
                                as usize] = x264_cabac_size_decision_noup2(
                                &mut *cabac_state_last.offset(lastindex_0 as isize),
                                1 as libc::c_int as libc::c_long,
                            ) + cost_sig1_0;
                        }
                    } else {
                        cost_siglast_0[2 as libc::c_int as usize] = 0 as libc::c_int;
                        cost_siglast_0[1 as libc::c_int
                            as usize] = cost_siglast_0[2 as libc::c_int as usize];
                        cost_siglast_0[0 as libc::c_int
                            as usize] = cost_siglast_0[1 as libc::c_int as usize];
                    }
                    let mut ssd0_0: [uint64_t; 2] = [0; 2];
                    let mut ssd1_0: [uint64_t; 2] = [0; 2];
                    let mut k_0: libc::c_int = 0 as libc::c_int;
                    while k_0 < 2 as libc::c_int {
                        let mut abs_level_0: libc::c_int = q_0 - 1 as libc::c_int + k_0;
                        let mut unquant_abs_level_0: libc::c_int = (if dc != 0 {
                            *unquant_mf.offset(0 as libc::c_int as isize)
                                << 1 as libc::c_int
                        } else {
                            *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                        }) * abs_level_0 + 128 as libc::c_int >> 8 as libc::c_int;
                        let mut d_0: libc::c_int = abs_coef_0 - unquant_abs_level_0;
                        if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0
                            && b_chroma == 0
                        {
                            let mut orig_coef_0: libc::c_int = if num_coefs
                                == 64 as libc::c_int
                            {
                                (*h)
                                    .mb
                                    .pic
                                    .fenc_dct8[idx
                                    as usize][*zigzag.offset(i_0 as isize) as usize]
                                    as libc::c_int
                            } else {
                                (*h)
                                    .mb
                                    .pic
                                    .fenc_dct4[idx
                                    as usize][*zigzag.offset(i_0 as isize) as usize]
                                    as libc::c_int
                            };
                            let mut predicted_coef_0: libc::c_int = orig_coef_0
                                - sign_coef_0;
                            let mut psy_value_0: libc::c_int = abs(
                                unquant_abs_level_0
                                    + ((predicted_coef_0 ^ sign_coef_0 >> 31 as libc::c_int)
                                        - (sign_coef_0 >> 31 as libc::c_int)),
                            );
                            let mut psy_weight_0: libc::c_int = (*coef_weight1
                                .offset(*zigzag.offset(i_0 as isize) as isize)
                                * (*h).mb.i_psy_trellis as uint32_t) as libc::c_int;
                            let mut tmp_0: int64_t = d_0 as int64_t * d_0 as int64_t
                                * *coef_weight2
                                    .offset(*zigzag.offset(i_0 as isize) as isize) as int64_t
                                - psy_weight_0 as int64_t * psy_value_0 as int64_t;
                            ssd1_0[k_0 as usize] = tmp_0 as uint64_t;
                        } else {
                            ssd1_0[k_0
                                as usize] = (d_0 as int64_t * d_0 as int64_t
                                * (if dc != 0 {
                                    256 as libc::c_int as uint32_t
                                } else {
                                    *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                }) as int64_t) as uint64_t;
                        }
                        ssd0_0[k_0 as usize] = ssd1_0[k_0 as usize];
                        if i_0 == 0 && dc == 0 && 1 as libc::c_int == 0 {
                            d_0 = sign_coef_0
                                - ((unquant_abs_level_0 ^ sign_coef_0 >> 31 as libc::c_int)
                                    - (sign_coef_0 >> 31 as libc::c_int) + 8 as libc::c_int
                                    & !(15 as libc::c_int));
                            ssd0_0[k_0
                                as usize] = (d_0 as int64_t * d_0 as int64_t
                                * *coef_weight2
                                    .offset(*zigzag.offset(i_0 as isize) as isize) as int64_t)
                                as uint64_t;
                        }
                        k_0 += 1;
                        k_0;
                    }
                    match q_0 {
                        1 => {
                            ssd1_0[0 as libc::c_int
                                as usize] = (ssd1_0[0 as libc::c_int as usize])
                                .wrapping_add(
                                    cost_siglast_0[0 as libc::c_int as usize] as uint64_t
                                        * lambda2 as uint64_t >> 8 as libc::c_int - 4 as libc::c_int,
                                );
                            levels_used = trellis_coef0_1(
                                (ssd0_0[0 as libc::c_int as usize])
                                    .wrapping_sub(ssd1_0[0 as libc::c_int as usize]),
                                nodes_cur,
                                nodes_prev,
                                level_tree.as_mut_ptr(),
                                levels_used,
                            );
                            levels_used = trellis_coef1_1(
                                (ssd0_0[1 as libc::c_int as usize])
                                    .wrapping_sub(ssd1_0[0 as libc::c_int as usize]),
                                (ssd1_0[1 as libc::c_int as usize])
                                    .wrapping_sub(ssd1_0[0 as libc::c_int as usize]),
                                cost_siglast_0.as_mut_ptr(),
                                nodes_cur,
                                nodes_prev,
                                level_tree.as_mut_ptr(),
                                levels_used,
                                lambda2,
                                level_state.as_mut_ptr(),
                            );
                        }
                        2 => {
                            levels_used = trellis_coef1_1(
                                ssd0_0[0 as libc::c_int as usize],
                                ssd1_0[0 as libc::c_int as usize],
                                cost_siglast_0.as_mut_ptr(),
                                nodes_cur,
                                nodes_prev,
                                level_tree.as_mut_ptr(),
                                levels_used,
                                lambda2,
                                level_state.as_mut_ptr(),
                            );
                            levels_used = trellis_coefn_1(
                                q_0,
                                ssd0_0[1 as libc::c_int as usize],
                                ssd1_0[1 as libc::c_int as usize],
                                cost_siglast_0.as_mut_ptr(),
                                nodes_cur,
                                nodes_prev,
                                level_tree.as_mut_ptr(),
                                levels_used,
                                lambda2,
                                level_state.as_mut_ptr(),
                                levelgt1_ctx,
                            );
                        }
                        _ => {
                            levels_used = trellis_coefn_1(
                                q_0 - 1 as libc::c_int,
                                ssd0_0[0 as libc::c_int as usize],
                                ssd1_0[0 as libc::c_int as usize],
                                cost_siglast_0.as_mut_ptr(),
                                nodes_cur,
                                nodes_prev,
                                level_tree.as_mut_ptr(),
                                levels_used,
                                lambda2,
                                level_state.as_mut_ptr(),
                                levelgt1_ctx,
                            );
                            levels_used = trellis_coefn_1(
                                q_0,
                                ssd0_0[1 as libc::c_int as usize],
                                ssd1_0[1 as libc::c_int as usize],
                                cost_siglast_0.as_mut_ptr(),
                                nodes_cur,
                                nodes_prev,
                                level_tree.as_mut_ptr(),
                                levels_used,
                                lambda2,
                                level_state.as_mut_ptr(),
                                levelgt1_ctx,
                            );
                        }
                    }
                }
            }
            bnode = &mut *nodes_cur.offset(1 as libc::c_int as isize)
                as *mut trellis_node_t;
            let mut j_5: libc::c_int = 1 as libc::c_int + 1 as libc::c_int;
            while j_5
                < (if 1 as libc::c_int != 0 {
                    8 as libc::c_int
                } else {
                    4 as libc::c_int
                })
            {
                if (*nodes_cur.offset(j_5 as isize)).score < (*bnode).score {
                    bnode = &mut *nodes_cur.offset(j_5 as isize) as *mut trellis_node_t;
                }
                j_5 += 1;
                j_5;
            }
        }
        _ => {
            bnode = &mut *nodes_cur.offset(0 as libc::c_int as isize)
                as *mut trellis_node_t;
            let mut j_2: libc::c_int = 0 as libc::c_int + 1 as libc::c_int;
            while j_2
                < (if 0 as libc::c_int != 0 {
                    8 as libc::c_int
                } else {
                    4 as libc::c_int
                })
            {
                if (*nodes_cur.offset(j_2 as isize)).score < (*bnode).score {
                    bnode = &mut *nodes_cur.offset(j_2 as isize) as *mut trellis_node_t;
                }
                j_2 += 1;
                j_2;
            }
            if bnode
                == &mut *nodes_cur.offset(0 as libc::c_int as isize)
                    as *mut trellis_node_t
            {
                if num_coefs == 16 as libc::c_int && dc == 0 {
                    memset(
                        dct as *mut libc::c_void,
                        0 as libc::c_int,
                        (16 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<dctcoef>() as libc::c_ulong,
                            ),
                    );
                }
                return 0 as libc::c_int;
            }
        }
    }
    let mut level: libc::c_int = (*bnode).level_idx;
    i_0 = b_ac;
    while i_0 <= last_nnz {
        *dct
            .offset(
                *zigzag.offset(i_0 as isize) as isize,
            ) = ((level_tree[level as usize].abs_level as libc::c_int
            ^ *dct.offset(*zigzag.offset(i_0 as isize) as isize) as libc::c_int
                >> 31 as libc::c_int)
            - (*dct.offset(*zigzag.offset(i_0 as isize) as isize) as libc::c_int
                >> 31 as libc::c_int)) as dctcoef;
        level = level_tree[level as usize].next as libc::c_int;
        i_0 += 1;
        i_0;
    }
    return 1 as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn quant_trellis_cavlc(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut quant_mf: *const udctcoef,
    mut unquant_mf: *const libc::c_int,
    mut zigzag: *const uint8_t,
    mut ctx_block_cat: libc::c_int,
    mut lambda2: libc::c_int,
    mut b_ac: libc::c_int,
    mut b_chroma: libc::c_int,
    mut dc: libc::c_int,
    mut num_coefs: libc::c_int,
    mut idx: libc::c_int,
    mut b_8x8: libc::c_int,
) -> libc::c_int {
    let mut last_nnz: libc::c_int = 0;
    let mut coef_mask: libc::c_int = 0;
    let mut round_mask: libc::c_int = 0;
    let mut quant_coefs: [[dctcoef; 16]; 2] = [[0; 16]; 2];
    let mut coefs: [dctcoef; 16] = [0; 16];
    let mut coef_weight1: *const uint32_t = if b_8x8 != 0 {
        x264_dct8_weight_tab.as_ptr()
    } else {
        x264_dct4_weight_tab.as_ptr()
    };
    let mut coef_weight2: *const uint32_t = if b_8x8 != 0 {
        x264_dct8_weight2_tab.as_ptr()
    } else {
        x264_dct4_weight2_tab.as_ptr()
    };
    let mut delta_distortion: [int64_t; 16] = [0; 16];
    let mut score: int64_t = ((1 as libc::c_ulonglong) << 62 as libc::c_int) as int64_t;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let f: libc::c_int = (1 as libc::c_int) << 15 as libc::c_int;
    let mut nC: libc::c_int = if b_chroma != 0 && dc != 0 {
        3 as libc::c_int + (num_coefs >> 2 as libc::c_int)
    } else {
        ct_index[x264_mb_predict_non_zero_code(
            h,
            if b_chroma == 0 && dc != 0 {
                (idx - 48 as libc::c_int) * 16 as libc::c_int
            } else {
                idx
            },
        ) as usize] as libc::c_int
    };
    i = 0 as libc::c_int;
    while i < 16 as libc::c_int {
        (*(&mut *coefs.as_mut_ptr().offset(i as isize) as *mut dctcoef
            as *mut x264_union128_sse_t))
            .i = _mm_setr_ps(
            0 as libc::c_int as libc::c_float,
            0 as libc::c_int as libc::c_float,
            0 as libc::c_int as libc::c_float,
            0 as libc::c_int as libc::c_float,
        );
        i = (i as libc::c_ulong)
            .wrapping_add(
                (16 as libc::c_int as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<dctcoef>() as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
    }
    let mut step: libc::c_int = 1 as libc::c_int;
    let mut start: libc::c_int = b_ac;
    let mut end: libc::c_int = num_coefs - 1 as libc::c_int;
    if b_8x8 != 0 {
        start = idx & 3 as libc::c_int;
        end = 60 as libc::c_int + start;
        step = 4 as libc::c_int;
    }
    idx &= 15 as libc::c_int;
    lambda2 <<= 4 as libc::c_int;
    i = end;
    while i >= start {
        if abs(*dct.offset(*zigzag.offset(i as isize) as isize) as libc::c_int)
            * (if dc != 0 {
                *quant_mf.offset(0 as libc::c_int as isize) as libc::c_int
                    >> 1 as libc::c_int
            } else {
                *quant_mf.offset(*zigzag.offset(i as isize) as isize) as libc::c_int
            }) >= f
        {
            break;
        }
        i -= step;
    }
    if !(i < start) {
        last_nnz = if b_8x8 != 0 { i >> 2 as libc::c_int } else { i };
        coef_mask = 0 as libc::c_int;
        round_mask = 0 as libc::c_int;
        i = b_ac;
        j = start;
        while i <= last_nnz {
            let mut coef: libc::c_int = *dct.offset(*zigzag.offset(j as isize) as isize)
                as libc::c_int;
            let mut abs_coef: libc::c_int = abs(coef);
            let mut sign: libc::c_int = if coef < 0 as libc::c_int {
                -(1 as libc::c_int)
            } else {
                1 as libc::c_int
            };
            let mut nearest_quant: libc::c_int = f
                + abs_coef
                    * (if dc != 0 {
                        *quant_mf.offset(0 as libc::c_int as isize) as libc::c_int
                            >> 1 as libc::c_int
                    } else {
                        *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                            as libc::c_int
                    }) >> 16 as libc::c_int;
            quant_coefs[0 as libc::c_int
                as usize][i as usize] = (sign * nearest_quant) as dctcoef;
            quant_coefs[1 as libc::c_int
                as usize][i
                as usize] = quant_coefs[0 as libc::c_int as usize][i as usize];
            coefs[i as usize] = quant_coefs[1 as libc::c_int as usize][i as usize];
            if nearest_quant != 0 {
                let mut deadzone_quant: libc::c_int = f / 2 as libc::c_int
                    + abs_coef
                        * (if dc != 0 {
                            *quant_mf.offset(0 as libc::c_int as isize) as libc::c_int
                                >> 1 as libc::c_int
                        } else {
                            *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                                as libc::c_int
                        }) >> 16 as libc::c_int;
                let mut unquant1: libc::c_int = (if dc != 0 {
                    *unquant_mf.offset(0 as libc::c_int as isize) << 1 as libc::c_int
                } else {
                    *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                }) * (nearest_quant - 0 as libc::c_int) + 128 as libc::c_int
                    >> 8 as libc::c_int;
                let mut unquant0: libc::c_int = (if dc != 0 {
                    *unquant_mf.offset(0 as libc::c_int as isize) << 1 as libc::c_int
                } else {
                    *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                }) * (nearest_quant - 1 as libc::c_int) + 128 as libc::c_int
                    >> 8 as libc::c_int;
                let mut d1: libc::c_int = abs_coef - unquant1;
                let mut d0: libc::c_int = abs_coef - unquant0;
                delta_distortion[i
                    as usize] = (d0 * d0 - d1 * d1) as int64_t
                    * (if dc != 0 {
                        256 as libc::c_int as uint32_t
                    } else {
                        *coef_weight2.offset(*zigzag.offset(j as isize) as isize)
                    }) as int64_t;
                if (*h).mb.i_psy_trellis != 0 && j != 0 && dc == 0 && b_chroma == 0 {
                    let mut orig_coef: libc::c_int = if b_8x8 != 0 {
                        (*h)
                            .mb
                            .pic
                            .fenc_dct8[(idx >> 2 as libc::c_int)
                            as usize][*zigzag.offset(j as isize) as usize] as libc::c_int
                    } else {
                        (*h)
                            .mb
                            .pic
                            .fenc_dct4[idx as usize][*zigzag.offset(j as isize) as usize]
                            as libc::c_int
                    };
                    let mut predicted_coef: libc::c_int = orig_coef - coef;
                    let mut psy_weight: libc::c_int = *coef_weight1
                        .offset(*zigzag.offset(j as isize) as isize) as libc::c_int;
                    let mut psy_value0: libc::c_int = (*h).mb.i_psy_trellis
                        * abs(predicted_coef + unquant0 * sign);
                    let mut psy_value1: libc::c_int = (*h).mb.i_psy_trellis
                        * abs(predicted_coef + unquant1 * sign);
                    delta_distortion[i as usize]
                        += ((psy_value0 - psy_value1) * psy_weight) as int64_t;
                }
                quant_coefs[0 as libc::c_int
                    as usize][i
                    as usize] = (sign * (nearest_quant - 1 as libc::c_int)) as dctcoef;
                if deadzone_quant != nearest_quant {
                    coefs[i
                        as usize] = quant_coefs[0 as libc::c_int as usize][i as usize];
                } else {
                    round_mask |= (1 as libc::c_int) << i;
                }
            } else {
                delta_distortion[i as usize] = 0 as libc::c_int as int64_t;
            }
            coef_mask |= ((coefs[i as usize] != 0) as libc::c_int) << i;
            i += 1;
            i;
            j += step;
        }
        (*h).out.bs.i_bits_encoded = 0 as libc::c_int;
        if coef_mask == 0 {
            (*h).out.bs.i_bits_encoded
                += x264_coeff0_token[nC as usize].i_size as libc::c_int;
        } else {
            cavlc_block_residual_internal(
                h,
                ctx_block_cat,
                coefs.as_mut_ptr().offset(b_ac as isize),
                nC,
            );
        }
        score = (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
        loop {
            let mut iter_score: int64_t = score;
            let mut iter_distortion_delta: int64_t = 0 as libc::c_int as int64_t;
            let mut iter_coef: libc::c_int = -(1 as libc::c_int);
            let mut iter_mask: libc::c_int = coef_mask;
            let mut iter_round: libc::c_int = round_mask;
            i = b_ac;
            while i <= last_nnz {
                if !(delta_distortion[i as usize] == 0) {
                    let mut cur_round: libc::c_int = round_mask
                        ^ (1 as libc::c_int) << i;
                    let mut round_change: libc::c_int = cur_round >> i
                        & 1 as libc::c_int;
                    let mut old_coef: libc::c_int = coefs[i as usize] as libc::c_int;
                    let mut new_coef: libc::c_int = quant_coefs[round_change
                        as usize][i as usize] as libc::c_int;
                    let mut cur_mask: libc::c_int = coef_mask
                        & !((1 as libc::c_int) << i)
                        | ((new_coef != 0) as libc::c_int) << i;
                    let mut cur_distortion_delta: int64_t = delta_distortion[i as usize]
                        * (if round_change != 0 {
                            -(1 as libc::c_int)
                        } else {
                            1 as libc::c_int
                        }) as int64_t;
                    let mut cur_score: int64_t = cur_distortion_delta;
                    coefs[i as usize] = new_coef as dctcoef;
                    (*h).out.bs.i_bits_encoded = 0 as libc::c_int;
                    if cur_mask == 0 {
                        (*h).out.bs.i_bits_encoded
                            += x264_coeff0_token[nC as usize].i_size as libc::c_int;
                    } else {
                        cavlc_block_residual_internal(
                            h,
                            ctx_block_cat,
                            coefs.as_mut_ptr().offset(b_ac as isize),
                            nC,
                        );
                    }
                    cur_score
                        += (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
                    coefs[i as usize] = old_coef as dctcoef;
                    if cur_score < iter_score {
                        iter_score = cur_score;
                        iter_coef = i;
                        iter_mask = cur_mask;
                        iter_round = cur_round;
                        iter_distortion_delta = cur_distortion_delta;
                    }
                }
                i += 1;
                i;
            }
            if !(iter_coef >= 0 as libc::c_int) {
                break;
            }
            score = iter_score - iter_distortion_delta;
            coef_mask = iter_mask;
            round_mask = iter_round;
            coefs[iter_coef
                as usize] = quant_coefs[(round_mask >> iter_coef & 1 as libc::c_int)
                as usize][iter_coef as usize];
            delta_distortion[iter_coef as usize] = 0 as libc::c_int as int64_t;
        }
        if coef_mask != 0 {
            i = b_ac;
            j = start;
            while i < num_coefs {
                *dct.offset(*zigzag.offset(j as isize) as isize) = coefs[i as usize];
                i += 1;
                i;
                j += step;
            }
            return 1 as libc::c_int;
        }
    }
    if dc == 0 {
        if b_8x8 != 0 {
            i = start;
            while i <= end {
                *dct
                    .offset(
                        *zigzag.offset(i as isize) as isize,
                    ) = 0 as libc::c_int as dctcoef;
                i += step;
            }
        } else {
            memset(
                dct as *mut libc::c_void,
                0 as libc::c_int,
                (16 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<dctcoef>() as libc::c_ulong),
            );
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_quant_luma_dc_trellis(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut i_quant_cat: libc::c_int,
    mut i_qp: libc::c_int,
    mut ctx_block_cat: libc::c_int,
    mut b_intra: libc::c_int,
    mut idx: libc::c_int,
) -> libc::c_int {
    if (*h).param.b_cabac != 0 {
        return quant_trellis_cabac(
            h,
            dct,
            (*((*h).quant4_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            (*((*h).quant4_bias0[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (*((*h).unquant4_mf[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (x264_zigzag_scan4[(*h).mb.b_interlaced as usize]).as_ptr(),
            ctx_block_cat,
            (*h).mb.i_trellis_lambda2[0 as libc::c_int as usize][b_intra as usize],
            0 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
            16 as libc::c_int,
            idx,
        );
    }
    return quant_trellis_cavlc(
        h,
        dct,
        (*((*h).quant4_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
        (*((*h).unquant4_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
        (x264_zigzag_scan4[(*h).mb.b_interlaced as usize]).as_ptr(),
        DCT_LUMA_DC as libc::c_int,
        (*h).mb.i_trellis_lambda2[0 as libc::c_int as usize][b_intra as usize],
        0 as libc::c_int,
        0 as libc::c_int,
        1 as libc::c_int,
        16 as libc::c_int,
        idx,
        0 as libc::c_int,
    );
}
static mut zigzag_scan2x2: [uint8_t; 4] = [
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
];
static mut zigzag_scan2x4: [uint8_t; 8] = [
    0 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    4 as libc::c_int as uint8_t,
    6 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
];
#[no_mangle]
pub unsafe extern "C" fn x264_8_quant_chroma_dc_trellis(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut i_qp: libc::c_int,
    mut b_intra: libc::c_int,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut zigzag: *const uint8_t = 0 as *const uint8_t;
    let mut num_coefs: libc::c_int = 0;
    let mut quant_cat: libc::c_int = CQM_4IC as libc::c_int + 1 as libc::c_int - b_intra;
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as libc::c_int {
        zigzag = zigzag_scan2x4.as_ptr();
        num_coefs = 8 as libc::c_int;
    } else {
        zigzag = zigzag_scan2x2.as_ptr();
        num_coefs = 4 as libc::c_int;
    }
    if (*h).param.b_cabac != 0 {
        return quant_trellis_cabac(
            h,
            dct,
            (*((*h).quant4_mf[quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            (*((*h).quant4_bias0[quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (*((*h).unquant4_mf[quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            zigzag,
            DCT_CHROMA_DC as libc::c_int,
            (*h).mb.i_trellis_lambda2[1 as libc::c_int as usize][b_intra as usize],
            0 as libc::c_int,
            1 as libc::c_int,
            1 as libc::c_int,
            num_coefs,
            idx,
        );
    }
    return quant_trellis_cavlc(
        h,
        dct,
        (*((*h).quant4_mf[quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
        (*((*h).unquant4_mf[quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
        zigzag,
        DCT_CHROMA_DC as libc::c_int,
        (*h).mb.i_trellis_lambda2[1 as libc::c_int as usize][b_intra as usize],
        0 as libc::c_int,
        1 as libc::c_int,
        1 as libc::c_int,
        num_coefs,
        idx,
        0 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_quant_4x4_trellis(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut i_quant_cat: libc::c_int,
    mut i_qp: libc::c_int,
    mut ctx_block_cat: libc::c_int,
    mut b_intra: libc::c_int,
    mut b_chroma: libc::c_int,
    mut idx: libc::c_int,
) -> libc::c_int {
    static mut ctx_ac: [uint8_t; 14] = [
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
    ];
    let mut b_ac: libc::c_int = ctx_ac[ctx_block_cat as usize] as libc::c_int;
    if (*h).param.b_cabac != 0 {
        return quant_trellis_cabac(
            h,
            dct,
            (*((*h).quant4_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            (*((*h).quant4_bias0[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (*((*h).unquant4_mf[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (x264_zigzag_scan4[(*h).mb.b_interlaced as usize]).as_ptr(),
            ctx_block_cat,
            (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
            b_ac,
            b_chroma,
            0 as libc::c_int,
            16 as libc::c_int,
            idx,
        );
    }
    return quant_trellis_cavlc(
        h,
        dct,
        (*((*h).quant4_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
        (*((*h).unquant4_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
        (x264_zigzag_scan4[(*h).mb.b_interlaced as usize]).as_ptr(),
        ctx_block_cat,
        (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
        b_ac,
        b_chroma,
        0 as libc::c_int,
        16 as libc::c_int,
        idx,
        0 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_quant_8x8_trellis(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut i_quant_cat: libc::c_int,
    mut i_qp: libc::c_int,
    mut ctx_block_cat: libc::c_int,
    mut b_intra: libc::c_int,
    mut b_chroma: libc::c_int,
    mut idx: libc::c_int,
) -> libc::c_int {
    if (*h).param.b_cabac != 0 {
        return quant_trellis_cabac(
            h,
            dct,
            (*((*h).quant8_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            (*((*h).quant8_bias0[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (*((*h).unquant8_mf[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (x264_zigzag_scan8[(*h).mb.b_interlaced as usize]).as_ptr(),
            ctx_block_cat,
            (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
            0 as libc::c_int,
            b_chroma,
            0 as libc::c_int,
            64 as libc::c_int,
            idx,
        );
    }
    let mut nzaccum: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        let mut nz: libc::c_int = quant_trellis_cavlc(
            h,
            dct,
            (*((*h).quant8_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            (*((*h).unquant8_mf[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
            (x264_zigzag_scan8[(*h).mb.b_interlaced as usize]).as_ptr(),
            DCT_LUMA_4x4 as libc::c_int,
            (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
            0 as libc::c_int,
            b_chroma,
            0 as libc::c_int,
            16 as libc::c_int,
            idx * 4 as libc::c_int + i,
            1 as libc::c_int,
        );
        (*h)
            .mb
            .cache
            .non_zero_count[x264_scan8[(idx * 4 as libc::c_int + i) as usize]
            as usize] = nz as uint8_t;
        nzaccum |= nz;
        i += 1;
        i;
    }
    (*(&mut *((*h).mb.cache.non_zero_count)
        .as_mut_ptr()
        .offset(
            (*x264_scan8
                .as_ptr()
                .offset(
                    (0 as libc::c_int * 16 as libc::c_int + idx * 4 as libc::c_int)
                        as isize,
                ) as libc::c_int + 0 as libc::c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
        .i = (0 as libc::c_int * 0x101 as libc::c_int) as uint16_t;
    (*(&mut *((*h).mb.cache.non_zero_count)
        .as_mut_ptr()
        .offset(
            (*x264_scan8
                .as_ptr()
                .offset(
                    (0 as libc::c_int * 16 as libc::c_int + idx * 4 as libc::c_int)
                        as isize,
                ) as libc::c_int + 8 as libc::c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
        .i = (0 as libc::c_int * 0x101 as libc::c_int) as uint16_t;
    return nzaccum;
}
#[inline(always)]
unsafe extern "C" fn x264_quant_4x4(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut i_qp: libc::c_int,
    mut ctx_block_cat: libc::c_int,
    mut b_intra: libc::c_int,
    mut p: libc::c_int,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut i_quant_cat: libc::c_int = if b_intra != 0 {
        if p != 0 { CQM_4IC as libc::c_int } else { CQM_4IY as libc::c_int }
    } else if p != 0 {
        CQM_4PC as libc::c_int
    } else {
        CQM_4PY as libc::c_int
    };
    if (*h).mb.b_noise_reduction != 0 {
        ((*h).quantf.denoise_dct)
            .expect(
                "non-null function pointer",
            )(
            dct,
            (*((*h).nr_residual_sum)
                .offset(
                    (0 as libc::c_int + (p != 0) as libc::c_int * 2 as libc::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
            (*((*h).nr_offset)
                .offset(
                    (0 as libc::c_int + (p != 0) as libc::c_int * 2 as libc::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
            16 as libc::c_int,
        );
    }
    if (*h).mb.b_trellis != 0 {
        return x264_8_quant_4x4_trellis(
            h,
            dct,
            i_quant_cat,
            i_qp,
            ctx_block_cat,
            b_intra,
            (p != 0) as libc::c_int,
            idx + p * 16 as libc::c_int,
        )
    } else {
        return ((*h).quantf.quant_4x4)
            .expect(
                "non-null function pointer",
            )(
            dct,
            (*((*h).quant4_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            (*((*h).quant4_bias[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
        )
    };
}
#[inline(always)]
unsafe extern "C" fn x264_quant_8x8(
    mut h: *mut x264_t,
    mut dct: *mut dctcoef,
    mut i_qp: libc::c_int,
    mut ctx_block_cat: libc::c_int,
    mut b_intra: libc::c_int,
    mut p: libc::c_int,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut i_quant_cat: libc::c_int = if b_intra != 0 {
        if p != 0 { CQM_8IC as libc::c_int } else { CQM_8IY as libc::c_int }
    } else if p != 0 {
        CQM_8PC as libc::c_int
    } else {
        CQM_8PY as libc::c_int
    };
    if (*h).mb.b_noise_reduction != 0 {
        ((*h).quantf.denoise_dct)
            .expect(
                "non-null function pointer",
            )(
            dct,
            (*((*h).nr_residual_sum)
                .offset(
                    (1 as libc::c_int + (p != 0) as libc::c_int * 2 as libc::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
            (*((*h).nr_offset)
                .offset(
                    (1 as libc::c_int + (p != 0) as libc::c_int * 2 as libc::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
            64 as libc::c_int,
        );
    }
    if (*h).mb.b_trellis != 0 {
        return x264_8_quant_8x8_trellis(
            h,
            dct,
            i_quant_cat,
            i_qp,
            ctx_block_cat,
            b_intra,
            (p != 0) as libc::c_int,
            idx + p * 4 as libc::c_int,
        )
    } else {
        return ((*h).quantf.quant_8x8)
            .expect(
                "non-null function pointer",
            )(
            dct,
            (*((*h).quant8_mf[i_quant_cat as usize]).offset(i_qp as isize)).as_mut_ptr(),
            (*((*h).quant8_bias[i_quant_cat as usize]).offset(i_qp as isize))
                .as_mut_ptr(),
        )
    };
}
#[inline(always)]
unsafe extern "C" fn x264_mb_encode_i4x4(
    mut h: *mut x264_t,
    mut p: libc::c_int,
    mut idx: libc::c_int,
    mut i_qp: libc::c_int,
    mut i_mode: libc::c_int,
    mut b_predict: libc::c_int,
) {
    let mut nz: libc::c_int = 0;
    let mut p_src: *mut pixel = &mut *(*((*h).mb.pic.p_fenc)
        .as_mut_ptr()
        .offset(p as isize))
        .offset(*block_idx_xy_fenc.as_ptr().offset(idx as isize) as isize) as *mut pixel;
    let mut p_dst: *mut pixel = &mut *(*((*h).mb.pic.p_fdec)
        .as_mut_ptr()
        .offset(p as isize))
        .offset(*block_idx_xy_fdec.as_ptr().offset(idx as isize) as isize) as *mut pixel;
    let mut dct4x4: [dctcoef; 16] = [0; 16];
    if b_predict != 0 {
        if (*h).mb.b_lossless != 0 {
            x264_8_predict_lossless_4x4(h, p_dst, p, idx, i_mode);
        } else {
            ((*h).predict_4x4[i_mode as usize])
                .expect("non-null function pointer")(p_dst);
        }
    }
    if (*h).mb.b_lossless != 0 {
        nz = ((*h).zigzagf.sub_4x4)
            .expect(
                "non-null function pointer",
            )(
            ((*h).dct.luma4x4[(p * 16 as libc::c_int + idx) as usize]).as_mut_ptr(),
            p_src,
            p_dst,
        );
        (*h)
            .mb
            .cache
            .non_zero_count[x264_scan8[(p * 16 as libc::c_int + idx) as usize]
            as usize] = nz as uint8_t;
        (*h).mb.i_cbp_luma |= nz << (idx >> 2 as libc::c_int);
        return;
    }
    ((*h).dctf.sub4x4_dct)
        .expect("non-null function pointer")(dct4x4.as_mut_ptr(), p_src, p_dst);
    nz = x264_quant_4x4(
        h,
        dct4x4.as_mut_ptr(),
        i_qp,
        ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int as usize][p as usize] as libc::c_int,
        1 as libc::c_int,
        p,
        idx,
    );
    (*h)
        .mb
        .cache
        .non_zero_count[x264_scan8[(p * 16 as libc::c_int + idx) as usize]
        as usize] = nz as uint8_t;
    if nz != 0 {
        (*h).mb.i_cbp_luma |= (1 as libc::c_int) << (idx >> 2 as libc::c_int);
        ((*h).zigzagf.scan_4x4)
            .expect(
                "non-null function pointer",
            )(
            ((*h).dct.luma4x4[(p * 16 as libc::c_int + idx) as usize]).as_mut_ptr(),
            dct4x4.as_mut_ptr(),
        );
        ((*h).quantf.dequant_4x4)
            .expect(
                "non-null function pointer",
            )(
            dct4x4.as_mut_ptr(),
            (*h)
                .dequant4_mf[(if p != 0 {
                CQM_4IC as libc::c_int
            } else {
                CQM_4IY as libc::c_int
            }) as usize],
            i_qp,
        );
        ((*h).dctf.add4x4_idct)
            .expect("non-null function pointer")(p_dst, dct4x4.as_mut_ptr());
    }
}
#[inline(always)]
unsafe extern "C" fn x264_mb_encode_i8x8(
    mut h: *mut x264_t,
    mut p: libc::c_int,
    mut idx: libc::c_int,
    mut i_qp: libc::c_int,
    mut i_mode: libc::c_int,
    mut edge: *mut pixel,
    mut b_predict: libc::c_int,
) {
    let mut x: libc::c_int = idx & 1 as libc::c_int;
    let mut y: libc::c_int = idx >> 1 as libc::c_int;
    let mut nz: libc::c_int = 0;
    let mut p_src: *mut pixel = &mut *(*((*h).mb.pic.p_fenc)
        .as_mut_ptr()
        .offset(p as isize))
        .offset(
            (8 as libc::c_int * x + 8 as libc::c_int * y * 16 as libc::c_int) as isize,
        ) as *mut pixel;
    let mut p_dst: *mut pixel = &mut *(*((*h).mb.pic.p_fdec)
        .as_mut_ptr()
        .offset(p as isize))
        .offset(
            (8 as libc::c_int * x + 8 as libc::c_int * y * 32 as libc::c_int) as isize,
        ) as *mut pixel;
    let mut dct8x8: [dctcoef; 64] = [0; 64];
    let mut edge_buf: [pixel; 36] = [0; 36];
    if b_predict != 0 {
        if edge.is_null() {
            ((*h).predict_8x8_filter)
                .expect(
                    "non-null function pointer",
                )(
                p_dst,
                edge_buf.as_mut_ptr(),
                (*h).mb.i_neighbour8[idx as usize] as libc::c_int,
                x264_pred_i4x4_neighbors[i_mode as usize] as libc::c_int,
            );
            edge = edge_buf.as_mut_ptr();
        }
        if (*h).mb.b_lossless != 0 {
            x264_8_predict_lossless_8x8(h, p_dst, p, idx, i_mode, edge);
        } else {
            ((*h).predict_8x8[i_mode as usize])
                .expect("non-null function pointer")(p_dst, edge);
        }
    }
    if (*h).mb.b_lossless != 0 {
        nz = ((*h).zigzagf.sub_8x8)
            .expect(
                "non-null function pointer",
            )(
            ((*h).dct.luma8x8[(p * 4 as libc::c_int + idx) as usize]).as_mut_ptr(),
            p_src,
            p_dst,
        );
        (*(&mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as libc::c_int + idx * 4 as libc::c_int) as isize)
                    as libc::c_int + 0 as libc::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
            .i = (nz * 0x101 as libc::c_int) as uint16_t;
        (*(&mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as libc::c_int + idx * 4 as libc::c_int) as isize)
                    as libc::c_int + 8 as libc::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
            .i = (nz * 0x101 as libc::c_int) as uint16_t;
        (*h).mb.i_cbp_luma |= nz << idx;
        return;
    }
    ((*h).dctf.sub8x8_dct8)
        .expect("non-null function pointer")(dct8x8.as_mut_ptr(), p_src, p_dst);
    nz = x264_quant_8x8(
        h,
        dct8x8.as_mut_ptr(),
        i_qp,
        ctx_cat_plane[DCT_LUMA_8x8 as libc::c_int as usize][p as usize] as libc::c_int,
        1 as libc::c_int,
        p,
        idx,
    );
    if nz != 0 {
        (*h).mb.i_cbp_luma |= (1 as libc::c_int) << idx;
        ((*h).zigzagf.scan_8x8)
            .expect(
                "non-null function pointer",
            )(
            ((*h).dct.luma8x8[(p * 4 as libc::c_int + idx) as usize]).as_mut_ptr(),
            dct8x8.as_mut_ptr(),
        );
        ((*h).quantf.dequant_8x8)
            .expect(
                "non-null function pointer",
            )(
            dct8x8.as_mut_ptr(),
            (*h)
                .dequant8_mf[(if p != 0 {
                CQM_8IC as libc::c_int
            } else {
                CQM_8IY as libc::c_int
            }) as usize],
            i_qp,
        );
        ((*h).dctf.add8x8_idct8)
            .expect("non-null function pointer")(p_dst, dct8x8.as_mut_ptr());
        (*(&mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as libc::c_int + idx * 4 as libc::c_int) as isize)
                    as libc::c_int + 0 as libc::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
            .i = (1 as libc::c_int * 0x101 as libc::c_int) as uint16_t;
        (*(&mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as libc::c_int + idx * 4 as libc::c_int) as isize)
                    as libc::c_int + 8 as libc::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
            .i = (1 as libc::c_int * 0x101 as libc::c_int) as uint16_t;
    } else {
        (*(&mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as libc::c_int + idx * 4 as libc::c_int) as isize)
                    as libc::c_int + 0 as libc::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as libc::c_int * 0x101 as libc::c_int) as uint16_t;
        (*(&mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as libc::c_int + idx * 4 as libc::c_int) as isize)
                    as libc::c_int + 8 as libc::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as libc::c_int * 0x101 as libc::c_int) as uint16_t;
    };
}
#[inline]
unsafe extern "C" fn cabac_mb_type_intra(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_mb_type: libc::c_int,
    mut ctx0: libc::c_int,
    mut ctx1: libc::c_int,
    mut ctx2: libc::c_int,
    mut ctx3: libc::c_int,
    mut ctx4: libc::c_int,
    mut ctx5: libc::c_int,
) {
    if i_mb_type == I_4x4 as libc::c_int || i_mb_type == I_8x8 as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            ctx0 as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
    } else {
        let mut i_pred: libc::c_int = x264_mb_pred_mode16x16_fix[(*h)
            .mb
            .i_intra16x16_pred_mode as usize] as libc::c_int;
        x264_cabac_size_decision_noup(
            cb,
            ctx0 as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        (*cb).f8_bits_encoded += 7 as libc::c_int;
        x264_cabac_size_decision_noup(
            cb,
            ctx1 as libc::c_long,
            ((*h).mb.i_cbp_luma != 0) as libc::c_int as libc::c_long,
        );
        if (*h).mb.i_cbp_chroma == 0 as libc::c_int {
            x264_cabac_size_decision_noup(
                cb,
                ctx2 as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
        } else {
            x264_cabac_size_decision(
                cb,
                ctx2 as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                ctx3 as libc::c_long,
                ((*h).mb.i_cbp_chroma >> 1 as libc::c_int) as libc::c_long,
            );
        }
        x264_cabac_size_decision(
            cb,
            ctx4 as libc::c_long,
            (i_pred >> 1 as libc::c_int) as libc::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            ctx5 as libc::c_long,
            (i_pred & 1 as libc::c_int) as libc::c_long,
        );
    };
}
unsafe extern "C" fn cabac_intra4x4_pred_mode(
    mut cb: *mut x264_cabac_t,
    mut i_pred: libc::c_int,
    mut i_mode: libc::c_int,
) {
    if i_pred == i_mode {
        x264_cabac_size_decision(
            cb,
            68 as libc::c_int as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
    } else {
        x264_cabac_size_decision(
            cb,
            68 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        if i_mode > i_pred {
            i_mode -= 1;
            i_mode;
        }
        x264_cabac_size_decision(
            cb,
            69 as libc::c_int as libc::c_long,
            (i_mode & 0x1 as libc::c_int) as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            69 as libc::c_int as libc::c_long,
            (i_mode >> 1 as libc::c_int & 0x1 as libc::c_int) as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            69 as libc::c_int as libc::c_long,
            (i_mode >> 2 as libc::c_int) as libc::c_long,
        );
    };
}
unsafe extern "C" fn cabac_intra_chroma_pred_mode(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
) {
    let mut i_mode: libc::c_int = x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode
        as usize] as libc::c_int;
    let mut ctx: libc::c_int = 0 as libc::c_int;
    if (*h).mb.i_neighbour & MB_LEFT as libc::c_int as libc::c_uint != 0
        && *((*h).mb.chroma_pred_mode)
            .offset((*h).mb.i_mb_left_xy[0 as libc::c_int as usize] as isize)
            as libc::c_int != 0 as libc::c_int
    {
        ctx += 1;
        ctx;
    }
    if (*h).mb.i_neighbour & MB_TOP as libc::c_int as libc::c_uint != 0
        && *((*h).mb.chroma_pred_mode).offset((*h).mb.i_mb_top_xy as isize)
            as libc::c_int != 0 as libc::c_int
    {
        ctx += 1;
        ctx;
    }
    x264_cabac_size_decision_noup(
        cb,
        (64 as libc::c_int + ctx) as libc::c_long,
        (i_mode > 0 as libc::c_int) as libc::c_int as libc::c_long,
    );
    if i_mode > 0 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            (64 as libc::c_int + 3 as libc::c_int) as libc::c_long,
            (i_mode > 1 as libc::c_int) as libc::c_int as libc::c_long,
        );
        if i_mode > 1 as libc::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (64 as libc::c_int + 3 as libc::c_int) as libc::c_long,
                (i_mode > 2 as libc::c_int) as libc::c_int as libc::c_long,
            );
        }
    }
}
unsafe extern "C" fn cabac_cbp_luma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
    let mut cbp: libc::c_int = (*h).mb.i_cbp_luma;
    let mut cbp_l: libc::c_int = (*h).mb.cache.i_cbp_left;
    let mut cbp_t: libc::c_int = (*h).mb.cache.i_cbp_top;
    x264_cabac_size_decision(
        cb,
        (76 as libc::c_int - (cbp_l >> 1 as libc::c_int & 1 as libc::c_int)
            - (cbp_t >> 1 as libc::c_int & 2 as libc::c_int)) as libc::c_long,
        (cbp >> 0 as libc::c_int & 1 as libc::c_int) as libc::c_long,
    );
    x264_cabac_size_decision(
        cb,
        (76 as libc::c_int - (cbp >> 0 as libc::c_int & 1 as libc::c_int)
            - (cbp_t >> 2 as libc::c_int & 2 as libc::c_int)) as libc::c_long,
        (cbp >> 1 as libc::c_int & 1 as libc::c_int) as libc::c_long,
    );
    x264_cabac_size_decision(
        cb,
        (76 as libc::c_int - (cbp_l >> 3 as libc::c_int & 1 as libc::c_int)
            - (cbp << 1 as libc::c_int & 2 as libc::c_int)) as libc::c_long,
        (cbp >> 2 as libc::c_int & 1 as libc::c_int) as libc::c_long,
    );
    x264_cabac_size_decision_noup(
        cb,
        (76 as libc::c_int - (cbp >> 2 as libc::c_int & 1 as libc::c_int)
            - (cbp >> 0 as libc::c_int & 2 as libc::c_int)) as libc::c_long,
        (cbp >> 3 as libc::c_int & 1 as libc::c_int) as libc::c_long,
    );
}
unsafe extern "C" fn cabac_cbp_chroma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
    let mut cbp_a: libc::c_int = (*h).mb.cache.i_cbp_left & 0x30 as libc::c_int;
    let mut cbp_b: libc::c_int = (*h).mb.cache.i_cbp_top & 0x30 as libc::c_int;
    let mut ctx: libc::c_int = 0 as libc::c_int;
    if cbp_a != 0 && (*h).mb.cache.i_cbp_left != -(1 as libc::c_int) {
        ctx += 1;
        ctx;
    }
    if cbp_b != 0 && (*h).mb.cache.i_cbp_top != -(1 as libc::c_int) {
        ctx += 2 as libc::c_int;
    }
    if (*h).mb.i_cbp_chroma == 0 as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            (77 as libc::c_int + ctx) as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
    } else {
        x264_cabac_size_decision_noup(
            cb,
            (77 as libc::c_int + ctx) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        ctx = 4 as libc::c_int;
        if cbp_a == 0x20 as libc::c_int {
            ctx += 1;
            ctx;
        }
        if cbp_b == 0x20 as libc::c_int {
            ctx += 2 as libc::c_int;
        }
        x264_cabac_size_decision_noup(
            cb,
            (77 as libc::c_int + ctx) as libc::c_long,
            ((*h).mb.i_cbp_chroma >> 1 as libc::c_int) as libc::c_long,
        );
    };
}
unsafe extern "C" fn cabac_qp_delta(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
    let mut i_dqp: libc::c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
    let mut ctx: libc::c_int = 0;
    if (*h).mb.i_type == I_16x16 as libc::c_int
        && *((*h).mb.cbp).offset((*h).mb.i_mb_xy as isize) == 0
        && (*h).mb.i_qp > (*h).mb.i_last_qp
    {
        i_dqp = 0 as libc::c_int;
    }
    ctx = ((*h).mb.i_last_dqp != 0
        && (*((*h).mb.type_0).offset((*h).mb.i_mb_prev_xy as isize) as libc::c_int
            == I_16x16 as libc::c_int
            || *((*h).mb.cbp).offset((*h).mb.i_mb_prev_xy as isize) as libc::c_int
                & 0x3f as libc::c_int != 0)) as libc::c_int;
    if i_dqp != 0 as libc::c_int {
        i_dqp *= 2 as libc::c_int;
        let mut val: libc::c_int = 1 as libc::c_int - i_dqp;
        if val < 0 as libc::c_int {
            val = i_dqp;
        }
        val -= 1;
        val;
        if val
            >= 51 as libc::c_int
                + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
            && val
                != 51 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                    + 1 as libc::c_int
        {
            val = 2 as libc::c_int
                * (51 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int))
                + 1 as libc::c_int - val;
        }
        loop {
            x264_cabac_size_decision(
                cb,
                (60 as libc::c_int + ctx) as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            ctx = 2 as libc::c_int + (ctx >> 1 as libc::c_int);
            val -= 1;
            if !(val != 0) {
                break;
            }
        }
    }
    x264_cabac_size_decision_noup(
        cb,
        (60 as libc::c_int + ctx) as libc::c_long,
        0 as libc::c_int as libc::c_long,
    );
}
#[inline]
unsafe extern "C" fn cabac_subpartition_p(
    mut cb: *mut x264_cabac_t,
    mut i_sub: libc::c_int,
) {
    if i_sub == D_L0_8x8 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            21 as libc::c_int as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        return;
    }
    x264_cabac_size_decision(
        cb,
        21 as libc::c_int as libc::c_long,
        0 as libc::c_int as libc::c_long,
    );
    if i_sub == D_L0_8x4 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            22 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
    } else {
        x264_cabac_size_decision(
            cb,
            22 as libc::c_int as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            23 as libc::c_int as libc::c_long,
            (i_sub == D_L0_4x8 as libc::c_int) as libc::c_int as libc::c_long,
        );
    };
}
#[inline(always)]
unsafe extern "C" fn cabac_subpartition_b(
    mut cb: *mut x264_cabac_t,
    mut i_sub: libc::c_int,
) {
    if i_sub == D_DIRECT_8x8 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            36 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        return;
    }
    x264_cabac_size_decision(
        cb,
        36 as libc::c_int as libc::c_long,
        1 as libc::c_int as libc::c_long,
    );
    if i_sub == D_BI_8x8 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            37 as libc::c_int as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            38 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            39 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            39 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        return;
    }
    x264_cabac_size_decision(
        cb,
        37 as libc::c_int as libc::c_long,
        0 as libc::c_int as libc::c_long,
    );
    x264_cabac_size_decision(
        cb,
        39 as libc::c_int as libc::c_long,
        (i_sub == D_L1_8x8 as libc::c_int) as libc::c_int as libc::c_long,
    );
}
#[inline(always)]
unsafe extern "C" fn cabac_transform_size(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
) {
    let mut ctx: libc::c_int = 399 as libc::c_int
        + (*h).mb.cache.i_neighbour_transform_size;
    x264_cabac_size_decision_noup(
        cb,
        ctx as libc::c_long,
        (*h).mb.b_transform_8x8 as libc::c_long,
    );
}
#[inline(always)]
unsafe extern "C" fn cabac_ref_internal(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_list: libc::c_int,
    mut idx: libc::c_int,
    mut bframe: libc::c_int,
) {
    let i8: libc::c_int = x264_scan8[idx as usize] as libc::c_int;
    let i_refa: libc::c_int = (*h)
        .mb
        .cache
        .ref_0[i_list as usize][(i8 - 1 as libc::c_int) as usize] as libc::c_int;
    let i_refb: libc::c_int = (*h)
        .mb
        .cache
        .ref_0[i_list as usize][(i8 - 8 as libc::c_int) as usize] as libc::c_int;
    let mut ctx: libc::c_int = 0 as libc::c_int;
    if i_refa > 0 as libc::c_int
        && (bframe == 0 || (*h).mb.cache.skip[(i8 - 1 as libc::c_int) as usize] == 0)
    {
        ctx += 1;
        ctx;
    }
    if i_refb > 0 as libc::c_int
        && (bframe == 0 || (*h).mb.cache.skip[(i8 - 8 as libc::c_int) as usize] == 0)
    {
        ctx += 2 as libc::c_int;
    }
    let mut i_ref: libc::c_int = (*h).mb.cache.ref_0[i_list as usize][i8 as usize]
        as libc::c_int;
    while i_ref > 0 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            (54 as libc::c_int + ctx) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        ctx = (ctx >> 2 as libc::c_int) + 4 as libc::c_int;
        i_ref -= 1;
        i_ref;
    }
    x264_cabac_size_decision(
        cb,
        (54 as libc::c_int + ctx) as libc::c_long,
        0 as libc::c_int as libc::c_long,
    );
}
#[inline(never)]
unsafe extern "C" fn cabac_ref_p(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut idx: libc::c_int,
) {
    cabac_ref_internal(h, cb, 0 as libc::c_int, idx, 0 as libc::c_int);
}
#[inline(never)]
unsafe extern "C" fn cabac_ref_b(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_list: libc::c_int,
    mut idx: libc::c_int,
) {
    cabac_ref_internal(h, cb, i_list, idx, 1 as libc::c_int);
}
#[inline(always)]
unsafe extern "C" fn cabac_mvd_cpn(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_list: libc::c_int,
    mut idx: libc::c_int,
    mut l: libc::c_int,
    mut mvd: libc::c_int,
    mut ctx: libc::c_int,
) -> libc::c_int {
    let mut ctxbase: libc::c_int = if l != 0 {
        47 as libc::c_int
    } else {
        40 as libc::c_int
    };
    if mvd == 0 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            (ctxbase + ctx) as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        return 0 as libc::c_int;
    }
    let mut i_abs: libc::c_int = abs(mvd);
    x264_cabac_size_decision(
        cb,
        (ctxbase + ctx) as libc::c_long,
        1 as libc::c_int as libc::c_long,
    );
    if i_abs <= 3 as libc::c_int {
        let mut i: libc::c_int = 1 as libc::c_int;
        while i < i_abs {
            x264_cabac_size_decision(
                cb,
                (ctxbase + i + 2 as libc::c_int) as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            i += 1;
            i;
        }
        x264_cabac_size_decision(
            cb,
            (ctxbase + i_abs + 2 as libc::c_int) as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        (*cb).f8_bits_encoded += 256 as libc::c_int;
    } else {
        x264_cabac_size_decision(
            cb,
            (ctxbase + 3 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (ctxbase + 4 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (ctxbase + 5 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        if i_abs < 9 as libc::c_int {
            (*cb).f8_bits_encoded
                += x264_8_cabac_size_unary[(i_abs - 3 as libc::c_int)
                    as usize][(*cb).state[(ctxbase + 6 as libc::c_int) as usize]
                    as usize] as libc::c_int;
            (*cb)
                .state[(ctxbase + 6 as libc::c_int)
                as usize] = x264_8_cabac_transition_unary[(i_abs - 3 as libc::c_int)
                as usize][(*cb).state[(ctxbase + 6 as libc::c_int) as usize] as usize];
        } else {
            (*cb).f8_bits_encoded
                += cabac_size_5ones[(*cb).state[(ctxbase + 6 as libc::c_int) as usize]
                    as usize] as libc::c_int;
            (*cb)
                .state[(ctxbase + 6 as libc::c_int)
                as usize] = cabac_transition_5ones[(*cb)
                .state[(ctxbase + 6 as libc::c_int) as usize] as usize];
            (*cb).f8_bits_encoded
                += (bs_size_ue_big(
                    (i_abs - 9 as libc::c_int + ((1 as libc::c_int) << 3 as libc::c_int)
                        - 1 as libc::c_int) as libc::c_uint,
                ) - 3 as libc::c_int) << 8 as libc::c_int;
        }
    }
    return if i_abs < 66 as libc::c_int { i_abs } else { 66 as libc::c_int };
}
#[inline(never)]
unsafe extern "C" fn cabac_mvd(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_list: libc::c_int,
    mut idx: libc::c_int,
    mut width: libc::c_int,
) -> uint16_t {
    let mut mvp: [int16_t; 2] = [0; 2];
    let mut mdx: libc::c_int = 0;
    let mut mdy: libc::c_int = 0;
    x264_8_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
    mdx = (*h)
        .mb
        .cache
        .mv[i_list
        as usize][x264_scan8[idx as usize] as usize][0 as libc::c_int as usize]
        as libc::c_int - mvp[0 as libc::c_int as usize] as libc::c_int;
    mdy = (*h)
        .mb
        .cache
        .mv[i_list
        as usize][x264_scan8[idx as usize] as usize][1 as libc::c_int as usize]
        as libc::c_int - mvp[1 as libc::c_int as usize] as libc::c_int;
    let mut amvd: uint16_t = x264_cabac_mvd_sum(
        ((*h)
            .mb
            .cache
            .mvd[i_list
            as usize][(x264_scan8[idx as usize] as libc::c_int - 1 as libc::c_int)
            as usize])
            .as_mut_ptr(),
        ((*h)
            .mb
            .cache
            .mvd[i_list
            as usize][(x264_scan8[idx as usize] as libc::c_int - 8 as libc::c_int)
            as usize])
            .as_mut_ptr(),
    );
    mdx = cabac_mvd_cpn(
        h,
        cb,
        i_list,
        idx,
        0 as libc::c_int,
        mdx,
        amvd as libc::c_int & 0xff as libc::c_int,
    );
    mdy = cabac_mvd_cpn(
        h,
        cb,
        i_list,
        idx,
        1 as libc::c_int,
        mdy,
        amvd as libc::c_int >> 8 as libc::c_int,
    );
    return pack8to16(mdx as uint32_t, mdy as uint32_t) as uint16_t;
}
#[inline]
unsafe extern "C" fn cabac_8x8_mvd(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i: libc::c_int,
) {
    match (*h).mb.i_sub_partition[i as usize] as libc::c_int {
        3 => {
            let mut mvd: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i,
                2 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i) as usize] as libc::c_int,
                block_idx_y[(4 as libc::c_int * i) as usize] as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                mvd,
            );
        }
        1 => {
            let mut mvd_0: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 0 as libc::c_int,
                2 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 0 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 0 as libc::c_int) as usize]
                    as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                mvd_0,
            );
            let mut mvd_1: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 2 as libc::c_int,
                2 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 2 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 2 as libc::c_int) as usize]
                    as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                mvd_1,
            );
        }
        2 => {
            let mut mvd_2: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 0 as libc::c_int,
                1 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 0 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 0 as libc::c_int) as usize]
                    as libc::c_int,
                1 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                mvd_2,
            );
            let mut mvd_3: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 1 as libc::c_int,
                1 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 1 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 1 as libc::c_int) as usize]
                    as libc::c_int,
                1 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                mvd_3,
            );
        }
        0 => {
            let mut mvd_4: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 0 as libc::c_int,
                1 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 0 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 0 as libc::c_int) as usize]
                    as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                mvd_4,
            );
            let mut mvd_5: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 1 as libc::c_int,
                1 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 1 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 1 as libc::c_int) as usize]
                    as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                mvd_5,
            );
            let mut mvd_6: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 2 as libc::c_int,
                1 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 2 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 2 as libc::c_int) as usize]
                    as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                mvd_6,
            );
            let mut mvd_7: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i + 3 as libc::c_int,
                1 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i + 3 as libc::c_int) as usize]
                    as libc::c_int,
                block_idx_y[(4 as libc::c_int * i + 3 as libc::c_int) as usize]
                    as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                mvd_7,
            );
        }
        _ => {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"encoder/cabac.c\0" as *const u8 as *const libc::c_char,
                377 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 50],
                    &[libc::c_char; 50],
                >(b"void cabac_8x8_mvd(x264_t *, x264_cabac_t *, int)\0"))
                    .as_ptr(),
            );
            'c_42361: {
                __assert_fail(
                    b"0\0" as *const u8 as *const libc::c_char,
                    b"encoder/cabac.c\0" as *const u8 as *const libc::c_char,
                    377 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 50],
                        &[libc::c_char; 50],
                    >(b"void cabac_8x8_mvd(x264_t *, x264_cabac_t *, int)\0"))
                        .as_ptr(),
                );
            };
        }
    };
}
#[inline(always)]
unsafe extern "C" fn cabac_mb_header_i(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_mb_type: libc::c_int,
    mut slice_type: libc::c_int,
    mut chroma: libc::c_int,
) {
    if slice_type == SLICE_TYPE_I as libc::c_int {
        let mut ctx: libc::c_int = 0 as libc::c_int;
        if (*h).mb.i_neighbour & MB_LEFT as libc::c_int as libc::c_uint != 0
            && (*h).mb.i_mb_type_left[0 as libc::c_int as usize] != I_4x4 as libc::c_int
        {
            ctx += 1;
            ctx;
        }
        if (*h).mb.i_neighbour & MB_TOP as libc::c_int as libc::c_uint != 0
            && (*h).mb.i_mb_type_top != I_4x4 as libc::c_int
        {
            ctx += 1;
            ctx;
        }
        cabac_mb_type_intra(
            h,
            cb,
            i_mb_type,
            3 as libc::c_int + ctx,
            3 as libc::c_int + 3 as libc::c_int,
            3 as libc::c_int + 4 as libc::c_int,
            3 as libc::c_int + 5 as libc::c_int,
            3 as libc::c_int + 6 as libc::c_int,
            3 as libc::c_int + 7 as libc::c_int,
        );
    } else if slice_type == SLICE_TYPE_P as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            14 as libc::c_int as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        cabac_mb_type_intra(
            h,
            cb,
            i_mb_type,
            17 as libc::c_int + 0 as libc::c_int,
            17 as libc::c_int + 1 as libc::c_int,
            17 as libc::c_int + 2 as libc::c_int,
            17 as libc::c_int + 2 as libc::c_int,
            17 as libc::c_int + 3 as libc::c_int,
            17 as libc::c_int + 3 as libc::c_int,
        );
    } else if slice_type == SLICE_TYPE_B as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            (27 as libc::c_int + 3 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            (27 as libc::c_int + 4 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        cabac_mb_type_intra(
            h,
            cb,
            i_mb_type,
            32 as libc::c_int + 0 as libc::c_int,
            32 as libc::c_int + 1 as libc::c_int,
            32 as libc::c_int + 2 as libc::c_int,
            32 as libc::c_int + 2 as libc::c_int,
            32 as libc::c_int + 3 as libc::c_int,
            32 as libc::c_int + 3 as libc::c_int,
        );
    }
    if i_mb_type == I_PCM as libc::c_int {
        return;
    }
    if i_mb_type != I_16x16 as libc::c_int {
        if (*((*h).pps).as_mut_ptr()).b_transform_8x8_mode != 0 {
            cabac_transform_size(h, cb);
        }
        let mut di: libc::c_int = if (*h).mb.b_transform_8x8 != 0 {
            4 as libc::c_int
        } else {
            1 as libc::c_int
        };
        let mut i: libc::c_int = 0 as libc::c_int;
        while i < 16 as libc::c_int {
            let i_pred: libc::c_int = x264_mb_predict_intra4x4_mode(h, i);
            let i_mode: libc::c_int = x264_mb_pred_mode4x4_fix[((*h)
                .mb
                .cache
                .intra4x4_pred_mode[x264_scan8[i as usize] as usize] as libc::c_int
                + 1 as libc::c_int) as usize] as libc::c_int;
            cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
            i += di;
        }
    }
    if chroma != 0 {
        cabac_intra_chroma_pred_mode(h, cb);
    }
}
#[inline(always)]
unsafe extern "C" fn cabac_mb_header_p(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_mb_type: libc::c_int,
    mut chroma: libc::c_int,
) {
    if i_mb_type == P_L0 as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            14 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        if (*h).mb.i_partition == D_16x16 as libc::c_int {
            x264_cabac_size_decision_noup(
                cb,
                15 as libc::c_int as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                16 as libc::c_int as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
            if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
                cabac_ref_p(h, cb, 0 as libc::c_int);
            }
            let mut mvd: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                0 as libc::c_int,
                4 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[0 as libc::c_int as usize] as libc::c_int,
                block_idx_y[0 as libc::c_int as usize] as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                mvd,
            );
        } else if (*h).mb.i_partition == D_16x8 as libc::c_int {
            x264_cabac_size_decision_noup(
                cb,
                15 as libc::c_int as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                17 as libc::c_int as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
                cabac_ref_p(h, cb, 0 as libc::c_int);
                cabac_ref_p(h, cb, 8 as libc::c_int);
            }
            let mut mvd_0: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                0 as libc::c_int,
                4 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[0 as libc::c_int as usize] as libc::c_int,
                block_idx_y[0 as libc::c_int as usize] as libc::c_int,
                4 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                mvd_0,
            );
            let mut mvd_1: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                8 as libc::c_int,
                4 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[8 as libc::c_int as usize] as libc::c_int,
                block_idx_y[8 as libc::c_int as usize] as libc::c_int,
                4 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                mvd_1,
            );
        } else {
            x264_cabac_size_decision_noup(
                cb,
                15 as libc::c_int as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                17 as libc::c_int as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
            if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
                cabac_ref_p(h, cb, 0 as libc::c_int);
                cabac_ref_p(h, cb, 4 as libc::c_int);
            }
            let mut mvd_2: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                0 as libc::c_int,
                2 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[0 as libc::c_int as usize] as libc::c_int,
                block_idx_y[0 as libc::c_int as usize] as libc::c_int,
                2 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                mvd_2,
            );
            let mut mvd_3: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int,
                2 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[4 as libc::c_int as usize] as libc::c_int,
                block_idx_y[4 as libc::c_int as usize] as libc::c_int,
                2 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                mvd_3,
            );
        }
    } else if i_mb_type == P_8x8 as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            14 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            15 as libc::c_int as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            16 as libc::c_int as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        let mut i: libc::c_int = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            cabac_subpartition_p(cb, (*h).mb.i_sub_partition[i as usize] as libc::c_int);
            i += 1;
            i;
        }
        if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
            cabac_ref_p(h, cb, 0 as libc::c_int);
            cabac_ref_p(h, cb, 4 as libc::c_int);
            cabac_ref_p(h, cb, 8 as libc::c_int);
            cabac_ref_p(h, cb, 12 as libc::c_int);
        }
        let mut i_0: libc::c_int = 0 as libc::c_int;
        while i_0 < 4 as libc::c_int {
            cabac_8x8_mvd(h, cb, i_0);
            i_0 += 1;
            i_0;
        }
    } else {
        cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_P as libc::c_int, chroma);
    };
}
#[inline(always)]
unsafe extern "C" fn cabac_mb_header_b(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i_mb_type: libc::c_int,
    mut chroma: libc::c_int,
) {
    let mut ctx: libc::c_int = 0 as libc::c_int;
    if (*h).mb.i_neighbour & MB_LEFT as libc::c_int as libc::c_uint != 0
        && (*h).mb.i_mb_type_left[0 as libc::c_int as usize] != B_SKIP as libc::c_int
        && (*h).mb.i_mb_type_left[0 as libc::c_int as usize] != B_DIRECT as libc::c_int
    {
        ctx += 1;
        ctx;
    }
    if (*h).mb.i_neighbour & MB_TOP as libc::c_int as libc::c_uint != 0
        && (*h).mb.i_mb_type_top != B_SKIP as libc::c_int
        && (*h).mb.i_mb_type_top != B_DIRECT as libc::c_int
    {
        ctx += 1;
        ctx;
    }
    if i_mb_type == B_DIRECT as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            (27 as libc::c_int + ctx) as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        return;
    }
    x264_cabac_size_decision_noup(
        cb,
        (27 as libc::c_int + ctx) as libc::c_long,
        1 as libc::c_int as libc::c_long,
    );
    if i_mb_type == B_8x8 as libc::c_int {
        x264_cabac_size_decision_noup(
            cb,
            (27 as libc::c_int + 3 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            (27 as libc::c_int + 4 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        let mut i: libc::c_int = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            cabac_subpartition_b(cb, (*h).mb.i_sub_partition[i as usize] as libc::c_int);
            i += 1;
            i;
        }
        if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
            let mut i_0: libc::c_int = 0 as libc::c_int;
            while i_0 < 4 as libc::c_int {
                if x264_mb_partition_listX_table[0 as libc::c_int
                    as usize][(*h).mb.i_sub_partition[i_0 as usize] as usize] != 0
                {
                    cabac_ref_b(h, cb, 0 as libc::c_int, 4 as libc::c_int * i_0);
                }
                i_0 += 1;
                i_0;
            }
        }
        if (*h).mb.pic.i_fref[1 as libc::c_int as usize] > 1 as libc::c_int {
            let mut i_1: libc::c_int = 0 as libc::c_int;
            while i_1 < 4 as libc::c_int {
                if x264_mb_partition_listX_table[1 as libc::c_int
                    as usize][(*h).mb.i_sub_partition[i_1 as usize] as usize] != 0
                {
                    cabac_ref_b(h, cb, 1 as libc::c_int, 4 as libc::c_int * i_1);
                }
                i_1 += 1;
                i_1;
            }
        }
        let mut i_2: libc::c_int = 0 as libc::c_int;
        while i_2 < 4 as libc::c_int {
            if x264_mb_partition_listX_table[0 as libc::c_int
                as usize][(*h).mb.i_sub_partition[i_2 as usize] as usize] != 0
            {
                let mut mvd: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as libc::c_int,
                    4 as libc::c_int * i_2,
                    2 as libc::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as libc::c_int * i_2) as usize] as libc::c_int,
                    block_idx_y[(4 as libc::c_int * i_2) as usize] as libc::c_int,
                    2 as libc::c_int,
                    2 as libc::c_int,
                    0 as libc::c_int,
                    mvd,
                );
            }
            i_2 += 1;
            i_2;
        }
        let mut i_3: libc::c_int = 0 as libc::c_int;
        while i_3 < 4 as libc::c_int {
            if x264_mb_partition_listX_table[1 as libc::c_int
                as usize][(*h).mb.i_sub_partition[i_3 as usize] as usize] != 0
            {
                let mut mvd_0: uint16_t = cabac_mvd(
                    h,
                    cb,
                    1 as libc::c_int,
                    4 as libc::c_int * i_3,
                    2 as libc::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as libc::c_int * i_3) as usize] as libc::c_int,
                    block_idx_y[(4 as libc::c_int * i_3) as usize] as libc::c_int,
                    2 as libc::c_int,
                    2 as libc::c_int,
                    1 as libc::c_int,
                    mvd_0,
                );
            }
            i_3 += 1;
            i_3;
        }
    } else if i_mb_type >= B_L0_L0 as libc::c_int && i_mb_type <= B_BI_BI as libc::c_int
    {
        static mut i_mb_bits: [uint8_t; 27] = [
            0x31 as libc::c_int as uint8_t,
            0x29 as libc::c_int as uint8_t,
            0x4 as libc::c_int as uint8_t,
            0x35 as libc::c_int as uint8_t,
            0x2d as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x43 as libc::c_int as uint8_t,
            0x63 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x3d as libc::c_int as uint8_t,
            0x2f as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x39 as libc::c_int as uint8_t,
            0x25 as libc::c_int as uint8_t,
            0x6 as libc::c_int as uint8_t,
            0x53 as libc::c_int as uint8_t,
            0x73 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x4b as libc::c_int as uint8_t,
            0x6b as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x5b as libc::c_int as uint8_t,
            0x7b as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0x47 as libc::c_int as uint8_t,
            0x67 as libc::c_int as uint8_t,
            0x21 as libc::c_int as uint8_t,
        ];
        let idx: libc::c_int = (i_mb_type - B_L0_L0 as libc::c_int) * 3 as libc::c_int
            + ((*h).mb.i_partition - D_16x8 as libc::c_int);
        let mut bits: libc::c_int = i_mb_bits[idx as usize] as libc::c_int;
        x264_cabac_size_decision_noup(
            cb,
            (27 as libc::c_int + 3 as libc::c_int) as libc::c_long,
            (bits & 1 as libc::c_int) as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (27 as libc::c_int + 5 as libc::c_int - (bits & 1 as libc::c_int))
                as libc::c_long,
            (bits >> 1 as libc::c_int & 1 as libc::c_int) as libc::c_long,
        );
        bits >>= 2 as libc::c_int;
        if bits != 1 as libc::c_int {
            x264_cabac_size_decision(
                cb,
                (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
                (bits & 1 as libc::c_int) as libc::c_long,
            );
            bits >>= 1 as libc::c_int;
            x264_cabac_size_decision(
                cb,
                (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
                (bits & 1 as libc::c_int) as libc::c_long,
            );
            bits >>= 1 as libc::c_int;
            x264_cabac_size_decision(
                cb,
                (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
                (bits & 1 as libc::c_int) as libc::c_long,
            );
            bits >>= 1 as libc::c_int;
            if bits != 1 as libc::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    (27 as libc::c_int + 5 as libc::c_int) as libc::c_long,
                    (bits & 1 as libc::c_int) as libc::c_long,
                );
            }
        }
        let mut b_list: *const [uint8_t; 2] = (x264_mb_type_list_table[i_mb_type
            as usize])
            .as_ptr();
        if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
            if (*b_list.offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                != 0
            {
                cabac_ref_b(h, cb, 0 as libc::c_int, 0 as libc::c_int);
            }
            if (*b_list.offset(0 as libc::c_int as isize))[1 as libc::c_int as usize]
                as libc::c_int != 0 && (*h).mb.i_partition != D_16x16 as libc::c_int
            {
                cabac_ref_b(
                    h,
                    cb,
                    0 as libc::c_int,
                    8 as libc::c_int
                        >> ((*h).mb.i_partition == D_8x16 as libc::c_int) as libc::c_int,
                );
            }
        }
        if (*h).mb.pic.i_fref[1 as libc::c_int as usize] > 1 as libc::c_int {
            if (*b_list.offset(1 as libc::c_int as isize))[0 as libc::c_int as usize]
                != 0
            {
                cabac_ref_b(h, cb, 1 as libc::c_int, 0 as libc::c_int);
            }
            if (*b_list.offset(1 as libc::c_int as isize))[1 as libc::c_int as usize]
                as libc::c_int != 0 && (*h).mb.i_partition != D_16x16 as libc::c_int
            {
                cabac_ref_b(
                    h,
                    cb,
                    1 as libc::c_int,
                    8 as libc::c_int
                        >> ((*h).mb.i_partition == D_8x16 as libc::c_int) as libc::c_int,
                );
            }
        }
        let mut i_list: libc::c_int = 0 as libc::c_int;
        while i_list < 2 as libc::c_int {
            if (*h).mb.i_partition == D_16x16 as libc::c_int {
                if (*b_list.offset(i_list as isize))[0 as libc::c_int as usize] != 0 {
                    let mut mvd_1: uint16_t = cabac_mvd(
                        h,
                        cb,
                        i_list,
                        0 as libc::c_int,
                        4 as libc::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[0 as libc::c_int as usize] as libc::c_int,
                        block_idx_y[0 as libc::c_int as usize] as libc::c_int,
                        4 as libc::c_int,
                        4 as libc::c_int,
                        i_list,
                        mvd_1,
                    );
                }
            } else if (*h).mb.i_partition == D_16x8 as libc::c_int {
                if (*b_list.offset(i_list as isize))[0 as libc::c_int as usize] != 0 {
                    let mut mvd_2: uint16_t = cabac_mvd(
                        h,
                        cb,
                        i_list,
                        0 as libc::c_int,
                        4 as libc::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[0 as libc::c_int as usize] as libc::c_int,
                        block_idx_y[0 as libc::c_int as usize] as libc::c_int,
                        4 as libc::c_int,
                        2 as libc::c_int,
                        i_list,
                        mvd_2,
                    );
                }
                if (*b_list.offset(i_list as isize))[1 as libc::c_int as usize] != 0 {
                    let mut mvd_3: uint16_t = cabac_mvd(
                        h,
                        cb,
                        i_list,
                        8 as libc::c_int,
                        4 as libc::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[8 as libc::c_int as usize] as libc::c_int,
                        block_idx_y[8 as libc::c_int as usize] as libc::c_int,
                        4 as libc::c_int,
                        2 as libc::c_int,
                        i_list,
                        mvd_3,
                    );
                }
            } else {
                if (*b_list.offset(i_list as isize))[0 as libc::c_int as usize] != 0 {
                    let mut mvd_4: uint16_t = cabac_mvd(
                        h,
                        cb,
                        i_list,
                        0 as libc::c_int,
                        2 as libc::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[0 as libc::c_int as usize] as libc::c_int,
                        block_idx_y[0 as libc::c_int as usize] as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        i_list,
                        mvd_4,
                    );
                }
                if (*b_list.offset(i_list as isize))[1 as libc::c_int as usize] != 0 {
                    let mut mvd_5: uint16_t = cabac_mvd(
                        h,
                        cb,
                        i_list,
                        4 as libc::c_int,
                        2 as libc::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[4 as libc::c_int as usize] as libc::c_int,
                        block_idx_y[4 as libc::c_int as usize] as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        i_list,
                        mvd_5,
                    );
                }
            }
            i_list += 1;
            i_list;
        }
    } else {
        cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_B as libc::c_int, chroma);
    };
}
#[inline(always)]
unsafe extern "C" fn cabac_cbf_ctxidxinc(
    mut h: *mut x264_t,
    mut i_cat: libc::c_int,
    mut i_idx: libc::c_int,
    mut b_intra: libc::c_int,
    mut b_dc: libc::c_int,
) -> libc::c_int {
    static mut base_ctx: [uint16_t; 14] = [
        85 as libc::c_int as uint16_t,
        89 as libc::c_int as uint16_t,
        93 as libc::c_int as uint16_t,
        97 as libc::c_int as uint16_t,
        101 as libc::c_int as uint16_t,
        1012 as libc::c_int as uint16_t,
        460 as libc::c_int as uint16_t,
        464 as libc::c_int as uint16_t,
        468 as libc::c_int as uint16_t,
        1016 as libc::c_int as uint16_t,
        472 as libc::c_int as uint16_t,
        476 as libc::c_int as uint16_t,
        480 as libc::c_int as uint16_t,
        1020 as libc::c_int as uint16_t,
    ];
    if b_dc != 0 {
        i_idx -= 48 as libc::c_int;
        if i_cat == DCT_CHROMA_DC as libc::c_int {
            let mut i_nza: libc::c_int = if (*h).mb.cache.i_cbp_left
                != -(1 as libc::c_int)
            {
                (*h).mb.cache.i_cbp_left >> 8 as libc::c_int + i_idx & 1 as libc::c_int
            } else {
                b_intra
            };
            let mut i_nzb: libc::c_int = if (*h).mb.cache.i_cbp_top
                != -(1 as libc::c_int)
            {
                (*h).mb.cache.i_cbp_top >> 8 as libc::c_int + i_idx & 1 as libc::c_int
            } else {
                b_intra
            };
            return base_ctx[i_cat as usize] as libc::c_int + 2 as libc::c_int * i_nzb
                + i_nza;
        } else {
            let mut i_nza_0: libc::c_int = (*h).mb.cache.i_cbp_left
                >> 8 as libc::c_int + i_idx & 1 as libc::c_int;
            let mut i_nzb_0: libc::c_int = (*h).mb.cache.i_cbp_top
                >> 8 as libc::c_int + i_idx & 1 as libc::c_int;
            return base_ctx[i_cat as usize] as libc::c_int + 2 as libc::c_int * i_nzb_0
                + i_nza_0;
        }
    } else {
        let mut i_nza_1: libc::c_int = (*h)
            .mb
            .cache
            .non_zero_count[(x264_scan8[i_idx as usize] as libc::c_int
            - 1 as libc::c_int) as usize] as libc::c_int;
        let mut i_nzb_1: libc::c_int = (*h)
            .mb
            .cache
            .non_zero_count[(x264_scan8[i_idx as usize] as libc::c_int
            - 8 as libc::c_int) as usize] as libc::c_int;
        if 0 != 0 && b_intra == 0 {
            return base_ctx[i_cat as usize] as libc::c_int
                + (2 as libc::c_int * i_nzb_1 + i_nza_1 & 0x7f as libc::c_int)
        } else {
            i_nza_1 &= 0x7f as libc::c_int + (b_intra << 7 as libc::c_int);
            i_nzb_1 &= 0x7f as libc::c_int + (b_intra << 7 as libc::c_int);
            return base_ctx[i_cat as usize] as libc::c_int
                + 2 as libc::c_int * (i_nzb_1 != 0) as libc::c_int
                + (i_nza_1 != 0) as libc::c_int;
        }
    };
}
static mut coeff_abs_level1_ctx: [uint8_t; 8] = [
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    4 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
];
static mut coeff_abs_levelgt1_ctx: [uint8_t; 8] = [
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    6 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    8 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
];
static mut coeff_abs_levelgt1_ctx_chroma_dc: [uint8_t; 8] = [
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    6 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    8 as libc::c_int as uint8_t,
    8 as libc::c_int as uint8_t,
];
static mut coeff_abs_level_transition: [[uint8_t; 8]; 2] = [
    [
        1 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        3 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        5 as libc::c_int as uint8_t,
        6 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
    ],
    [
        4 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        4 as libc::c_int as uint8_t,
        5 as libc::c_int as uint8_t,
        6 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
    ],
];
#[inline(always)]
unsafe extern "C" fn cabac_block_residual_internal(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut ctx_block_cat: libc::c_int,
    mut l: *mut dctcoef,
    mut b_8x8: libc::c_int,
    mut chroma422dc: libc::c_int,
) {
    let mut sig_offset: *const uint8_t = (x264_significant_coeff_flag_offset_8x8[(*h)
        .mb
        .b_interlaced as usize])
        .as_ptr();
    let mut ctx_sig: libc::c_int = x264_significant_coeff_flag_offset[(*h)
        .mb
        .b_interlaced as usize][ctx_block_cat as usize] as libc::c_int;
    let mut ctx_last: libc::c_int = x264_last_coeff_flag_offset[(*h).mb.b_interlaced
        as usize][ctx_block_cat as usize] as libc::c_int;
    let mut ctx_level: libc::c_int = x264_coeff_abs_level_m1_offset[ctx_block_cat
        as usize] as libc::c_int;
    let mut last: libc::c_int = ((*h).quantf.coeff_last[ctx_block_cat as usize])
        .expect("non-null function pointer")(l);
    let mut coeff_abs: libc::c_int = abs(*l.offset(last as isize) as libc::c_int);
    let mut ctx: libc::c_int = coeff_abs_level1_ctx[0 as libc::c_int as usize]
        as libc::c_int + ctx_level;
    let mut node_ctx: libc::c_int = 0;
    let mut levelgt1_ctx: *const uint8_t = if chroma422dc != 0 {
        coeff_abs_levelgt1_ctx_chroma_dc.as_ptr()
    } else {
        coeff_abs_levelgt1_ctx.as_ptr()
    };
    if last
        != (if b_8x8 != 0 {
            63 as libc::c_int
        } else {
            (if chroma422dc != 0 {
                7 as libc::c_int
            } else {
                x264_count_cat_m1[ctx_block_cat as usize] as libc::c_int
            })
        })
    {
        x264_cabac_size_decision(
            cb,
            (ctx_sig
                + (if b_8x8 != 0 {
                    *sig_offset.offset(last as isize) as libc::c_int
                } else {
                    (if chroma422dc != 0 {
                        x264_coeff_flag_offset_chroma_422_dc[last as usize]
                            as libc::c_int
                    } else {
                        last
                    })
                })) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (ctx_last
                + (if b_8x8 != 0 {
                    x264_last_coeff_flag_offset_8x8[last as usize] as libc::c_int
                } else {
                    (if chroma422dc != 0 {
                        x264_coeff_flag_offset_chroma_422_dc[last as usize]
                            as libc::c_int
                    } else {
                        last
                    })
                })) as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
    }
    if coeff_abs > 1 as libc::c_int {
        x264_cabac_size_decision(
            cb,
            ctx as libc::c_long,
            1 as libc::c_int as libc::c_long,
        );
        ctx = *levelgt1_ctx.offset(0 as libc::c_int as isize) as libc::c_int + ctx_level;
        if coeff_abs < 15 as libc::c_int {
            (*cb).f8_bits_encoded
                += x264_8_cabac_size_unary[(coeff_abs - 1 as libc::c_int)
                    as usize][(*cb).state[ctx as usize] as usize] as libc::c_int;
            (*cb)
                .state[ctx
                as usize] = x264_8_cabac_transition_unary[(coeff_abs - 1 as libc::c_int)
                as usize][(*cb).state[ctx as usize] as usize];
        } else {
            (*cb).f8_bits_encoded
                += x264_8_cabac_size_unary[14 as libc::c_int
                    as usize][(*cb).state[ctx as usize] as usize] as libc::c_int;
            (*cb)
                .state[ctx
                as usize] = x264_8_cabac_transition_unary[14 as libc::c_int
                as usize][(*cb).state[ctx as usize] as usize];
            (*cb).f8_bits_encoded
                += (bs_size_ue_big(
                    (coeff_abs - 15 as libc::c_int
                        + ((1 as libc::c_int) << 0 as libc::c_int) - 1 as libc::c_int)
                        as libc::c_uint,
                ) - 0 as libc::c_int) << 8 as libc::c_int;
        }
        node_ctx = coeff_abs_level_transition[1 as libc::c_int
            as usize][0 as libc::c_int as usize] as libc::c_int;
    } else {
        x264_cabac_size_decision(
            cb,
            ctx as libc::c_long,
            0 as libc::c_int as libc::c_long,
        );
        node_ctx = coeff_abs_level_transition[0 as libc::c_int
            as usize][0 as libc::c_int as usize] as libc::c_int;
        (*cb).f8_bits_encoded += 256 as libc::c_int;
    }
    let mut i: libc::c_int = last - 1 as libc::c_int;
    while i >= 0 as libc::c_int {
        if *l.offset(i as isize) != 0 {
            coeff_abs = abs(*l.offset(i as isize) as libc::c_int);
            x264_cabac_size_decision(
                cb,
                (ctx_sig
                    + (if b_8x8 != 0 {
                        *sig_offset.offset(i as isize) as libc::c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                as libc::c_int
                        } else {
                            i
                        })
                    })) as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctx_last
                    + (if b_8x8 != 0 {
                        x264_last_coeff_flag_offset_8x8[i as usize] as libc::c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                as libc::c_int
                        } else {
                            i
                        })
                    })) as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
            ctx = coeff_abs_level1_ctx[node_ctx as usize] as libc::c_int + ctx_level;
            if coeff_abs > 1 as libc::c_int {
                x264_cabac_size_decision(
                    cb,
                    ctx as libc::c_long,
                    1 as libc::c_int as libc::c_long,
                );
                ctx = *levelgt1_ctx.offset(node_ctx as isize) as libc::c_int + ctx_level;
                if coeff_abs < 15 as libc::c_int {
                    (*cb).f8_bits_encoded
                        += x264_8_cabac_size_unary[(coeff_abs - 1 as libc::c_int)
                            as usize][(*cb).state[ctx as usize] as usize] as libc::c_int;
                    (*cb)
                        .state[ctx
                        as usize] = x264_8_cabac_transition_unary[(coeff_abs
                        - 1 as libc::c_int)
                        as usize][(*cb).state[ctx as usize] as usize];
                } else {
                    (*cb).f8_bits_encoded
                        += x264_8_cabac_size_unary[14 as libc::c_int
                            as usize][(*cb).state[ctx as usize] as usize] as libc::c_int;
                    (*cb)
                        .state[ctx
                        as usize] = x264_8_cabac_transition_unary[14 as libc::c_int
                        as usize][(*cb).state[ctx as usize] as usize];
                    (*cb).f8_bits_encoded
                        += (bs_size_ue_big(
                            (coeff_abs - 15 as libc::c_int
                                + ((1 as libc::c_int) << 0 as libc::c_int)
                                - 1 as libc::c_int) as libc::c_uint,
                        ) - 0 as libc::c_int) << 8 as libc::c_int;
                }
                node_ctx = coeff_abs_level_transition[1 as libc::c_int
                    as usize][node_ctx as usize] as libc::c_int;
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctx as libc::c_long,
                    0 as libc::c_int as libc::c_long,
                );
                node_ctx = coeff_abs_level_transition[0 as libc::c_int
                    as usize][node_ctx as usize] as libc::c_int;
                (*cb).f8_bits_encoded += 256 as libc::c_int;
            }
        } else {
            x264_cabac_size_decision(
                cb,
                (ctx_sig
                    + (if b_8x8 != 0 {
                        *sig_offset.offset(i as isize) as libc::c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                as libc::c_int
                        } else {
                            i
                        })
                    })) as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
        }
        i -= 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_cabac_block_residual_8x8_rd_c(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut ctx_block_cat: libc::c_int,
    mut l: *mut dctcoef,
) {
    cabac_block_residual_internal(
        h,
        cb,
        ctx_block_cat,
        l,
        1 as libc::c_int,
        0 as libc::c_int,
    );
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_cabac_block_residual_rd_c(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut ctx_block_cat: libc::c_int,
    mut l: *mut dctcoef,
) {
    cabac_block_residual_internal(
        h,
        cb,
        ctx_block_cat,
        l,
        0 as libc::c_int,
        0 as libc::c_int,
    );
}
#[inline(always)]
unsafe extern "C" fn cabac_block_residual_8x8(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut ctx_block_cat: libc::c_int,
    mut l: *mut dctcoef,
) {
    x264_8_cabac_block_residual_8x8_rd_c(h, cb, ctx_block_cat, l);
}
#[inline(always)]
unsafe extern "C" fn cabac_block_residual(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut ctx_block_cat: libc::c_int,
    mut l: *mut dctcoef,
) {
    x264_8_cabac_block_residual_rd_c(h, cb, ctx_block_cat, l);
}
unsafe extern "C" fn cabac_block_residual_422_dc(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut ctx_block_cat: libc::c_int,
    mut l: *mut dctcoef,
) {
    cabac_block_residual_internal(
        h,
        cb,
        DCT_CHROMA_DC as libc::c_int,
        l,
        0 as libc::c_int,
        1 as libc::c_int,
    );
}
#[inline(always)]
unsafe extern "C" fn macroblock_write_cabac_internal(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut plane_count: libc::c_int,
    mut chroma: libc::c_int,
) {
    let i_mb_type: libc::c_int = (*h).mb.i_type;
    if (*h).sh.i_type == SLICE_TYPE_P as libc::c_int {
        cabac_mb_header_p(h, cb, i_mb_type, chroma);
    } else if (*h).sh.i_type == SLICE_TYPE_B as libc::c_int {
        cabac_mb_header_b(h, cb, i_mb_type, chroma);
    } else {
        cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_I as libc::c_int, chroma);
    }
    if i_mb_type != I_16x16 as libc::c_int {
        cabac_cbp_luma(h, cb);
        if chroma != 0 {
            cabac_cbp_chroma(h, cb);
        }
    }
    if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
        cabac_transform_size(h, cb);
    }
    if (*h).mb.i_cbp_luma != 0 || chroma != 0 && (*h).mb.i_cbp_chroma != 0
        || i_mb_type == I_16x16 as libc::c_int
    {
        let b_intra: libc::c_int = (i_mb_type == I_4x4 as libc::c_int
            || i_mb_type == I_8x8 as libc::c_int || i_mb_type == I_16x16 as libc::c_int
            || i_mb_type == I_PCM as libc::c_int) as libc::c_int;
        cabac_qp_delta(h, cb);
        if i_mb_type == I_16x16 as libc::c_int {
            let mut p: libc::c_int = 0 as libc::c_int;
            while p < plane_count {
                let mut ctxidxinc: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    ctx_cat_plane[DCT_LUMA_DC as libc::c_int as usize][p as usize]
                        as libc::c_int,
                    48 as libc::c_int + p,
                    1 as libc::c_int,
                    1 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(48 as libc::c_int + p) as usize]
                    as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        ctx_cat_plane[DCT_LUMA_DC as libc::c_int as usize][p as usize]
                            as libc::c_int,
                        ((*h).dct.luma16x16_dc[p as usize]).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                if (*h).mb.i_cbp_luma != 0 {
                    let mut i: libc::c_int = p * 16 as libc::c_int;
                    while i < p * 16 as libc::c_int + 16 as libc::c_int {
                        let mut ctxidxinc_0: libc::c_int = cabac_cbf_ctxidxinc(
                            h,
                            ctx_cat_plane[DCT_LUMA_AC as libc::c_int
                                as usize][p as usize] as libc::c_int,
                            i,
                            1 as libc::c_int,
                            0 as libc::c_int,
                        );
                        if (*h).mb.cache.non_zero_count[x264_scan8[i as usize] as usize]
                            != 0
                        {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_0 as libc::c_long,
                                1 as libc::c_int as libc::c_long,
                            );
                            cabac_block_residual(
                                h,
                                cb,
                                ctx_cat_plane[DCT_LUMA_AC as libc::c_int
                                    as usize][p as usize] as libc::c_int,
                                ((*h).dct.luma4x4[i as usize])
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_0 as libc::c_long,
                                0 as libc::c_int as libc::c_long,
                            );
                        }
                        i += 1;
                        i;
                    }
                }
                p += 1;
                p;
            }
        } else if (*h).mb.b_transform_8x8 != 0 {
            if plane_count == 3 as libc::c_int {
                let mut nnzbak: [[uint8_t; 8]; 3] = [[0; 8]; 3];
                if (*h).mb.i_neighbour & MB_LEFT as libc::c_int as libc::c_uint != 0
                    && *((*h).mb.mb_transform_size)
                        .offset((*h).mb.i_mb_left_xy[0 as libc::c_int as usize] as isize)
                        == 0
                    && *((*h).mb.cbp)
                        .offset((*h).mb.i_mb_left_xy[0 as libc::c_int as usize] as isize)
                        as libc::c_int & 0x1000 as libc::c_int == 0
                {
                    nnzbak[0 as libc::c_int
                        as usize][0 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[0 as libc::c_int
                        as usize][1 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[1 as libc::c_int
                        as usize][0 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[1 as libc::c_int
                        as usize][1 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[2 as libc::c_int
                        as usize][0 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[2 as libc::c_int
                        as usize][1 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                }
                if (*h).mb.i_neighbour & MB_LEFT as libc::c_int as libc::c_uint != 0
                    && *((*h).mb.mb_transform_size)
                        .offset((*h).mb.i_mb_left_xy[1 as libc::c_int as usize] as isize)
                        == 0
                    && *((*h).mb.cbp)
                        .offset((*h).mb.i_mb_left_xy[1 as libc::c_int as usize] as isize)
                        as libc::c_int & 0x1000 as libc::c_int == 0
                {
                    nnzbak[0 as libc::c_int
                        as usize][2 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[0 as libc::c_int
                        as usize][3 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[1 as libc::c_int
                        as usize][2 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[1 as libc::c_int
                        as usize][3 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[2 as libc::c_int
                        as usize][2 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                    nnzbak[2 as libc::c_int
                        as usize][3 as libc::c_int
                        as usize] = (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = 0 as libc::c_int as uint8_t;
                }
                if (*h).mb.i_neighbour & MB_TOP as libc::c_int as libc::c_uint != 0
                    && *((*h).mb.mb_transform_size).offset((*h).mb.i_mb_top_xy as isize)
                        == 0
                    && *((*h).mb.cbp).offset((*h).mb.i_mb_top_xy as isize) as libc::c_int
                        & 0x1000 as libc::c_int == 0
                {
                    (*(&mut *(*nnzbak.as_mut_ptr().offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize) as *mut uint8_t
                        as *mut x264_union32_t))
                        .i = (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 0 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                    (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 0 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i = 0 as libc::c_uint;
                    (*(&mut *(*nnzbak.as_mut_ptr().offset(1 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize) as *mut uint8_t
                        as *mut x264_union32_t))
                        .i = (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 1 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                    (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 1 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i = 0 as libc::c_uint;
                    (*(&mut *(*nnzbak.as_mut_ptr().offset(2 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize) as *mut uint8_t
                        as *mut x264_union32_t))
                        .i = (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 2 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                    (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 2 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i = 0 as libc::c_uint;
                }
                let mut p_0: libc::c_int = 0 as libc::c_int;
                while p_0 < 3 as libc::c_int {
                    let mut i_0: libc::c_int = 0 as libc::c_int;
                    let mut msk: libc::c_int = (*h).mb.i_cbp_luma;
                    let mut skip: libc::c_int = 0;
                    while msk != 0
                        && {
                            skip = x264_ctz_4bit(msk as uint32_t);
                            i_0 += skip;
                            msk >>= skip + 1 as libc::c_int;
                            1 as libc::c_int != 0
                        }
                    {
                        let mut ctxidxinc_1: libc::c_int = cabac_cbf_ctxidxinc(
                            h,
                            ctx_cat_plane[DCT_LUMA_8x8 as libc::c_int
                                as usize][p_0 as usize] as libc::c_int,
                            i_0 * 4 as libc::c_int + p_0 * 16 as libc::c_int,
                            b_intra,
                            0 as libc::c_int,
                        );
                        if (*h)
                            .mb
                            .cache
                            .non_zero_count[x264_scan8[(i_0 * 4 as libc::c_int
                            + p_0 * 16 as libc::c_int) as usize] as usize] != 0
                        {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_1 as libc::c_long,
                                1 as libc::c_int as libc::c_long,
                            );
                            cabac_block_residual_8x8(
                                h,
                                cb,
                                ctx_cat_plane[DCT_LUMA_8x8 as libc::c_int
                                    as usize][p_0 as usize] as libc::c_int,
                                ((*h).dct.luma8x8[(i_0 + p_0 * 4 as libc::c_int) as usize])
                                    .as_mut_ptr(),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_1 as libc::c_long,
                                0 as libc::c_int as libc::c_long,
                            );
                        }
                        i_0 += 1;
                        i_0;
                    }
                    p_0 += 1;
                    p_0;
                }
                if (*h).mb.i_neighbour & MB_LEFT as libc::c_int as libc::c_uint != 0
                    && *((*h).mb.mb_transform_size)
                        .offset((*h).mb.i_mb_left_xy[0 as libc::c_int as usize] as isize)
                        == 0
                    && *((*h).mb.cbp)
                        .offset((*h).mb.i_mb_left_xy[0 as libc::c_int as usize] as isize)
                        as libc::c_int & 0x1000 as libc::c_int == 0
                {
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[0 as libc::c_int
                        as usize][0 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[0 as libc::c_int
                        as usize][1 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[1 as libc::c_int
                        as usize][0 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[1 as libc::c_int
                        as usize][1 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 0 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[2 as libc::c_int
                        as usize][0 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 2 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[2 as libc::c_int
                        as usize][1 as libc::c_int as usize];
                }
                if (*h).mb.i_neighbour & MB_LEFT as libc::c_int as libc::c_uint != 0
                    && *((*h).mb.mb_transform_size)
                        .offset((*h).mb.i_mb_left_xy[1 as libc::c_int as usize] as isize)
                        == 0
                    && *((*h).mb.cbp)
                        .offset((*h).mb.i_mb_left_xy[1 as libc::c_int as usize] as isize)
                        as libc::c_int & 0x1000 as libc::c_int == 0
                {
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[0 as libc::c_int
                        as usize][2 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 0 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[0 as libc::c_int
                        as usize][3 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[1 as libc::c_int
                        as usize][2 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 1 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[1 as libc::c_int
                        as usize][3 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 8 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[2 as libc::c_int
                        as usize][2 as libc::c_int as usize];
                    (*h)
                        .mb
                        .cache
                        .non_zero_count[(x264_scan8[(16 as libc::c_int * 2 as libc::c_int
                        + 10 as libc::c_int) as usize] as libc::c_int - 1 as libc::c_int)
                        as usize] = nnzbak[2 as libc::c_int
                        as usize][3 as libc::c_int as usize];
                }
                if (*h).mb.i_neighbour & MB_TOP as libc::c_int as libc::c_uint != 0
                    && *((*h).mb.mb_transform_size).offset((*h).mb.i_mb_top_xy as isize)
                        == 0
                    && *((*h).mb.cbp).offset((*h).mb.i_mb_top_xy as isize) as libc::c_int
                        & 0x1000 as libc::c_int == 0
                {
                    (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 0 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i = (*(&mut *(*nnzbak
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize) as *mut uint8_t
                        as *mut x264_union32_t))
                        .i;
                    (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 1 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i = (*(&mut *(*nnzbak
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize) as *mut uint8_t
                        as *mut x264_union32_t))
                        .i;
                    (*(&mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as libc::c_int * 2 as libc::c_int) as isize)
                                as libc::c_int - 8 as libc::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                        .i = (*(&mut *(*nnzbak
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize) as *mut uint8_t
                        as *mut x264_union32_t))
                        .i;
                }
            } else {
                let mut i_1: libc::c_int = 0 as libc::c_int;
                let mut msk_0: libc::c_int = (*h).mb.i_cbp_luma;
                let mut skip_0: libc::c_int = 0;
                while msk_0 != 0
                    && {
                        skip_0 = x264_ctz_4bit(msk_0 as uint32_t);
                        i_1 += skip_0;
                        msk_0 >>= skip_0 + 1 as libc::c_int;
                        1 as libc::c_int != 0
                    }
                {
                    cabac_block_residual_8x8(
                        h,
                        cb,
                        DCT_LUMA_8x8 as libc::c_int,
                        ((*h).dct.luma8x8[i_1 as usize]).as_mut_ptr(),
                    );
                    i_1 += 1;
                    i_1;
                }
            }
        } else {
            let mut p_1: libc::c_int = 0 as libc::c_int;
            while p_1 < plane_count {
                let mut i8x8: libc::c_int = 0 as libc::c_int;
                let mut msk_1: libc::c_int = (*h).mb.i_cbp_luma;
                let mut skip_1: libc::c_int = 0;
                while msk_1 != 0
                    && {
                        skip_1 = x264_ctz_4bit(msk_1 as uint32_t);
                        i8x8 += skip_1;
                        msk_1 >>= skip_1 + 1 as libc::c_int;
                        1 as libc::c_int != 0
                    }
                {
                    let mut i_2: libc::c_int = 0 as libc::c_int;
                    while i_2 < 4 as libc::c_int {
                        let mut ctxidxinc_2: libc::c_int = cabac_cbf_ctxidxinc(
                            h,
                            ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int
                                as usize][p_1 as usize] as libc::c_int,
                            i_2 + i8x8 * 4 as libc::c_int + p_1 * 16 as libc::c_int,
                            b_intra,
                            0 as libc::c_int,
                        );
                        if (*h)
                            .mb
                            .cache
                            .non_zero_count[x264_scan8[(i_2 + i8x8 * 4 as libc::c_int
                            + p_1 * 16 as libc::c_int) as usize] as usize] != 0
                        {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_2 as libc::c_long,
                                1 as libc::c_int as libc::c_long,
                            );
                            cabac_block_residual(
                                h,
                                cb,
                                ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int
                                    as usize][p_1 as usize] as libc::c_int,
                                ((*h)
                                    .dct
                                    .luma4x4[(i_2 + i8x8 * 4 as libc::c_int
                                    + p_1 * 16 as libc::c_int) as usize])
                                    .as_mut_ptr(),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_2 as libc::c_long,
                                0 as libc::c_int as libc::c_long,
                            );
                        }
                        i_2 += 1;
                        i_2;
                    }
                    i8x8 += 1;
                    i8x8;
                }
                p_1 += 1;
                p_1;
            }
        }
        if chroma != 0 && (*h).mb.i_cbp_chroma != 0 {
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_422 as libc::c_int
            {
                let mut ctxidxinc_3: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as libc::c_int,
                    49 as libc::c_int + 0 as libc::c_int,
                    b_intra,
                    1 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(49 as libc::c_int + 0 as libc::c_int)
                    as usize] as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_3 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as libc::c_int,
                        ((*h).dct.chroma_dc[0 as libc::c_int as usize]).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_3 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                let mut ctxidxinc_4: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as libc::c_int,
                    49 as libc::c_int + 1 as libc::c_int,
                    b_intra,
                    1 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(49 as libc::c_int + 1 as libc::c_int)
                    as usize] as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_4 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as libc::c_int,
                        ((*h).dct.chroma_dc[1 as libc::c_int as usize]).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_4 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
            } else {
                let mut ctxidxinc_5: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as libc::c_int,
                    49 as libc::c_int + 0 as libc::c_int,
                    b_intra,
                    1 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(49 as libc::c_int + 0 as libc::c_int)
                    as usize] as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_5 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as libc::c_int,
                        ((*h).dct.chroma_dc[0 as libc::c_int as usize]).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_5 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                let mut ctxidxinc_6: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as libc::c_int,
                    49 as libc::c_int + 1 as libc::c_int,
                    b_intra,
                    1 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(49 as libc::c_int + 1 as libc::c_int)
                    as usize] as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_6 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as libc::c_int,
                        ((*h).dct.chroma_dc[1 as libc::c_int as usize]).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_6 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
            }
            if (*h).mb.i_cbp_chroma == 2 as libc::c_int {
                let mut step: libc::c_int = (8 as libc::c_int) << (*h).mb.chroma_v_shift;
                let mut i_3: libc::c_int = 16 as libc::c_int;
                while i_3 < 3 as libc::c_int * 16 as libc::c_int {
                    let mut j: libc::c_int = i_3;
                    while j < i_3 + 4 as libc::c_int {
                        let mut ctxidxinc_7: libc::c_int = cabac_cbf_ctxidxinc(
                            h,
                            DCT_CHROMA_AC as libc::c_int,
                            j,
                            b_intra,
                            0 as libc::c_int,
                        );
                        if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize]
                            != 0
                        {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_7 as libc::c_long,
                                1 as libc::c_int as libc::c_long,
                            );
                            cabac_block_residual(
                                h,
                                cb,
                                DCT_CHROMA_AC as libc::c_int,
                                ((*h).dct.luma4x4[j as usize])
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_7 as libc::c_long,
                                0 as libc::c_int as libc::c_long,
                            );
                        }
                        j += 1;
                        j;
                    }
                    i_3 += step;
                }
            }
        }
    }
}
unsafe extern "C" fn macroblock_size_cabac(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
) {
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
        macroblock_write_cabac_internal(h, cb, 3 as libc::c_int, 0 as libc::c_int);
    } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
        macroblock_write_cabac_internal(h, cb, 1 as libc::c_int, 1 as libc::c_int);
    } else {
        macroblock_write_cabac_internal(h, cb, 1 as libc::c_int, 0 as libc::c_int);
    };
}
unsafe extern "C" fn partition_size_cabac(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i8: libc::c_int,
    mut i_pixel: libc::c_int,
) {
    let i_mb_type: libc::c_int = (*h).mb.i_type;
    let mut b_8x16: libc::c_int = ((*h).mb.i_partition == D_8x16 as libc::c_int)
        as libc::c_int;
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    if i_mb_type == P_8x8 as libc::c_int {
        cabac_8x8_mvd(h, cb, i8);
        cabac_subpartition_p(cb, (*h).mb.i_sub_partition[i8 as usize] as libc::c_int);
    } else if i_mb_type == P_L0 as libc::c_int {
        let mut mvd: uint16_t = cabac_mvd(
            h,
            cb,
            0 as libc::c_int,
            4 as libc::c_int * i8,
            4 as libc::c_int >> b_8x16,
        );
        x264_macroblock_cache_mvd(
            h,
            block_idx_x[(4 as libc::c_int * i8) as usize] as libc::c_int,
            block_idx_y[(4 as libc::c_int * i8) as usize] as libc::c_int,
            4 as libc::c_int >> b_8x16,
            (2 as libc::c_int) << b_8x16,
            0 as libc::c_int,
            mvd,
        );
    } else if i_mb_type > B_DIRECT as libc::c_int && i_mb_type < B_8x8 as libc::c_int {
        if x264_mb_type_list_table[i_mb_type
            as usize][0 as libc::c_int as usize][(i8 != 0) as libc::c_int as usize] != 0
        {
            let mut mvd_0: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i8,
                4 as libc::c_int >> b_8x16,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i8) as usize] as libc::c_int,
                block_idx_y[(4 as libc::c_int * i8) as usize] as libc::c_int,
                4 as libc::c_int >> b_8x16,
                (2 as libc::c_int) << b_8x16,
                0 as libc::c_int,
                mvd_0,
            );
        }
        if x264_mb_type_list_table[i_mb_type
            as usize][1 as libc::c_int as usize][(i8 != 0) as libc::c_int as usize] != 0
        {
            let mut mvd_1: uint16_t = cabac_mvd(
                h,
                cb,
                1 as libc::c_int,
                4 as libc::c_int * i8,
                4 as libc::c_int >> b_8x16,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i8) as usize] as libc::c_int,
                block_idx_y[(4 as libc::c_int * i8) as usize] as libc::c_int,
                4 as libc::c_int >> b_8x16,
                (2 as libc::c_int) << b_8x16,
                1 as libc::c_int,
                mvd_1,
            );
        }
    } else {
        if x264_mb_partition_listX_table[0 as libc::c_int
            as usize][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
        {
            let mut mvd_2: uint16_t = cabac_mvd(
                h,
                cb,
                0 as libc::c_int,
                4 as libc::c_int * i8,
                2 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i8) as usize] as libc::c_int,
                block_idx_y[(4 as libc::c_int * i8) as usize] as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                mvd_2,
            );
        }
        if x264_mb_partition_listX_table[1 as libc::c_int
            as usize][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
        {
            let mut mvd_3: uint16_t = cabac_mvd(
                h,
                cb,
                1 as libc::c_int,
                4 as libc::c_int * i8,
                2 as libc::c_int,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as libc::c_int * i8) as usize] as libc::c_int,
                block_idx_y[(4 as libc::c_int * i8) as usize] as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                mvd_3,
            );
        }
    }
    let mut j: libc::c_int = (i_pixel < PIXEL_8x8 as libc::c_int) as libc::c_int;
    while j >= 0 as libc::c_int {
        if (*h).mb.i_cbp_luma & (1 as libc::c_int) << i8 != 0 {
            if (*h).mb.b_transform_8x8 != 0 {
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_444 as libc::c_int
                {
                    let mut p: libc::c_int = 0 as libc::c_int;
                    while p < 3 as libc::c_int {
                        let mut ctxidxinc: libc::c_int = cabac_cbf_ctxidxinc(
                            h,
                            ctx_cat_plane[DCT_LUMA_8x8 as libc::c_int
                                as usize][p as usize] as libc::c_int,
                            i8 * 4 as libc::c_int + p * 16 as libc::c_int,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                        if (*h)
                            .mb
                            .cache
                            .non_zero_count[x264_scan8[(i8 * 4 as libc::c_int
                            + p * 16 as libc::c_int) as usize] as usize] != 0
                        {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc as libc::c_long,
                                1 as libc::c_int as libc::c_long,
                            );
                            cabac_block_residual_8x8(
                                h,
                                cb,
                                ctx_cat_plane[DCT_LUMA_8x8 as libc::c_int
                                    as usize][p as usize] as libc::c_int,
                                ((*h).dct.luma8x8[(i8 + p * 4 as libc::c_int) as usize])
                                    .as_mut_ptr(),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc as libc::c_long,
                                0 as libc::c_int as libc::c_long,
                            );
                        }
                        p += 1;
                        p;
                    }
                } else {
                    cabac_block_residual_8x8(
                        h,
                        cb,
                        DCT_LUMA_8x8 as libc::c_int,
                        ((*h).dct.luma8x8[i8 as usize]).as_mut_ptr(),
                    );
                }
            } else {
                let mut p_0: libc::c_int = 0 as libc::c_int;
                while p_0 < plane_count {
                    let mut i4: libc::c_int = 0 as libc::c_int;
                    while i4 < 4 as libc::c_int {
                        let mut ctxidxinc_0: libc::c_int = cabac_cbf_ctxidxinc(
                            h,
                            ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int
                                as usize][p_0 as usize] as libc::c_int,
                            i4 + i8 * 4 as libc::c_int + p_0 * 16 as libc::c_int,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                        if (*h)
                            .mb
                            .cache
                            .non_zero_count[x264_scan8[(i4 + i8 * 4 as libc::c_int
                            + p_0 * 16 as libc::c_int) as usize] as usize] != 0
                        {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_0 as libc::c_long,
                                1 as libc::c_int as libc::c_long,
                            );
                            cabac_block_residual(
                                h,
                                cb,
                                ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int
                                    as usize][p_0 as usize] as libc::c_int,
                                ((*h)
                                    .dct
                                    .luma4x4[(i4 + i8 * 4 as libc::c_int
                                    + p_0 * 16 as libc::c_int) as usize])
                                    .as_mut_ptr(),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_0 as libc::c_long,
                                0 as libc::c_int as libc::c_long,
                            );
                        }
                        i4 += 1;
                        i4;
                    }
                    p_0 += 1;
                    p_0;
                }
            }
        }
        if (*h).mb.i_cbp_chroma != 0 {
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_422 as libc::c_int
            {
                let mut offset: libc::c_int = 5 as libc::c_int * i8 & 0x9 as libc::c_int;
                let mut ctxidxinc_1: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_AC as libc::c_int,
                    16 as libc::c_int + offset,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(16 as libc::c_int + offset) as usize]
                    as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_1 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(16 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_1 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                let mut ctxidxinc_2: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_AC as libc::c_int,
                    18 as libc::c_int + offset,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(18 as libc::c_int + offset) as usize]
                    as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_2 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(18 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_2 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                let mut ctxidxinc_3: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_AC as libc::c_int,
                    32 as libc::c_int + offset,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(32 as libc::c_int + offset) as usize]
                    as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_3 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(32 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_3 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                let mut ctxidxinc_4: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_AC as libc::c_int,
                    34 as libc::c_int + offset,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(34 as libc::c_int + offset) as usize]
                    as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_4 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(34 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_4 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
            } else {
                let mut ctxidxinc_5: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_AC as libc::c_int,
                    16 as libc::c_int + i8,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(16 as libc::c_int + i8) as usize]
                    as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_5 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(16 as libc::c_int + i8) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_5 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                let mut ctxidxinc_6: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_AC as libc::c_int,
                    32 as libc::c_int + i8,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(32 as libc::c_int + i8) as usize]
                    as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_6 as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(32 as libc::c_int + i8) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_6 as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
            }
        }
        i8 += x264_pixel_size[i_pixel as usize].h as libc::c_int >> 3 as libc::c_int;
        j -= 1;
        j;
    }
}
unsafe extern "C" fn subpartition_size_cabac(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i4: libc::c_int,
    mut i_pixel: libc::c_int,
) {
    let mut b_8x4: libc::c_int = (i_pixel == PIXEL_8x4 as libc::c_int) as libc::c_int;
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    if i_pixel == PIXEL_4x4 as libc::c_int {
        let mut mvd: uint16_t = cabac_mvd(h, cb, 0 as libc::c_int, i4, 1 as libc::c_int);
        x264_macroblock_cache_mvd(
            h,
            block_idx_x[i4 as usize] as libc::c_int,
            block_idx_y[i4 as usize] as libc::c_int,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
            mvd,
        );
    } else {
        let mut mvd_0: uint16_t = cabac_mvd(
            h,
            cb,
            0 as libc::c_int,
            i4,
            1 as libc::c_int + b_8x4,
        );
        x264_macroblock_cache_mvd(
            h,
            block_idx_x[i4 as usize] as libc::c_int,
            block_idx_y[i4 as usize] as libc::c_int,
            1 as libc::c_int + b_8x4,
            2 as libc::c_int - b_8x4,
            0 as libc::c_int,
            mvd_0,
        );
    }
    let mut p: libc::c_int = 0 as libc::c_int;
    while p < plane_count {
        let mut ctxidxinc: libc::c_int = cabac_cbf_ctxidxinc(
            h,
            ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int as usize][p as usize]
                as libc::c_int,
            p * 16 as libc::c_int + i4,
            0 as libc::c_int,
            0 as libc::c_int,
        );
        if (*h)
            .mb
            .cache
            .non_zero_count[x264_scan8[(p * 16 as libc::c_int + i4) as usize] as usize]
            != 0
        {
            x264_cabac_size_decision(
                cb,
                ctxidxinc as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            cabac_block_residual(
                h,
                cb,
                ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int as usize][p as usize]
                    as libc::c_int,
                ((*h).dct.luma4x4[(p * 16 as libc::c_int + i4) as usize]).as_mut_ptr(),
            );
        } else {
            x264_cabac_size_decision(
                cb,
                ctxidxinc as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
        }
        if i_pixel != PIXEL_4x4 as libc::c_int {
            let mut ctxidxinc_0: libc::c_int = cabac_cbf_ctxidxinc(
                h,
                ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int as usize][p as usize]
                    as libc::c_int,
                p * 16 as libc::c_int + i4 + 2 as libc::c_int - b_8x4,
                0 as libc::c_int,
                0 as libc::c_int,
            );
            if (*h)
                .mb
                .cache
                .non_zero_count[x264_scan8[(p * 16 as libc::c_int + i4 + 2 as libc::c_int
                - b_8x4) as usize] as usize] != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_0 as libc::c_long,
                    1 as libc::c_int as libc::c_long,
                );
                cabac_block_residual(
                    h,
                    cb,
                    ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int as usize][p as usize]
                        as libc::c_int,
                    ((*h)
                        .dct
                        .luma4x4[(p * 16 as libc::c_int + i4 + 2 as libc::c_int - b_8x4)
                        as usize])
                        .as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_0 as libc::c_long,
                    0 as libc::c_int as libc::c_long,
                );
            }
        }
        p += 1;
        p;
    }
}
unsafe extern "C" fn partition_i8x8_size_cabac(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i8: libc::c_int,
    mut i_mode: libc::c_int,
) {
    let i_pred: libc::c_int = x264_mb_predict_intra4x4_mode(h, 4 as libc::c_int * i8);
    i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as libc::c_int) as usize]
        as libc::c_int;
    cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
    cabac_cbp_luma(h, cb);
    if (*h).mb.i_cbp_luma & (1 as libc::c_int) << i8 != 0 {
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            let mut p: libc::c_int = 0 as libc::c_int;
            while p < 3 as libc::c_int {
                let mut ctxidxinc: libc::c_int = cabac_cbf_ctxidxinc(
                    h,
                    ctx_cat_plane[DCT_LUMA_8x8 as libc::c_int as usize][p as usize]
                        as libc::c_int,
                    i8 * 4 as libc::c_int + p * 16 as libc::c_int,
                    1 as libc::c_int,
                    0 as libc::c_int,
                );
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(i8 * 4 as libc::c_int
                    + p * 16 as libc::c_int) as usize] as usize] != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as libc::c_long,
                        1 as libc::c_int as libc::c_long,
                    );
                    cabac_block_residual_8x8(
                        h,
                        cb,
                        ctx_cat_plane[DCT_LUMA_8x8 as libc::c_int as usize][p as usize]
                            as libc::c_int,
                        ((*h).dct.luma8x8[(i8 + p * 4 as libc::c_int) as usize])
                            .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as libc::c_long,
                        0 as libc::c_int as libc::c_long,
                    );
                }
                p += 1;
                p;
            }
        } else {
            cabac_block_residual_8x8(
                h,
                cb,
                DCT_LUMA_8x8 as libc::c_int,
                ((*h).dct.luma8x8[i8 as usize]).as_mut_ptr(),
            );
        }
    }
}
unsafe extern "C" fn partition_i4x4_size_cabac(
    mut h: *mut x264_t,
    mut cb: *mut x264_cabac_t,
    mut i4: libc::c_int,
    mut i_mode: libc::c_int,
) {
    let i_pred: libc::c_int = x264_mb_predict_intra4x4_mode(h, i4);
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as libc::c_int) as usize]
        as libc::c_int;
    cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
    let mut p: libc::c_int = 0 as libc::c_int;
    while p < plane_count {
        let mut ctxidxinc: libc::c_int = cabac_cbf_ctxidxinc(
            h,
            ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int as usize][p as usize]
                as libc::c_int,
            i4 + p * 16 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
        if (*h)
            .mb
            .cache
            .non_zero_count[x264_scan8[(i4 + p * 16 as libc::c_int) as usize] as usize]
            != 0
        {
            x264_cabac_size_decision(
                cb,
                ctxidxinc as libc::c_long,
                1 as libc::c_int as libc::c_long,
            );
            cabac_block_residual(
                h,
                cb,
                ctx_cat_plane[DCT_LUMA_4x4 as libc::c_int as usize][p as usize]
                    as libc::c_int,
                ((*h).dct.luma4x4[(i4 + p * 16 as libc::c_int) as usize]).as_mut_ptr(),
            );
        } else {
            x264_cabac_size_decision(
                cb,
                ctxidxinc as libc::c_long,
                0 as libc::c_int as libc::c_long,
            );
        }
        p += 1;
        p;
    }
}
unsafe extern "C" fn chroma_size_cabac(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
    cabac_intra_chroma_pred_mode(h, cb);
    cabac_cbp_chroma(h, cb);
    if (*h).mb.i_cbp_chroma != 0 {
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as libc::c_int {
            let mut ctxidxinc: libc::c_int = cabac_cbf_ctxidxinc(
                h,
                DCT_CHROMA_DC as libc::c_int,
                49 as libc::c_int + 0 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
            );
            if (*h)
                .mb
                .cache
                .non_zero_count[x264_scan8[(49 as libc::c_int + 0 as libc::c_int)
                as usize] as usize] != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as libc::c_long,
                    1 as libc::c_int as libc::c_long,
                );
                cabac_block_residual_422_dc(
                    h,
                    cb,
                    DCT_CHROMA_DC as libc::c_int,
                    ((*h).dct.chroma_dc[0 as libc::c_int as usize]).as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as libc::c_long,
                    0 as libc::c_int as libc::c_long,
                );
            }
            let mut ctxidxinc_0: libc::c_int = cabac_cbf_ctxidxinc(
                h,
                DCT_CHROMA_DC as libc::c_int,
                49 as libc::c_int + 1 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
            );
            if (*h)
                .mb
                .cache
                .non_zero_count[x264_scan8[(49 as libc::c_int + 1 as libc::c_int)
                as usize] as usize] != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_0 as libc::c_long,
                    1 as libc::c_int as libc::c_long,
                );
                cabac_block_residual_422_dc(
                    h,
                    cb,
                    DCT_CHROMA_DC as libc::c_int,
                    ((*h).dct.chroma_dc[1 as libc::c_int as usize]).as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_0 as libc::c_long,
                    0 as libc::c_int as libc::c_long,
                );
            }
        } else {
            let mut ctxidxinc_1: libc::c_int = cabac_cbf_ctxidxinc(
                h,
                DCT_CHROMA_DC as libc::c_int,
                49 as libc::c_int + 0 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
            );
            if (*h)
                .mb
                .cache
                .non_zero_count[x264_scan8[(49 as libc::c_int + 0 as libc::c_int)
                as usize] as usize] != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_1 as libc::c_long,
                    1 as libc::c_int as libc::c_long,
                );
                cabac_block_residual(
                    h,
                    cb,
                    DCT_CHROMA_DC as libc::c_int,
                    ((*h).dct.chroma_dc[0 as libc::c_int as usize]).as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_1 as libc::c_long,
                    0 as libc::c_int as libc::c_long,
                );
            }
            let mut ctxidxinc_2: libc::c_int = cabac_cbf_ctxidxinc(
                h,
                DCT_CHROMA_DC as libc::c_int,
                49 as libc::c_int + 1 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
            );
            if (*h)
                .mb
                .cache
                .non_zero_count[x264_scan8[(49 as libc::c_int + 1 as libc::c_int)
                as usize] as usize] != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_2 as libc::c_long,
                    1 as libc::c_int as libc::c_long,
                );
                cabac_block_residual(
                    h,
                    cb,
                    DCT_CHROMA_DC as libc::c_int,
                    ((*h).dct.chroma_dc[1 as libc::c_int as usize]).as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc_2 as libc::c_long,
                    0 as libc::c_int as libc::c_long,
                );
            }
        }
        if (*h).mb.i_cbp_chroma == 2 as libc::c_int {
            let mut step: libc::c_int = (8 as libc::c_int) << (*h).mb.chroma_v_shift;
            let mut i: libc::c_int = 16 as libc::c_int;
            while i < 3 as libc::c_int * 16 as libc::c_int {
                let mut j: libc::c_int = i;
                while j < i + 4 as libc::c_int {
                    let mut ctxidxinc_3: libc::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as libc::c_int,
                        j,
                        1 as libc::c_int,
                        0 as libc::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize] != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as libc::c_long,
                            1 as libc::c_int as libc::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as libc::c_int,
                            ((*h).dct.luma4x4[j as usize])
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as libc::c_long,
                            0 as libc::c_int as libc::c_long,
                        );
                    }
                    j += 1;
                    j;
                }
                i += step;
            }
        }
    }
}
static mut delta_tfi_divisor: [uint8_t; 10] = [
    0 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    4 as libc::c_int as uint8_t,
    6 as libc::c_int as uint8_t,
];
unsafe extern "C" fn lowres_context_init(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    (*a)
        .i_qp = 12 as libc::c_int
        + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int);
    (*a).i_lambda = x264_lambda_tab[(*a).i_qp as usize] as libc::c_int;
    mb_analyse_load_costs(h, a);
    if (*h).param.analyse.i_subpel_refine > 1 as libc::c_int {
        (*h)
            .mb
            .i_me_method = if (1 as libc::c_int) < (*h).param.analyse.i_me_method {
            1 as libc::c_int
        } else {
            (*h).param.analyse.i_me_method
        };
        (*h).mb.i_subpel_refine = 4 as libc::c_int;
    } else {
        (*h).mb.i_me_method = 0 as libc::c_int;
        (*h).mb.i_subpel_refine = 2 as libc::c_int;
    }
    (*h).mb.b_chroma_me = 0 as libc::c_int;
}
unsafe extern "C" fn weight_get_h264(
    mut weight_nonh264: libc::c_int,
    mut offset: libc::c_int,
    mut w: *mut x264_weight_t,
) {
    (*w).i_offset = offset;
    (*w).i_denom = 7 as libc::c_int;
    (*w).i_scale = weight_nonh264;
    while (*w).i_denom > 0 as libc::c_int && (*w).i_scale > 127 as libc::c_int {
        (*w).i_denom -= 1;
        (*w).i_denom;
        (*w).i_scale >>= 1 as libc::c_int;
    }
    (*w)
        .i_scale = if (*w).i_scale < 127 as libc::c_int {
        (*w).i_scale
    } else {
        127 as libc::c_int
    };
}
#[inline(never)]
unsafe extern "C" fn weight_cost_init_luma(
    mut h: *mut x264_t,
    mut fenc: *mut x264_frame_t,
    mut ref_0: *mut x264_frame_t,
    mut dest: *mut pixel,
) -> *mut pixel {
    let mut ref0_distance: libc::c_int = (*fenc).i_frame - (*ref_0).i_frame
        - 1 as libc::c_int;
    if (*((*fenc).lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
        .offset(0 as libc::c_int as isize))[0 as libc::c_int as usize] as libc::c_int
        != 0x7fff as libc::c_int
    {
        let mut i_stride: libc::c_int = (*fenc).i_stride_lowres;
        let mut i_lines: libc::c_int = (*fenc).i_lines_lowres;
        let mut i_width: libc::c_int = (*fenc).i_width_lowres;
        let mut i_mb_xy: libc::c_int = 0 as libc::c_int;
        let mut p: *mut pixel = dest;
        let mut y: libc::c_int = 0 as libc::c_int;
        while y < i_lines {
            let mut x: libc::c_int = 0 as libc::c_int;
            while x < i_width {
                let mut mvx: libc::c_int = (*((*fenc)
                    .lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
                    .offset(i_mb_xy as isize))[0 as libc::c_int as usize] as libc::c_int;
                let mut mvy: libc::c_int = (*((*fenc)
                    .lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
                    .offset(i_mb_xy as isize))[1 as libc::c_int as usize] as libc::c_int;
                ((*h).mc.mc_luma)
                    .expect(
                        "non-null function pointer",
                    )(
                    p.offset(x as isize),
                    i_stride as intptr_t,
                    ((*ref_0).lowres).as_mut_ptr(),
                    i_stride as intptr_t,
                    mvx + (x << 2 as libc::c_int),
                    mvy + (y << 2 as libc::c_int),
                    8 as libc::c_int,
                    8 as libc::c_int,
                    x264_zero.as_mut_ptr() as *const x264_weight_t,
                );
                x += 8 as libc::c_int;
                i_mb_xy += 1;
                i_mb_xy;
            }
            y += 8 as libc::c_int;
            p = p.offset((i_stride * 8 as libc::c_int) as isize);
        }
        return dest;
    }
    return (*ref_0).lowres[0 as libc::c_int as usize];
}
#[inline(never)]
unsafe extern "C" fn weight_cost_init_chroma(
    mut h: *mut x264_t,
    mut fenc: *mut x264_frame_t,
    mut ref_0: *mut x264_frame_t,
    mut dstu: *mut pixel,
    mut dstv: *mut pixel,
) {
    let mut ref0_distance: libc::c_int = (*fenc).i_frame - (*ref_0).i_frame
        - 1 as libc::c_int;
    let mut i_stride: libc::c_int = (*fenc).i_stride[1 as libc::c_int as usize];
    let mut i_lines: libc::c_int = (*fenc).i_lines[1 as libc::c_int as usize];
    let mut i_width: libc::c_int = (*fenc).i_width[1 as libc::c_int as usize];
    let mut v_shift: libc::c_int = (*h).mb.chroma_v_shift;
    let mut cw: libc::c_int = 8 as libc::c_int * (*h).mb.i_mb_width;
    let mut ch: libc::c_int = 16 as libc::c_int * (*h).mb.i_mb_height >> v_shift;
    let mut height: libc::c_int = 16 as libc::c_int >> v_shift;
    if (*((*fenc).lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
        .offset(0 as libc::c_int as isize))[0 as libc::c_int as usize] as libc::c_int
        != 0x7fff as libc::c_int
    {
        x264_8_frame_expand_border_chroma(h, ref_0, 1 as libc::c_int);
        let mut y: libc::c_int = 0 as libc::c_int;
        let mut mb_xy: libc::c_int = 0 as libc::c_int;
        let mut pel_offset_y: libc::c_int = 0 as libc::c_int;
        while y < i_lines {
            let mut x: libc::c_int = 0 as libc::c_int;
            let mut pel_offset_x: libc::c_int = 0 as libc::c_int;
            while x < i_width {
                let mut pixu: *mut pixel = dstu
                    .offset(pel_offset_y as isize)
                    .offset(pel_offset_x as isize);
                let mut pixv: *mut pixel = dstv
                    .offset(pel_offset_y as isize)
                    .offset(pel_offset_x as isize);
                let mut src1: *mut pixel = ((*ref_0).plane[1 as libc::c_int as usize])
                    .offset(pel_offset_y as isize)
                    .offset((pel_offset_x * 2 as libc::c_int) as isize);
                let mut mvx: libc::c_int = (*((*fenc)
                    .lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
                    .offset(mb_xy as isize))[0 as libc::c_int as usize] as libc::c_int;
                let mut mvy: libc::c_int = (*((*fenc)
                    .lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
                    .offset(mb_xy as isize))[1 as libc::c_int as usize] as libc::c_int;
                ((*h).mc.mc_chroma)
                    .expect(
                        "non-null function pointer",
                    )(
                    pixu,
                    pixv,
                    i_stride as intptr_t,
                    src1,
                    i_stride as intptr_t,
                    mvx,
                    2 as libc::c_int * mvy >> v_shift,
                    8 as libc::c_int,
                    height,
                );
                x += 8 as libc::c_int;
                mb_xy += 1;
                mb_xy;
                pel_offset_x += 8 as libc::c_int;
            }
            y += height;
            pel_offset_y = y * i_stride;
        }
    } else {
        ((*h).mc.plane_copy_deinterleave)
            .expect(
                "non-null function pointer",
            )(
            dstu,
            i_stride as intptr_t,
            dstv,
            i_stride as intptr_t,
            (*ref_0).plane[1 as libc::c_int as usize],
            i_stride as intptr_t,
            cw,
            ch,
        );
    }
    ((*h).mc.plane_copy_deinterleave)
        .expect(
            "non-null function pointer",
        )(
        dstu.offset(i_width as isize),
        i_stride as intptr_t,
        dstv.offset(i_width as isize),
        i_stride as intptr_t,
        (*fenc).plane[1 as libc::c_int as usize],
        i_stride as intptr_t,
        cw,
        ch,
    );
}
#[inline(never)]
unsafe extern "C" fn weight_cost_init_chroma444(
    mut h: *mut x264_t,
    mut fenc: *mut x264_frame_t,
    mut ref_0: *mut x264_frame_t,
    mut dst: *mut pixel,
    mut p: libc::c_int,
) -> *mut pixel {
    let mut ref0_distance: libc::c_int = (*fenc).i_frame - (*ref_0).i_frame
        - 1 as libc::c_int;
    let mut i_stride: libc::c_int = (*fenc).i_stride[p as usize];
    let mut i_lines: libc::c_int = (*fenc).i_lines[p as usize];
    let mut i_width: libc::c_int = (*fenc).i_width[p as usize];
    if (*((*fenc).lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
        .offset(0 as libc::c_int as isize))[0 as libc::c_int as usize] as libc::c_int
        != 0x7fff as libc::c_int
    {
        x264_8_frame_expand_border_chroma(h, ref_0, p);
        let mut y: libc::c_int = 0 as libc::c_int;
        let mut mb_xy: libc::c_int = 0 as libc::c_int;
        let mut pel_offset_y: libc::c_int = 0 as libc::c_int;
        while y < i_lines {
            let mut x: libc::c_int = 0 as libc::c_int;
            let mut pel_offset_x: libc::c_int = 0 as libc::c_int;
            while x < i_width {
                let mut pix: *mut pixel = dst
                    .offset(pel_offset_y as isize)
                    .offset(pel_offset_x as isize);
                let mut src: *mut pixel = ((*ref_0).plane[p as usize])
                    .offset(pel_offset_y as isize)
                    .offset(pel_offset_x as isize);
                let mut mvx: libc::c_int = (*((*fenc)
                    .lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
                    .offset(mb_xy as isize))[0 as libc::c_int as usize] as libc::c_int
                    / 2 as libc::c_int;
                let mut mvy: libc::c_int = (*((*fenc)
                    .lowres_mvs[0 as libc::c_int as usize][ref0_distance as usize])
                    .offset(mb_xy as isize))[1 as libc::c_int as usize] as libc::c_int
                    / 2 as libc::c_int;
                ((*h).mc.copy_16x16_unaligned)
                    .expect(
                        "non-null function pointer",
                    )(
                    pix,
                    i_stride as intptr_t,
                    src.offset(mvx as isize).offset((mvy * i_stride) as isize),
                    i_stride as intptr_t,
                    16 as libc::c_int,
                );
                x += 16 as libc::c_int;
                mb_xy += 1;
                mb_xy;
                pel_offset_x += 16 as libc::c_int;
            }
            y += 16 as libc::c_int;
            pel_offset_y = y * i_stride;
        }
        return dst;
    }
    return (*ref_0).plane[p as usize];
}
unsafe extern "C" fn weight_slice_header_cost(
    mut h: *mut x264_t,
    mut w: *mut x264_weight_t,
    mut b_chroma: libc::c_int,
) -> libc::c_int {
    let mut lambda: libc::c_int = x264_lambda_tab[(12 as libc::c_int
        + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)) as usize]
        as libc::c_int;
    if b_chroma != 0 {
        lambda *= 4 as libc::c_int;
    }
    let mut numslices: libc::c_int = 0;
    if (*h).param.i_slice_count != 0 {
        numslices = (*h).param.i_slice_count;
    } else if (*h).param.i_slice_max_mbs != 0 {
        numslices = ((*h).mb.i_mb_width * (*h).mb.i_mb_height
            + (*h).param.i_slice_max_mbs - 1 as libc::c_int)
            / (*h).param.i_slice_max_mbs;
    } else {
        numslices = 1 as libc::c_int;
    }
    let mut denom_cost: libc::c_int = bs_size_ue(
        (*w.offset(0 as libc::c_int as isize)).i_denom as libc::c_uint,
    ) * (2 as libc::c_int - b_chroma);
    return lambda * numslices
        * (10 as libc::c_int + denom_cost
            + 2 as libc::c_int
                * (bs_size_se((*w.offset(0 as libc::c_int as isize)).i_scale)
                    + bs_size_se((*w.offset(0 as libc::c_int as isize)).i_offset)));
}
#[inline(never)]
unsafe extern "C" fn weight_cost_luma(
    mut h: *mut x264_t,
    mut fenc: *mut x264_frame_t,
    mut src: *mut pixel,
    mut w: *mut x264_weight_t,
) -> libc::c_uint {
    let mut cost: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i_stride: libc::c_int = (*fenc).i_stride_lowres;
    let mut i_lines: libc::c_int = (*fenc).i_lines_lowres;
    let mut i_width: libc::c_int = (*fenc).i_width_lowres;
    let mut fenc_plane: *mut pixel = (*fenc).lowres[0 as libc::c_int as usize];
    let mut buf: [pixel; 64] = [0; 64];
    let mut pixoff: libc::c_int = 0 as libc::c_int;
    let mut i_mb: libc::c_int = 0 as libc::c_int;
    if !w.is_null() {
        let mut y: libc::c_int = 0 as libc::c_int;
        while y < i_lines {
            let mut x: libc::c_int = 0 as libc::c_int;
            while x < i_width {
                (*((*w).weightfn)
                    .offset((8 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    buf.as_mut_ptr(),
                    8 as libc::c_int as intptr_t,
                    &mut *src.offset(pixoff as isize),
                    i_stride as intptr_t,
                    w,
                    8 as libc::c_int,
                );
                let mut cmp: libc::c_int = ((*h)
                    .pixf
                    .mbcmp[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    buf.as_mut_ptr(),
                    8 as libc::c_int as intptr_t,
                    &mut *fenc_plane.offset(pixoff as isize),
                    i_stride as intptr_t,
                );
                cost = cost
                    .wrapping_add(
                        (if cmp
                            < *((*fenc).i_intra_cost).offset(i_mb as isize)
                                as libc::c_int
                        {
                            cmp
                        } else {
                            *((*fenc).i_intra_cost).offset(i_mb as isize) as libc::c_int
                        }) as libc::c_uint,
                    );
                x += 8 as libc::c_int;
                i_mb += 1;
                i_mb;
                pixoff += 8 as libc::c_int;
            }
            y += 8 as libc::c_int;
            pixoff = y * i_stride;
        }
        cost = cost
            .wrapping_add(
                weight_slice_header_cost(h, w, 0 as libc::c_int) as libc::c_uint,
            );
    } else {
        let mut y_0: libc::c_int = 0 as libc::c_int;
        while y_0 < i_lines {
            let mut x_0: libc::c_int = 0 as libc::c_int;
            while x_0 < i_width {
                let mut cmp_0: libc::c_int = ((*h)
                    .pixf
                    .mbcmp[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *src.offset(pixoff as isize),
                    i_stride as intptr_t,
                    &mut *fenc_plane.offset(pixoff as isize),
                    i_stride as intptr_t,
                );
                cost = cost
                    .wrapping_add(
                        (if cmp_0
                            < *((*fenc).i_intra_cost).offset(i_mb as isize)
                                as libc::c_int
                        {
                            cmp_0
                        } else {
                            *((*fenc).i_intra_cost).offset(i_mb as isize) as libc::c_int
                        }) as libc::c_uint,
                    );
                x_0 += 8 as libc::c_int;
                i_mb += 1;
                i_mb;
                pixoff += 8 as libc::c_int;
            }
            y_0 += 8 as libc::c_int;
            pixoff = y_0 * i_stride;
        }
    }
    return cost;
}
#[inline(never)]
unsafe extern "C" fn weight_cost_chroma(
    mut h: *mut x264_t,
    mut fenc: *mut x264_frame_t,
    mut ref_0: *mut pixel,
    mut w: *mut x264_weight_t,
) -> libc::c_uint {
    let mut cost: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i_stride: libc::c_int = (*fenc).i_stride[1 as libc::c_int as usize];
    let mut i_lines: libc::c_int = (*fenc).i_lines[1 as libc::c_int as usize];
    let mut i_width: libc::c_int = (*fenc).i_width[1 as libc::c_int as usize];
    let mut src: *mut pixel = ref_0.offset(i_width as isize);
    let mut buf: [pixel; 128] = [0; 128];
    let mut pixoff: libc::c_int = 0 as libc::c_int;
    let mut height: libc::c_int = 16 as libc::c_int >> (*h).mb.chroma_v_shift;
    if !w.is_null() {
        let mut y: libc::c_int = 0 as libc::c_int;
        while y < i_lines {
            let mut x: libc::c_int = 0 as libc::c_int;
            while x < i_width {
                (*((*w).weightfn)
                    .offset((8 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    buf.as_mut_ptr(),
                    8 as libc::c_int as intptr_t,
                    &mut *ref_0.offset(pixoff as isize),
                    i_stride as intptr_t,
                    w,
                    height,
                );
                cost = cost
                    .wrapping_add(
                        ((*h).pixf.asd8)
                            .expect(
                                "non-null function pointer",
                            )(
                            buf.as_mut_ptr(),
                            8 as libc::c_int as intptr_t,
                            &mut *src.offset(pixoff as isize),
                            i_stride as intptr_t,
                            height,
                        ) as libc::c_uint,
                    );
                x += 8 as libc::c_int;
                pixoff += 8 as libc::c_int;
            }
            y += height;
            pixoff = y * i_stride;
        }
        cost = cost
            .wrapping_add(
                weight_slice_header_cost(h, w, 1 as libc::c_int) as libc::c_uint,
            );
    } else {
        let mut y_0: libc::c_int = 0 as libc::c_int;
        while y_0 < i_lines {
            let mut x_0: libc::c_int = 0 as libc::c_int;
            while x_0 < i_width {
                cost = cost
                    .wrapping_add(
                        ((*h).pixf.asd8)
                            .expect(
                                "non-null function pointer",
                            )(
                            &mut *ref_0.offset(pixoff as isize),
                            i_stride as intptr_t,
                            &mut *src.offset(pixoff as isize),
                            i_stride as intptr_t,
                            height,
                        ) as libc::c_uint,
                    );
                x_0 += 8 as libc::c_int;
                pixoff += 8 as libc::c_int;
            }
            y_0 += height;
            pixoff = y_0 * i_stride;
        }
    }
    return cost;
}
#[inline(never)]
unsafe extern "C" fn weight_cost_chroma444(
    mut h: *mut x264_t,
    mut fenc: *mut x264_frame_t,
    mut ref_0: *mut pixel,
    mut w: *mut x264_weight_t,
    mut p: libc::c_int,
) -> libc::c_uint {
    let mut cost: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i_stride: libc::c_int = (*fenc).i_stride[p as usize];
    let mut i_lines: libc::c_int = (*fenc).i_lines[p as usize];
    let mut i_width: libc::c_int = (*fenc).i_width[p as usize];
    let mut src: *mut pixel = (*fenc).plane[p as usize];
    let mut buf: [pixel; 256] = [0; 256];
    let mut pixoff: libc::c_int = 0 as libc::c_int;
    if !w.is_null() {
        let mut y: libc::c_int = 0 as libc::c_int;
        while y < i_lines {
            let mut x: libc::c_int = 0 as libc::c_int;
            while x < i_width {
                (*((*w).weightfn)
                    .offset((16 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    buf.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    &mut *ref_0.offset(pixoff as isize),
                    i_stride as intptr_t,
                    w,
                    16 as libc::c_int,
                );
                cost = cost
                    .wrapping_add(
                        ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                            .expect(
                                "non-null function pointer",
                            )(
                            buf.as_mut_ptr(),
                            16 as libc::c_int as intptr_t,
                            &mut *src.offset(pixoff as isize),
                            i_stride as intptr_t,
                        ) as libc::c_uint,
                    );
                x += 16 as libc::c_int;
                pixoff += 16 as libc::c_int;
            }
            y += 16 as libc::c_int;
            pixoff = y * i_stride;
        }
        cost = cost
            .wrapping_add(
                weight_slice_header_cost(h, w, 1 as libc::c_int) as libc::c_uint,
            );
    } else {
        let mut y_0: libc::c_int = 0 as libc::c_int;
        while y_0 < i_lines {
            let mut x_0: libc::c_int = 0 as libc::c_int;
            while x_0 < i_width {
                cost = cost
                    .wrapping_add(
                        ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                            .expect(
                                "non-null function pointer",
                            )(
                            &mut *ref_0.offset(pixoff as isize),
                            i_stride as intptr_t,
                            &mut *src.offset(pixoff as isize),
                            i_stride as intptr_t,
                        ) as libc::c_uint,
                    );
                x_0 += 16 as libc::c_int;
                pixoff += 16 as libc::c_int;
            }
            y_0 += 16 as libc::c_int;
            pixoff = y_0 * i_stride;
        }
    }
    return cost;
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_weights_analyse(
    mut h: *mut x264_t,
    mut fenc: *mut x264_frame_t,
    mut ref_0: *mut x264_frame_t,
    mut b_lookahead: libc::c_int,
) {
    let mut i_delta_index: libc::c_int = (*fenc).i_frame - (*ref_0).i_frame
        - 1 as libc::c_int;
    let epsilon: libc::c_float = 1.0f32 / 128.0f32;
    let mut weights: *mut x264_weight_t = ((*fenc).weight[0 as libc::c_int as usize])
        .as_mut_ptr();
    (*weights.offset(0 as libc::c_int as isize)).i_scale = 1 as libc::c_int;
    (*weights.offset(0 as libc::c_int as isize)).i_denom = 0 as libc::c_int;
    (*weights.offset(0 as libc::c_int as isize)).i_offset = 0 as libc::c_int;
    let ref mut fresh2 = (*weights.offset(0 as libc::c_int as isize)).weightfn;
    *fresh2 = 0 as *mut weight_fn_t;
    (*weights.offset(1 as libc::c_int as isize)).i_scale = 1 as libc::c_int;
    (*weights.offset(1 as libc::c_int as isize)).i_denom = 0 as libc::c_int;
    (*weights.offset(1 as libc::c_int as isize)).i_offset = 0 as libc::c_int;
    let ref mut fresh3 = (*weights.offset(1 as libc::c_int as isize)).weightfn;
    *fresh3 = 0 as *mut weight_fn_t;
    (*weights.offset(2 as libc::c_int as isize)).i_scale = 1 as libc::c_int;
    (*weights.offset(2 as libc::c_int as isize)).i_denom = 0 as libc::c_int;
    (*weights.offset(2 as libc::c_int as isize)).i_offset = 0 as libc::c_int;
    let ref mut fresh4 = (*weights.offset(2 as libc::c_int as isize)).weightfn;
    *fresh4 = 0 as *mut weight_fn_t;
    let mut chroma_initted: libc::c_int = 0 as libc::c_int;
    let mut guess_scale: [libc::c_float; 3] = [0.; 3];
    let mut fenc_mean: [libc::c_float; 3] = [0.; 3];
    let mut ref_mean: [libc::c_float; 3] = [0.; 3];
    let mut plane: libc::c_int = 0 as libc::c_int;
    while plane <= 2 as libc::c_int * (b_lookahead == 0) as libc::c_int {
        if plane == 0 || (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            let mut zero_bias: libc::c_int = ((*ref_0).i_pixel_ssd[plane as usize] == 0)
                as libc::c_int;
            let mut fenc_var: libc::c_float = ((*fenc).i_pixel_ssd[plane as usize])
                .wrapping_add(zero_bias as uint64_t) as libc::c_float;
            let mut ref_var: libc::c_float = ((*ref_0).i_pixel_ssd[plane as usize])
                .wrapping_add(zero_bias as uint64_t) as libc::c_float;
            guess_scale[plane as usize] = sqrtf(fenc_var / ref_var);
            fenc_mean[plane
                as usize] = ((*fenc).i_pixel_sum[plane as usize])
                .wrapping_add(zero_bias as uint32_t) as libc::c_float
                / ((*fenc).i_lines[(plane != 0) as libc::c_int as usize]
                    * (*fenc).i_width[(plane != 0) as libc::c_int as usize])
                    as libc::c_float
                / ((1 as libc::c_int) << 8 as libc::c_int - 8 as libc::c_int)
                    as libc::c_float;
            ref_mean[plane
                as usize] = ((*ref_0).i_pixel_sum[plane as usize])
                .wrapping_add(zero_bias as uint32_t) as libc::c_float
                / ((*fenc).i_lines[(plane != 0) as libc::c_int as usize]
                    * (*fenc).i_width[(plane != 0) as libc::c_int as usize])
                    as libc::c_float
                / ((1 as libc::c_int) << 8 as libc::c_int - 8 as libc::c_int)
                    as libc::c_float;
        } else {
            guess_scale[plane as usize] = 1 as libc::c_int as libc::c_float;
            fenc_mean[plane as usize] = 0 as libc::c_int as libc::c_float;
            ref_mean[plane as usize] = 0 as libc::c_int as libc::c_float;
        }
        plane += 1;
        plane;
    }
    let mut chroma_denom: libc::c_int = 7 as libc::c_int;
    if b_lookahead == 0 {
        while chroma_denom > 0 as libc::c_int {
            let mut thresh: libc::c_float = 127.0f32
                / ((1 as libc::c_int) << chroma_denom) as libc::c_float;
            if guess_scale[1 as libc::c_int as usize] < thresh
                && guess_scale[2 as libc::c_int as usize] < thresh
            {
                break;
            }
            chroma_denom -= 1;
            chroma_denom;
        }
    }
    let mut plane_0: libc::c_int = 0 as libc::c_int;
    while plane_0
        < (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            3 as libc::c_int
        } else {
            1 as libc::c_int
        })
        && !(plane_0 != 0
            && (((*weights.offset(0 as libc::c_int as isize)).weightfn).is_null()
                || b_lookahead != 0))
    {
        let mut minoff: libc::c_int = 0;
        let mut minscale: libc::c_int = 0;
        let mut mindenom: libc::c_int = 0;
        let mut minscore: libc::c_uint = 0;
        let mut origscore: libc::c_uint = 0;
        let mut found: libc::c_int = 0;
        if fabsf(ref_mean[plane_0 as usize] - fenc_mean[plane_0 as usize]) < 0.5f32
            && fabsf(1.0f32 - guess_scale[plane_0 as usize]) < epsilon
        {
            (*weights.offset(plane_0 as isize)).i_scale = 1 as libc::c_int;
            (*weights.offset(plane_0 as isize)).i_denom = 0 as libc::c_int;
            (*weights.offset(plane_0 as isize)).i_offset = 0 as libc::c_int;
            let ref mut fresh5 = (*weights.offset(plane_0 as isize)).weightfn;
            *fresh5 = 0 as *mut weight_fn_t;
        } else {
            if plane_0 != 0 {
                (*weights.offset(plane_0 as isize)).i_denom = chroma_denom;
                (*weights.offset(plane_0 as isize))
                    .i_scale = x264_clip3(
                    round(
                        (guess_scale[plane_0 as usize]
                            * ((1 as libc::c_int) << chroma_denom) as libc::c_float)
                            as libc::c_double,
                    ) as libc::c_int,
                    0 as libc::c_int,
                    255 as libc::c_int,
                );
                if (*weights.offset(plane_0 as isize)).i_scale > 127 as libc::c_int {
                    let ref mut fresh6 = (*weights.offset(2 as libc::c_int as isize))
                        .weightfn;
                    *fresh6 = 0 as *mut weight_fn_t;
                    let ref mut fresh7 = (*weights.offset(1 as libc::c_int as isize))
                        .weightfn;
                    *fresh7 = *fresh6;
                    break;
                }
            } else {
                weight_get_h264(
                    round(
                        (guess_scale[plane_0 as usize]
                            * 128 as libc::c_int as libc::c_float) as libc::c_double,
                    ) as libc::c_int,
                    0 as libc::c_int,
                    &mut *weights.offset(plane_0 as isize),
                );
            }
            found = 0 as libc::c_int;
            mindenom = (*weights.offset(plane_0 as isize)).i_denom;
            minscale = (*weights.offset(plane_0 as isize)).i_scale;
            minoff = 0 as libc::c_int;
            let mut mcbuf: *mut pixel = 0 as *mut pixel;
            if plane_0 == 0 {
                if (*fenc).b_intra_calculated == 0 {
                    let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
                        i_lambda: 0,
                        i_lambda2: 0,
                        i_qp: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        p_cost_ref: [0 as *mut uint16_t; 2],
                        i_mbrd: 0,
                        b_fast_intra: 0,
                        b_force_intra: 0,
                        b_avoid_topright: 0,
                        b_try_skip: 0,
                        i_satd_i16x16: 0,
                        i_satd_i16x16_dir: [0; 7],
                        i_predict16x16: 0,
                        i_satd_i8x8: 0,
                        i_cbp_i8x8_luma: 0,
                        i_satd_i8x8_dir: [[0; 16]; 4],
                        i_predict8x8: [0; 4],
                        i_satd_i4x4: 0,
                        i_predict4x4: [0; 16],
                        i_satd_pcm: 0,
                        i_satd_chroma: 0,
                        i_satd_chroma_dir: [0; 7],
                        i_predict8x8chroma: 0,
                        l0: x264_mb_analysis_list_t {
                            me16x16: x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            },
                            bi16x16: x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            },
                            me8x8: [x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 4],
                            me4x4: [[x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 4]; 4],
                            me8x4: [[x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2]; 4],
                            me4x8: [[x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2]; 4],
                            me16x8: [x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2],
                            me8x16: [x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2],
                            i_rd16x16: 0,
                            i_cost8x8: 0,
                            i_cost4x4: [0; 4],
                            i_cost8x4: [0; 4],
                            i_cost4x8: [0; 4],
                            i_cost16x8: 0,
                            i_cost8x16: 0,
                            mvc: [[[0; 2]; 6]; 32],
                        },
                        l1: x264_mb_analysis_list_t {
                            me16x16: x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            },
                            bi16x16: x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            },
                            me8x8: [x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 4],
                            me4x4: [[x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 4]; 4],
                            me8x4: [[x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2]; 4],
                            me4x8: [[x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2]; 4],
                            me16x8: [x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2],
                            me8x16: [x264_me_t {
                                i_pixel: 0,
                                p_cost_mv: 0 as *mut uint16_t,
                                i_ref_cost: 0,
                                i_ref: 0,
                                weight: 0 as *const x264_weight_t,
                                p_fref: [0 as *mut pixel; 12],
                                p_fref_w: 0 as *mut pixel,
                                p_fenc: [0 as *mut pixel; 3],
                                integral: 0 as *mut uint16_t,
                                i_stride: [0; 3],
                                mvp: [0; 2],
                                cost_mv: 0,
                                cost: 0,
                                mv: [0; 2],
                            }; 2],
                            i_rd16x16: 0,
                            i_cost8x8: 0,
                            i_cost4x4: [0; 4],
                            i_cost8x4: [0; 4],
                            i_cost4x8: [0; 4],
                            i_cost16x8: 0,
                            i_cost8x16: 0,
                            mvc: [[[0; 2]; 6]; 32],
                        },
                        i_cost16x16bi: 0,
                        i_cost16x16direct: 0,
                        i_cost8x8bi: 0,
                        i_cost8x8direct: [0; 4],
                        i_satd8x8: [[0; 4]; 3],
                        i_cost_est16x8: [0; 2],
                        i_cost_est8x16: [0; 2],
                        i_cost16x8bi: 0,
                        i_cost8x16bi: 0,
                        i_rd16x16bi: 0,
                        i_rd16x16direct: 0,
                        i_rd16x8bi: 0,
                        i_rd8x16bi: 0,
                        i_rd8x8bi: 0,
                        i_mb_partition16x8: [0; 2],
                        i_mb_partition8x16: [0; 2],
                        i_mb_type16x8: 0,
                        i_mb_type8x16: 0,
                        b_direct_available: 0,
                        b_early_terminate: 0,
                    };
                    lowres_context_init(h, &mut a);
                    slicetype_frame_cost(
                        h,
                        &mut a,
                        &mut fenc,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
                mcbuf = weight_cost_init_luma(
                    h,
                    fenc,
                    ref_0,
                    (*h).mb.p_weight_buf[0 as libc::c_int as usize],
                );
                minscore = weight_cost_luma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                origscore = minscore;
            } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as libc::c_int
            {
                mcbuf = weight_cost_init_chroma444(
                    h,
                    fenc,
                    ref_0,
                    (*h).mb.p_weight_buf[0 as libc::c_int as usize],
                    plane_0,
                );
                minscore = weight_cost_chroma444(
                    h,
                    fenc,
                    mcbuf,
                    0 as *mut x264_weight_t,
                    plane_0,
                );
                origscore = minscore;
            } else {
                let mut dstu: *mut pixel = (*h)
                    .mb
                    .p_weight_buf[0 as libc::c_int as usize];
                let mut dstv: *mut pixel = ((*h)
                    .mb
                    .p_weight_buf[0 as libc::c_int as usize])
                    .offset(
                        ((*fenc).i_stride[1 as libc::c_int as usize]
                            * (*fenc).i_lines[1 as libc::c_int as usize]) as isize,
                    );
                let fresh8 = chroma_initted;
                chroma_initted = chroma_initted + 1;
                if fresh8 == 0 {
                    weight_cost_init_chroma(h, fenc, ref_0, dstu, dstv);
                }
                mcbuf = if plane_0 == 1 as libc::c_int { dstu } else { dstv };
                minscore = weight_cost_chroma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                origscore = minscore;
            }
            if !(minscore == 0) {
                static mut weight_check_distance: [[uint8_t; 2]; 12] = [
                    [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
                    [0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t],
                    [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [0 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [2 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [2 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t],
                    [4 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t],
                ];
                let mut scale_dist: libc::c_int = if b_lookahead != 0 {
                    0 as libc::c_int
                } else {
                    weight_check_distance[(*h).param.analyse.i_subpel_refine
                        as usize][0 as libc::c_int as usize] as libc::c_int
                };
                let mut offset_dist: libc::c_int = if b_lookahead != 0 {
                    0 as libc::c_int
                } else {
                    weight_check_distance[(*h).param.analyse.i_subpel_refine
                        as usize][1 as libc::c_int as usize] as libc::c_int
                };
                let mut start_scale: libc::c_int = x264_clip3(
                    minscale - scale_dist,
                    0 as libc::c_int,
                    127 as libc::c_int,
                );
                let mut end_scale: libc::c_int = x264_clip3(
                    minscale + scale_dist,
                    0 as libc::c_int,
                    127 as libc::c_int,
                );
                let mut i_scale: libc::c_int = start_scale;
                while i_scale <= end_scale {
                    let mut cur_scale: libc::c_int = i_scale;
                    let mut cur_offset: libc::c_int = (fenc_mean[plane_0 as usize]
                        - ref_mean[plane_0 as usize] * cur_scale as libc::c_float
                            / ((1 as libc::c_int) << mindenom) as libc::c_float
                        + 0.5f32 * b_lookahead as libc::c_float) as libc::c_int;
                    if cur_offset < -(128 as libc::c_int)
                        || cur_offset > 127 as libc::c_int
                    {
                        cur_offset = x264_clip3(
                            cur_offset,
                            -(128 as libc::c_int),
                            127 as libc::c_int,
                        );
                        cur_scale = x264_clip3f(
                            (((1 as libc::c_int) << mindenom) as libc::c_float
                                * (fenc_mean[plane_0 as usize]
                                    - cur_offset as libc::c_float) / ref_mean[plane_0 as usize]
                                + 0.5f32) as libc::c_double,
                            0 as libc::c_int as libc::c_double,
                            127 as libc::c_int as libc::c_double,
                        ) as libc::c_int;
                    }
                    let mut start_offset: libc::c_int = x264_clip3(
                        cur_offset - offset_dist,
                        -(128 as libc::c_int),
                        127 as libc::c_int,
                    );
                    let mut end_offset: libc::c_int = x264_clip3(
                        cur_offset + offset_dist,
                        -(128 as libc::c_int),
                        127 as libc::c_int,
                    );
                    let mut i_off: libc::c_int = start_offset;
                    while i_off <= end_offset {
                        (*weights.offset(plane_0 as isize)).i_scale = cur_scale;
                        (*weights.offset(plane_0 as isize)).i_denom = mindenom;
                        (*weights.offset(plane_0 as isize)).i_offset = i_off;
                        ((*h).mc.weight_cache)
                            .expect(
                                "non-null function pointer",
                            )(h, &mut *weights.offset(plane_0 as isize));
                        let mut s: libc::c_uint = 0;
                        if plane_0 != 0 {
                            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                                == CHROMA_444 as libc::c_int
                            {
                                s = weight_cost_chroma444(
                                    h,
                                    fenc,
                                    mcbuf,
                                    &mut *weights.offset(plane_0 as isize),
                                    plane_0,
                                );
                            } else {
                                s = weight_cost_chroma(
                                    h,
                                    fenc,
                                    mcbuf,
                                    &mut *weights.offset(plane_0 as isize),
                                );
                            }
                        } else {
                            s = weight_cost_luma(
                                h,
                                fenc,
                                mcbuf,
                                &mut *weights.offset(plane_0 as isize),
                            );
                        }
                        if s < minscore {
                            minscore = s;
                            minscale = cur_scale;
                            minoff = i_off;
                            found = 1 as libc::c_int;
                        }
                        if minoff == start_offset && i_off != start_offset {
                            break;
                        }
                        i_off += 1;
                        i_off;
                    }
                    i_scale += 1;
                    i_scale;
                }
                if plane_0 == 0 {
                    while mindenom > 0 as libc::c_int && minscale & 1 as libc::c_int == 0
                    {
                        mindenom -= 1;
                        mindenom;
                        minscale >>= 1 as libc::c_int;
                    }
                }
                if found == 0
                    || minscale == (1 as libc::c_int) << mindenom
                        && minoff == 0 as libc::c_int
                    || minscore as libc::c_float / origscore as libc::c_float > 0.998f32
                {
                    (*weights.offset(plane_0 as isize)).i_scale = 1 as libc::c_int;
                    (*weights.offset(plane_0 as isize)).i_denom = 0 as libc::c_int;
                    (*weights.offset(plane_0 as isize)).i_offset = 0 as libc::c_int;
                    let ref mut fresh10 = (*weights.offset(plane_0 as isize)).weightfn;
                    *fresh10 = 0 as *mut weight_fn_t;
                } else {
                    (*weights.offset(plane_0 as isize)).i_scale = minscale;
                    (*weights.offset(plane_0 as isize)).i_denom = mindenom;
                    (*weights.offset(plane_0 as isize)).i_offset = minoff;
                    ((*h).mc.weight_cache)
                        .expect(
                            "non-null function pointer",
                        )(h, &mut *weights.offset(plane_0 as isize));
                    if (*h).param.analyse.i_weighted_pred == -(1 as libc::c_int)
                        && !((*weights.offset(0 as libc::c_int as isize)).weightfn)
                            .is_null() && plane_0 == 0
                    {
                        (*fenc)
                            .f_weighted_cost_delta[i_delta_index
                            as usize] = minscore as libc::c_float
                            / origscore as libc::c_float;
                    }
                }
            }
        }
        plane_0 += 1;
        plane_0;
    }
    if !((*weights.offset(1 as libc::c_int as isize)).weightfn).is_null()
        || !((*weights.offset(2 as libc::c_int as isize)).weightfn).is_null()
    {
        let mut denom: libc::c_int = if !((*weights.offset(1 as libc::c_int as isize))
            .weightfn)
            .is_null()
        {
            (*weights.offset(1 as libc::c_int as isize)).i_denom
        } else {
            (*weights.offset(2 as libc::c_int as isize)).i_denom
        };
        let mut both_weighted: libc::c_int = (!((*weights
            .offset(1 as libc::c_int as isize))
            .weightfn)
            .is_null()
            && !((*weights.offset(2 as libc::c_int as isize)).weightfn).is_null())
            as libc::c_int;
        while both_weighted == 0 && denom == 7 as libc::c_int
            || denom > 0 as libc::c_int
                && !(!((*weights.offset(1 as libc::c_int as isize)).weightfn).is_null()
                    && (*weights.offset(1 as libc::c_int as isize)).i_scale
                        & 1 as libc::c_int != 0)
                && !(!((*weights.offset(2 as libc::c_int as isize)).weightfn).is_null()
                    && (*weights.offset(2 as libc::c_int as isize)).i_scale
                        & 1 as libc::c_int != 0)
        {
            denom -= 1;
            denom;
            let mut i: libc::c_int = 1 as libc::c_int;
            while i <= 2 as libc::c_int {
                if !((*weights.offset(i as isize)).weightfn).is_null() {
                    (*weights.offset(i as isize)).i_scale >>= 1 as libc::c_int;
                    (*weights.offset(i as isize)).i_denom = denom;
                }
                i += 1;
                i;
            }
        }
    }
    let mut i_0: libc::c_int = 1 as libc::c_int;
    while i_0 <= 2 as libc::c_int {
        if !((*weights.offset(i_0 as isize)).weightfn).is_null() {
            ((*h).mc.weight_cache)
                .expect(
                    "non-null function pointer",
                )(h, &mut *weights.offset(i_0 as isize));
        }
        i_0 += 1;
        i_0;
    }
    if !((*weights.offset(0 as libc::c_int as isize)).weightfn).is_null()
        && b_lookahead != 0
    {
        let mut src: *mut pixel = (*ref_0).buffer_lowres;
        let mut dst: *mut pixel = (*h).mb.p_weight_buf[0 as libc::c_int as usize];
        let mut width: libc::c_int = (*ref_0).i_width_lowres
            + ((if 32 as libc::c_int
                > 64 as libc::c_int
                    / ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int
            {
                32 as libc::c_int
            } else {
                64 as libc::c_int
                    / ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int
            }) + 32 as libc::c_int);
        let mut height: libc::c_int = (*ref_0).i_lines_lowres
            + 32 as libc::c_int * 2 as libc::c_int;
        x264_8_weight_scale_plane(
            h,
            dst,
            (*ref_0).i_stride_lowres as intptr_t,
            src,
            (*ref_0).i_stride_lowres as intptr_t,
            width,
            height,
            &mut *weights.offset(0 as libc::c_int as isize),
        );
        (*fenc)
            .weighted[0 as libc::c_int
            as usize] = ((*h).mb.p_weight_buf[0 as libc::c_int as usize])
            .offset(
                (if 32 as libc::c_int
                    > 64 as libc::c_int
                        / ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int
                {
                    32 as libc::c_int
                } else {
                    64 as libc::c_int
                        / ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int
                }) as isize,
            )
            .offset(((*ref_0).i_stride_lowres * 32 as libc::c_int) as isize);
    }
}
unsafe extern "C" fn slicetype_mb_cost(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut p0: libc::c_int,
    mut p1: libc::c_int,
    mut b: libc::c_int,
    mut dist_scale_factor: libc::c_int,
    mut do_search: *mut libc::c_int,
    mut w: *const x264_weight_t,
    mut output_inter: *mut libc::c_int,
    mut output_intra: *mut libc::c_int,
) {
    let mut mv_range: libc::c_int = 0;
    let mut fref0: *mut x264_frame_t = *frames.offset(p0 as isize);
    let mut fref1: *mut x264_frame_t = *frames.offset(p1 as isize);
    let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
    let b_bidir: libc::c_int = (b < p1) as libc::c_int;
    let i_mb_x: libc::c_int = (*h).mb.i_mb_x;
    let i_mb_y: libc::c_int = (*h).mb.i_mb_y;
    let i_mb_stride: libc::c_int = (*h).mb.i_mb_width;
    let i_mb_xy: libc::c_int = i_mb_x + i_mb_y * i_mb_stride;
    let i_stride: libc::c_int = (*fenc).i_stride_lowres;
    let i_pel_offset: libc::c_int = 8 as libc::c_int * (i_mb_x + i_mb_y * i_stride);
    let i_bipred_weight: libc::c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
        64 as libc::c_int - (dist_scale_factor >> 2 as libc::c_int)
    } else {
        32 as libc::c_int
    };
    let mut fenc_mvs: [*mut [int16_t; 2]; 2] = [
        if b != p0 {
            &mut *(*(*((*fenc).lowres_mvs)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset((b - p0 - 1 as libc::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
        } else {
            0 as *mut [int16_t; 2]
        },
        if b != p1 {
            &mut *(*(*((*fenc).lowres_mvs)
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .as_mut_ptr()
                .offset((p1 - b - 1 as libc::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
        } else {
            0 as *mut [int16_t; 2]
        },
    ];
    let mut fenc_costs: [*mut libc::c_int; 2] = [
        if b != p0 {
            &mut *(*(*((*fenc).lowres_mv_costs)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset((b - p0 - 1 as libc::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut libc::c_int
        } else {
            0 as *mut libc::c_int
        },
        if b != p1 {
            &mut *(*(*((*fenc).lowres_mv_costs)
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .as_mut_ptr()
                .offset((p1 - b - 1 as libc::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut libc::c_int
        } else {
            0 as *mut libc::c_int
        },
    ];
    let mut b_frame_score_mb: libc::c_int = (i_mb_x > 0 as libc::c_int
        && i_mb_x < (*h).mb.i_mb_width - 1 as libc::c_int && i_mb_y > 0 as libc::c_int
        && i_mb_y < (*h).mb.i_mb_height - 1 as libc::c_int
        || (*h).mb.i_mb_width <= 2 as libc::c_int
        || (*h).mb.i_mb_height <= 2 as libc::c_int) as libc::c_int;
    let mut pix1: [pixel; 288] = [0; 288];
    let mut pix2: *mut pixel = pix1.as_mut_ptr().offset(8 as libc::c_int as isize);
    let mut m: [x264_me_t; 2] = [x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    }; 2];
    let mut i_bcost: libc::c_int = (1 as libc::c_int) << 28 as libc::c_int;
    let mut list_used: libc::c_int = 0 as libc::c_int;
    let mut lowres_penalty: libc::c_int = 4 as libc::c_int;
    (*h).mb.pic.p_fenc[0 as libc::c_int as usize] = ((*h).mb.pic.fenc_buf).as_mut_ptr();
    ((*h).mc.copy[PIXEL_8x8 as libc::c_int as usize])
        .expect(
            "non-null function pointer",
        )(
        (*h).mb.pic.p_fenc[0 as libc::c_int as usize],
        16 as libc::c_int as intptr_t,
        &mut *(*((*fenc).lowres).as_mut_ptr().offset(0 as libc::c_int as isize))
            .offset(i_pel_offset as isize),
        i_stride as intptr_t,
        8 as libc::c_int,
    );
    if !(p0 == p1) {
        mv_range = 2 as libc::c_int * (*h).param.analyse.i_mv_range;
        (*h)
            .mb
            .mv_min_spel[0 as libc::c_int
            as usize] = if 4 as libc::c_int
            * (-(8 as libc::c_int) * (*h).mb.i_mb_x - 12 as libc::c_int) > -mv_range
        {
            4 as libc::c_int * (-(8 as libc::c_int) * (*h).mb.i_mb_x - 12 as libc::c_int)
        } else {
            -mv_range
        };
        (*h)
            .mb
            .mv_max_spel[0 as libc::c_int
            as usize] = if 4 as libc::c_int
            * (8 as libc::c_int
                * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as libc::c_int)
                + 12 as libc::c_int) < mv_range - 1 as libc::c_int
        {
            4 as libc::c_int
                * (8 as libc::c_int
                    * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as libc::c_int)
                    + 12 as libc::c_int)
        } else {
            mv_range - 1 as libc::c_int
        };
        (*h)
            .mb
            .mv_limit_fpel[0 as libc::c_int
            as usize][0 as libc::c_int
            as usize] = ((*h).mb.mv_min_spel[0 as libc::c_int as usize]
            >> 2 as libc::c_int) as int16_t;
        (*h)
            .mb
            .mv_limit_fpel[1 as libc::c_int
            as usize][0 as libc::c_int
            as usize] = ((*h).mb.mv_max_spel[0 as libc::c_int as usize]
            >> 2 as libc::c_int) as int16_t;
        if (*h).mb.i_mb_x >= (*h).mb.i_mb_width - 2 as libc::c_int {
            (*h)
                .mb
                .mv_min_spel[1 as libc::c_int
                as usize] = if 4 as libc::c_int
                * (-(8 as libc::c_int) * (*h).mb.i_mb_y - 12 as libc::c_int) > -mv_range
            {
                4 as libc::c_int
                    * (-(8 as libc::c_int) * (*h).mb.i_mb_y - 12 as libc::c_int)
            } else {
                -mv_range
            };
            (*h)
                .mb
                .mv_max_spel[1 as libc::c_int
                as usize] = if 4 as libc::c_int
                * (8 as libc::c_int
                    * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as libc::c_int)
                    + 12 as libc::c_int) < mv_range - 1 as libc::c_int
            {
                4 as libc::c_int
                    * (8 as libc::c_int
                        * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as libc::c_int)
                        + 12 as libc::c_int)
            } else {
                mv_range - 1 as libc::c_int
            };
            (*h)
                .mb
                .mv_limit_fpel[0 as libc::c_int
                as usize][1 as libc::c_int
                as usize] = ((*h).mb.mv_min_spel[1 as libc::c_int as usize]
                >> 2 as libc::c_int) as int16_t;
            (*h)
                .mb
                .mv_limit_fpel[1 as libc::c_int
                as usize][1 as libc::c_int
                as usize] = ((*h).mb.mv_max_spel[1 as libc::c_int as usize]
                >> 2 as libc::c_int) as int16_t;
        }
        m[0 as libc::c_int as usize].i_pixel = PIXEL_8x8 as libc::c_int;
        m[0 as libc::c_int as usize].p_cost_mv = (*a).p_cost_mv;
        m[0 as libc::c_int as usize].i_stride[0 as libc::c_int as usize] = i_stride;
        m[0 as libc::c_int as usize]
            .p_fenc[0 as libc::c_int
            as usize] = (*h).mb.pic.p_fenc[0 as libc::c_int as usize];
        m[0 as libc::c_int as usize].weight = w;
        m[0 as libc::c_int as usize].i_ref = 0 as libc::c_int;
        m[0 as libc::c_int as usize]
            .p_fref[0 as libc::c_int
            as usize] = &mut *(*((*fref0).lowres)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .offset(i_pel_offset as isize) as *mut pixel;
        m[0 as libc::c_int as usize]
            .p_fref[1 as libc::c_int
            as usize] = &mut *(*((*fref0).lowres)
            .as_mut_ptr()
            .offset(1 as libc::c_int as isize))
            .offset(i_pel_offset as isize) as *mut pixel;
        m[0 as libc::c_int as usize]
            .p_fref[2 as libc::c_int
            as usize] = &mut *(*((*fref0).lowres)
            .as_mut_ptr()
            .offset(2 as libc::c_int as isize))
            .offset(i_pel_offset as isize) as *mut pixel;
        m[0 as libc::c_int as usize]
            .p_fref[3 as libc::c_int
            as usize] = &mut *(*((*fref0).lowres)
            .as_mut_ptr()
            .offset(3 as libc::c_int as isize))
            .offset(i_pel_offset as isize) as *mut pixel;
        m[0 as libc::c_int as usize]
            .p_fref_w = m[0 as libc::c_int as usize].p_fref[0 as libc::c_int as usize];
        if !((*w.offset(0 as libc::c_int as isize)).weightfn).is_null() {
            m[0 as libc::c_int as usize]
                .p_fref_w = &mut *(*((*fenc).weighted)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
        }
        if b_bidir != 0 {
            let mut dmv: [[int16_t; 2]; 2] = [[0; 2]; 2];
            m[1 as libc::c_int as usize].i_pixel = PIXEL_8x8 as libc::c_int;
            m[1 as libc::c_int as usize].p_cost_mv = (*a).p_cost_mv;
            m[1 as libc::c_int as usize].i_stride[0 as libc::c_int as usize] = i_stride;
            m[1 as libc::c_int as usize]
                .p_fenc[0 as libc::c_int
                as usize] = (*h).mb.pic.p_fenc[0 as libc::c_int as usize];
            m[1 as libc::c_int as usize].i_ref = 0 as libc::c_int;
            m[1 as libc::c_int as usize]
                .weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            m[1 as libc::c_int as usize]
                .p_fref[0 as libc::c_int
                as usize] = &mut *(*((*fref1).lowres)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[1 as libc::c_int as usize]
                .p_fref[1 as libc::c_int
                as usize] = &mut *(*((*fref1).lowres)
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[1 as libc::c_int as usize]
                .p_fref[2 as libc::c_int
                as usize] = &mut *(*((*fref1).lowres)
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[1 as libc::c_int as usize]
                .p_fref[3 as libc::c_int
                as usize] = &mut *(*((*fref1).lowres)
                .as_mut_ptr()
                .offset(3 as libc::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[1 as libc::c_int as usize]
                .p_fref_w = m[1 as libc::c_int as usize]
                .p_fref[0 as libc::c_int as usize];
            if (*((*fref1)
                .lowres_mvs[0 as libc::c_int
                as usize][(p1 - p0 - 1 as libc::c_int) as usize])
                .offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                as libc::c_int != 0x7fff as libc::c_int
            {
                let mut mvr: *mut int16_t = (*((*fref1)
                    .lowres_mvs[0 as libc::c_int
                    as usize][(p1 - p0 - 1 as libc::c_int) as usize])
                    .offset(i_mb_xy as isize))
                    .as_mut_ptr();
                dmv[0 as libc::c_int
                    as usize][0 as libc::c_int
                    as usize] = (*mvr.offset(0 as libc::c_int as isize) as libc::c_int
                    * dist_scale_factor + 128 as libc::c_int >> 8 as libc::c_int)
                    as int16_t;
                dmv[0 as libc::c_int
                    as usize][1 as libc::c_int
                    as usize] = (*mvr.offset(1 as libc::c_int as isize) as libc::c_int
                    * dist_scale_factor + 128 as libc::c_int >> 8 as libc::c_int)
                    as int16_t;
                dmv[1 as libc::c_int
                    as usize][0 as libc::c_int
                    as usize] = (dmv[0 as libc::c_int
                    as usize][0 as libc::c_int as usize] as libc::c_int
                    - *mvr.offset(0 as libc::c_int as isize) as libc::c_int) as int16_t;
                dmv[1 as libc::c_int
                    as usize][1 as libc::c_int
                    as usize] = (dmv[0 as libc::c_int
                    as usize][1 as libc::c_int as usize] as libc::c_int
                    - *mvr.offset(1 as libc::c_int as isize) as libc::c_int) as int16_t;
                dmv[0 as libc::c_int
                    as usize][0 as libc::c_int
                    as usize] = x264_clip3(
                    dmv[0 as libc::c_int as usize][0 as libc::c_int as usize]
                        as libc::c_int,
                    (*h).mb.mv_min_spel[0 as libc::c_int as usize],
                    (*h).mb.mv_max_spel[0 as libc::c_int as usize],
                ) as int16_t;
                dmv[0 as libc::c_int
                    as usize][1 as libc::c_int
                    as usize] = x264_clip3(
                    dmv[0 as libc::c_int as usize][1 as libc::c_int as usize]
                        as libc::c_int,
                    (*h).mb.mv_min_spel[1 as libc::c_int as usize],
                    (*h).mb.mv_max_spel[1 as libc::c_int as usize],
                ) as int16_t;
                dmv[1 as libc::c_int
                    as usize][0 as libc::c_int
                    as usize] = x264_clip3(
                    dmv[1 as libc::c_int as usize][0 as libc::c_int as usize]
                        as libc::c_int,
                    (*h).mb.mv_min_spel[0 as libc::c_int as usize],
                    (*h).mb.mv_max_spel[0 as libc::c_int as usize],
                ) as int16_t;
                dmv[1 as libc::c_int
                    as usize][1 as libc::c_int
                    as usize] = x264_clip3(
                    dmv[1 as libc::c_int as usize][1 as libc::c_int as usize]
                        as libc::c_int,
                    (*h).mb.mv_min_spel[1 as libc::c_int as usize],
                    (*h).mb.mv_max_spel[1 as libc::c_int as usize],
                ) as int16_t;
                if (*h).param.analyse.i_subpel_refine <= 1 as libc::c_int {
                    let ref mut fresh12 = (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i;
                    *fresh12 = (*fresh12 as libc::c_ulonglong
                        & !(0x1000100010001 as libc::c_ulonglong)) as uint64_t;
                }
            } else {
                (*(dmv.as_mut_ptr() as *mut x264_union64_t))
                    .i = 0 as libc::c_int as uint64_t;
            }
            let mut i_cost: libc::c_int = 0;
            if (*h).param.analyse.i_subpel_refine <= 1 as libc::c_int {
                let mut hpel_idx1: libc::c_int = ((dmv[0 as libc::c_int
                    as usize][0 as libc::c_int as usize] as libc::c_int
                    & 2 as libc::c_int) >> 1 as libc::c_int)
                    + (dmv[0 as libc::c_int as usize][1 as libc::c_int as usize]
                        as libc::c_int & 2 as libc::c_int);
                let mut hpel_idx2: libc::c_int = ((dmv[1 as libc::c_int
                    as usize][0 as libc::c_int as usize] as libc::c_int
                    & 2 as libc::c_int) >> 1 as libc::c_int)
                    + (dmv[1 as libc::c_int as usize][1 as libc::c_int as usize]
                        as libc::c_int & 2 as libc::c_int);
                let mut src1: *mut pixel = (m[0 as libc::c_int as usize]
                    .p_fref[hpel_idx1 as usize])
                    .offset(
                        (dmv[0 as libc::c_int as usize][0 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int) as isize,
                    )
                    .offset(
                        ((dmv[0 as libc::c_int as usize][1 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int)
                            * m[0 as libc::c_int as usize]
                                .i_stride[0 as libc::c_int as usize]) as isize,
                    );
                let mut src2: *mut pixel = (m[1 as libc::c_int as usize]
                    .p_fref[hpel_idx2 as usize])
                    .offset(
                        (dmv[1 as libc::c_int as usize][0 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int) as isize,
                    )
                    .offset(
                        ((dmv[1 as libc::c_int as usize][1 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int)
                            * m[1 as libc::c_int as usize]
                                .i_stride[0 as libc::c_int as usize]) as isize,
                    );
                ((*h).mc.avg[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    src1,
                    m[0 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    src2,
                    m[1 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    i_bipred_weight,
                );
            } else {
                let mut stride1: intptr_t = 16 as libc::c_int as intptr_t;
                let mut stride2: intptr_t = 16 as libc::c_int as intptr_t;
                let mut src1_0: *mut pixel = 0 as *mut pixel;
                let mut src2_0: *mut pixel = 0 as *mut pixel;
                src1_0 = ((*h).mc.get_ref)
                    .expect(
                        "non-null function pointer",
                    )(
                    pix1.as_mut_ptr(),
                    &mut stride1,
                    (m[0 as libc::c_int as usize].p_fref).as_mut_ptr(),
                    m[0 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    dmv[0 as libc::c_int as usize][0 as libc::c_int as usize]
                        as libc::c_int,
                    dmv[0 as libc::c_int as usize][1 as libc::c_int as usize]
                        as libc::c_int,
                    8 as libc::c_int,
                    8 as libc::c_int,
                    w,
                );
                src2_0 = ((*h).mc.get_ref)
                    .expect(
                        "non-null function pointer",
                    )(
                    pix2,
                    &mut stride2,
                    (m[1 as libc::c_int as usize].p_fref).as_mut_ptr(),
                    m[1 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    dmv[1 as libc::c_int as usize][0 as libc::c_int as usize]
                        as libc::c_int,
                    dmv[1 as libc::c_int as usize][1 as libc::c_int as usize]
                        as libc::c_int,
                    8 as libc::c_int,
                    8 as libc::c_int,
                    w,
                );
                ((*h).mc.avg[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    src1_0,
                    stride1,
                    src2_0,
                    stride2,
                    i_bipred_weight,
                );
            }
            i_cost = 0 as libc::c_int * (*a).i_lambda
                + ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    m[0 as libc::c_int as usize].p_fenc[0 as libc::c_int as usize],
                    16 as libc::c_int as intptr_t,
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                );
            if i_cost < i_bcost {
                i_bcost = i_cost;
                list_used = 3 as libc::c_int;
            }
            if (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i != 0 {
                let mut i_cost_0: libc::c_int = 0;
                ((*h).mc.avg[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    m[0 as libc::c_int as usize].p_fref[0 as libc::c_int as usize],
                    m[0 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    m[1 as libc::c_int as usize].p_fref[0 as libc::c_int as usize],
                    m[1 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    i_bipred_weight,
                );
                i_cost_0 = ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    m[0 as libc::c_int as usize].p_fenc[0 as libc::c_int as usize],
                    16 as libc::c_int as intptr_t,
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                );
                if i_cost_0 < i_bcost {
                    i_bcost = i_cost_0;
                    list_used = 3 as libc::c_int;
                }
            }
        }
        let mut l: libc::c_int = 0 as libc::c_int;
        while l < 1 as libc::c_int + b_bidir {
            if *do_search.offset(l as isize) != 0 {
                let mut current_block_117: u64;
                let mut i_mvc: libc::c_int = 0 as libc::c_int;
                let mut fenc_mv: *mut [int16_t; 2] = fenc_mvs[l as usize];
                let mut mvc: [[int16_t; 2]; 4] = [[0; 2]; 4];
                (*((mvc[0 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = 0 as libc::c_int as uint32_t;
                (*((mvc[2 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = 0 as libc::c_int as uint32_t;
                if i_mb_x < (*h).mb.i_mb_width - 1 as libc::c_int {
                    (*((mvc[i_mvc as usize]).as_mut_ptr() as *mut x264_union32_t))
                        .i = (*((*fenc_mv.offset(1 as libc::c_int as isize)).as_mut_ptr()
                        as *mut x264_union32_t))
                        .i;
                    i_mvc += 1;
                    i_mvc;
                }
                if i_mb_y < (*h).i_threadslice_end - 1 as libc::c_int {
                    (*((mvc[i_mvc as usize]).as_mut_ptr() as *mut x264_union32_t))
                        .i = (*((*fenc_mv.offset(i_mb_stride as isize)).as_mut_ptr()
                        as *mut x264_union32_t))
                        .i;
                    i_mvc += 1;
                    i_mvc;
                    if i_mb_x > 0 as libc::c_int {
                        (*((mvc[i_mvc as usize]).as_mut_ptr() as *mut x264_union32_t))
                            .i = (*((*fenc_mv
                            .offset((i_mb_stride - 1 as libc::c_int) as isize))
                            .as_mut_ptr() as *mut x264_union32_t))
                            .i;
                        i_mvc += 1;
                        i_mvc;
                    }
                    if i_mb_x < (*h).mb.i_mb_width - 1 as libc::c_int {
                        (*((mvc[i_mvc as usize]).as_mut_ptr() as *mut x264_union32_t))
                            .i = (*((*fenc_mv
                            .offset((i_mb_stride + 1 as libc::c_int) as isize))
                            .as_mut_ptr() as *mut x264_union32_t))
                            .i;
                        i_mvc += 1;
                        i_mvc;
                    }
                }
                if i_mvc <= 1 as libc::c_int {
                    (*((m[l as usize].mvp).as_mut_ptr() as *mut x264_union32_t))
                        .i = (*((mvc[0 as libc::c_int as usize]).as_mut_ptr()
                        as *mut x264_union32_t))
                        .i;
                } else {
                    x264_median_mv(
                        (m[l as usize].mvp).as_mut_ptr(),
                        (mvc[0 as libc::c_int as usize]).as_mut_ptr(),
                        (mvc[1 as libc::c_int as usize]).as_mut_ptr(),
                        (mvc[2 as libc::c_int as usize]).as_mut_ptr(),
                    );
                }
                if (*((m[l as usize].mvp).as_mut_ptr() as *mut x264_union32_t)).i == 0 {
                    m[l as usize]
                        .cost = ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        m[l as usize].p_fenc[0 as libc::c_int as usize],
                        16 as libc::c_int as intptr_t,
                        m[l as usize].p_fref[0 as libc::c_int as usize],
                        m[l as usize].i_stride[0 as libc::c_int as usize] as intptr_t,
                    );
                    if m[l as usize].cost < 64 as libc::c_int {
                        (*((m[l as usize].mv).as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as libc::c_int as uint32_t;
                        current_block_117 = 11344938856102329863;
                    } else {
                        current_block_117 = 17958840340921835115;
                    }
                } else {
                    current_block_117 = 17958840340921835115;
                }
                match current_block_117 {
                    17958840340921835115 => {
                        x264_8_me_search_ref(
                            h,
                            &mut *m.as_mut_ptr().offset(l as isize),
                            mvc.as_mut_ptr(),
                            i_mvc,
                            0 as *mut libc::c_int,
                        );
                        m[l as usize].cost
                            -= *((*a).p_cost_mv).offset(0 as libc::c_int as isize)
                                as libc::c_int;
                        if (*((m[l as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i
                            != 0
                        {
                            m[l as usize].cost += 5 as libc::c_int * (*a).i_lambda;
                        }
                    }
                    _ => {}
                }
                (*(fenc_mvs[l as usize] as *mut x264_union32_t))
                    .i = (*((m[l as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i;
                *fenc_costs[l as usize] = m[l as usize].cost;
            } else {
                (*((m[l as usize].mv).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(fenc_mvs[l as usize] as *mut x264_union32_t)).i;
                m[l as usize].cost = *fenc_costs[l as usize];
            }
            if m[l as usize].cost < i_bcost {
                i_bcost = m[l as usize].cost;
                list_used = l + 1 as libc::c_int;
            }
            l += 1;
            l;
        }
        if b_bidir != 0
            && ((*((m[0 as libc::c_int as usize].mv).as_mut_ptr()
                as *mut x264_union32_t))
                .i != 0
                || (*((m[1 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i != 0)
        {
            let mut i_cost_1: libc::c_int = 0;
            if (*h).param.analyse.i_subpel_refine <= 1 as libc::c_int {
                let mut hpel_idx1_0: libc::c_int = ((m[0 as libc::c_int as usize]
                    .mv[0 as libc::c_int as usize] as libc::c_int & 2 as libc::c_int)
                    >> 1 as libc::c_int)
                    + (m[0 as libc::c_int as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int & 2 as libc::c_int);
                let mut hpel_idx2_0: libc::c_int = ((m[1 as libc::c_int as usize]
                    .mv[0 as libc::c_int as usize] as libc::c_int & 2 as libc::c_int)
                    >> 1 as libc::c_int)
                    + (m[1 as libc::c_int as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int & 2 as libc::c_int);
                let mut src1_1: *mut pixel = (m[0 as libc::c_int as usize]
                    .p_fref[hpel_idx1_0 as usize])
                    .offset(
                        (m[0 as libc::c_int as usize].mv[0 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int) as isize,
                    )
                    .offset(
                        ((m[0 as libc::c_int as usize].mv[1 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int)
                            * m[0 as libc::c_int as usize]
                                .i_stride[0 as libc::c_int as usize]) as isize,
                    );
                let mut src2_1: *mut pixel = (m[1 as libc::c_int as usize]
                    .p_fref[hpel_idx2_0 as usize])
                    .offset(
                        (m[1 as libc::c_int as usize].mv[0 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int) as isize,
                    )
                    .offset(
                        ((m[1 as libc::c_int as usize].mv[1 as libc::c_int as usize]
                            as libc::c_int >> 2 as libc::c_int)
                            * m[1 as libc::c_int as usize]
                                .i_stride[0 as libc::c_int as usize]) as isize,
                    );
                ((*h).mc.avg[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    src1_1,
                    m[0 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    src2_1,
                    m[1 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    i_bipred_weight,
                );
            } else {
                let mut stride1_0: intptr_t = 16 as libc::c_int as intptr_t;
                let mut stride2_0: intptr_t = 16 as libc::c_int as intptr_t;
                let mut src1_2: *mut pixel = 0 as *mut pixel;
                let mut src2_2: *mut pixel = 0 as *mut pixel;
                src1_2 = ((*h).mc.get_ref)
                    .expect(
                        "non-null function pointer",
                    )(
                    pix1.as_mut_ptr(),
                    &mut stride1_0,
                    (m[0 as libc::c_int as usize].p_fref).as_mut_ptr(),
                    m[0 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    m[0 as libc::c_int as usize].mv[0 as libc::c_int as usize]
                        as libc::c_int,
                    m[0 as libc::c_int as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int,
                    8 as libc::c_int,
                    8 as libc::c_int,
                    w,
                );
                src2_2 = ((*h).mc.get_ref)
                    .expect(
                        "non-null function pointer",
                    )(
                    pix2,
                    &mut stride2_0,
                    (m[1 as libc::c_int as usize].p_fref).as_mut_ptr(),
                    m[1 as libc::c_int as usize].i_stride[0 as libc::c_int as usize]
                        as intptr_t,
                    m[1 as libc::c_int as usize].mv[0 as libc::c_int as usize]
                        as libc::c_int,
                    m[1 as libc::c_int as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int,
                    8 as libc::c_int,
                    8 as libc::c_int,
                    w,
                );
                ((*h).mc.avg[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    src1_2,
                    stride1_0,
                    src2_2,
                    stride2_0,
                    i_bipred_weight,
                );
            }
            i_cost_1 = 5 as libc::c_int * (*a).i_lambda
                + ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    m[0 as libc::c_int as usize].p_fenc[0 as libc::c_int as usize],
                    16 as libc::c_int as intptr_t,
                    pix1.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                );
            if i_cost_1 < i_bcost {
                i_bcost = i_cost_1;
                list_used = 3 as libc::c_int;
            }
        }
    }
    if (*fenc).b_intra_calculated == 0 {
        let mut edge: [pixel; 36] = [0; 36];
        let mut pix: *mut pixel = &mut *pix1
            .as_mut_ptr()
            .offset((8 as libc::c_int + 32 as libc::c_int) as isize) as *mut pixel;
        let mut src: *mut pixel = &mut *(*((*fenc).lowres)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .offset(i_pel_offset as isize) as *mut pixel;
        let intra_penalty: libc::c_int = 5 as libc::c_int * (*a).i_lambda;
        let mut satds: [libc::c_int; 3] = [0; 3];
        let mut pixoff: libc::c_int = 4 as libc::c_int
            / ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int;
        memcpy(
            pix.offset(-(32 as libc::c_int as isize)) as *mut libc::c_void,
            src.offset(-(i_stride as isize)) as *const libc::c_void,
            (16 as libc::c_int
                * ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int)
                as libc::c_ulong,
        );
        let mut i: libc::c_int = -(1 as libc::c_int);
        while i < 8 as libc::c_int {
            (*(&mut *pix.offset((i * 32 as libc::c_int - pixoff) as isize) as *mut pixel
                as *mut x264_union32_t))
                .i = (*(&mut *src.offset((i * i_stride - pixoff) as isize) as *mut pixel
                as *mut x264_union32_t))
                .i;
            i += 1;
            i;
        }
        ((*h).pixf.intra_mbcmp_x3_8x8c)
            .expect(
                "non-null function pointer",
            )((*h).mb.pic.p_fenc[0 as libc::c_int as usize], pix, satds.as_mut_ptr());
        let mut i_icost: libc::c_int = if satds[0 as libc::c_int as usize]
            < (if satds[1 as libc::c_int as usize] < satds[2 as libc::c_int as usize] {
                satds[1 as libc::c_int as usize]
            } else {
                satds[2 as libc::c_int as usize]
            })
        {
            satds[0 as libc::c_int as usize]
        } else if satds[1 as libc::c_int as usize] < satds[2 as libc::c_int as usize] {
            satds[1 as libc::c_int as usize]
        } else {
            satds[2 as libc::c_int as usize]
        };
        if (*h).param.analyse.i_subpel_refine > 1 as libc::c_int {
            ((*h).predict_8x8c[I_PRED_CHROMA_P as libc::c_int as usize])
                .expect("non-null function pointer")(pix);
            let mut satd: libc::c_int = ((*h)
                .pixf
                .mbcmp[PIXEL_8x8 as libc::c_int as usize])
                .expect(
                    "non-null function pointer",
                )(
                (*h).mb.pic.p_fenc[0 as libc::c_int as usize],
                16 as libc::c_int as intptr_t,
                pix,
                32 as libc::c_int as intptr_t,
            );
            i_icost = if i_icost < satd { i_icost } else { satd };
            ((*h).predict_8x8_filter)
                .expect(
                    "non-null function pointer",
                )(
                pix,
                edge.as_mut_ptr(),
                ALL_NEIGHBORS as libc::c_int,
                ALL_NEIGHBORS as libc::c_int,
            );
            let mut i_0: libc::c_int = 3 as libc::c_int;
            while i_0 < 9 as libc::c_int {
                ((*h).predict_8x8[i_0 as usize])
                    .expect("non-null function pointer")(pix, edge.as_mut_ptr());
                satd = ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    (*h).mb.pic.p_fenc[0 as libc::c_int as usize],
                    16 as libc::c_int as intptr_t,
                    pix,
                    32 as libc::c_int as intptr_t,
                );
                i_icost = if i_icost < satd { i_icost } else { satd };
                i_0 += 1;
                i_0;
            }
        }
        i_icost = (i_icost + intra_penalty >> 8 as libc::c_int - 8 as libc::c_int)
            + lowres_penalty;
        *((*fenc).i_intra_cost).offset(i_mb_xy as isize) = i_icost as uint16_t;
        let mut i_icost_aq: libc::c_int = i_icost;
        if (*h).param.rc.i_aq_mode != 0 {
            i_icost_aq = i_icost_aq
                * *((*fenc).i_inv_qscale_factor).offset(i_mb_xy as isize) as libc::c_int
                + 128 as libc::c_int >> 8 as libc::c_int;
        }
        *output_intra
            .offset(
                (4 as libc::c_int + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize,
            ) += i_icost_aq;
        if b_frame_score_mb != 0 {
            *output_intra.offset(0 as libc::c_int as isize) += i_icost;
            *output_intra.offset(1 as libc::c_int as isize) += i_icost_aq;
        }
    }
    i_bcost = (i_bcost >> 8 as libc::c_int - 8 as libc::c_int) + lowres_penalty;
    if b_bidir == 0 {
        let mut i_icost_0: libc::c_int = *((*fenc).i_intra_cost).offset(i_mb_xy as isize)
            as libc::c_int;
        let mut b_intra: libc::c_int = (i_icost_0 < i_bcost) as libc::c_int;
        if b_intra != 0 {
            i_bcost = i_icost_0;
            list_used = 0 as libc::c_int;
        }
        if b_frame_score_mb != 0 {
            *output_inter.offset(2 as libc::c_int as isize) += b_intra;
        }
    }
    if p0 != p1 {
        let mut i_bcost_aq: libc::c_int = i_bcost;
        if (*h).param.rc.i_aq_mode != 0 {
            i_bcost_aq = i_bcost_aq
                * *((*fenc).i_inv_qscale_factor).offset(i_mb_xy as isize) as libc::c_int
                + 128 as libc::c_int >> 8 as libc::c_int;
        }
        *output_inter
            .offset(
                (4 as libc::c_int + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize,
            ) += i_bcost_aq;
        if b_frame_score_mb != 0 {
            *output_inter.offset(0 as libc::c_int as isize) += i_bcost;
            *output_inter.offset(1 as libc::c_int as isize) += i_bcost_aq;
        }
    }
    *((*fenc).lowres_costs[(b - p0) as usize][(p1 - b) as usize])
        .offset(
            i_mb_xy as isize,
        ) = ((if i_bcost < ((1 as libc::c_int) << 14 as libc::c_int) - 1 as libc::c_int {
        i_bcost
    } else {
        ((1 as libc::c_int) << 14 as libc::c_int) - 1 as libc::c_int
    }) + (list_used << 14 as libc::c_int)) as uint16_t;
}
unsafe extern "C" fn slicetype_slice_cost(mut s: *mut x264_slicetype_slice_t) {
    let mut h: *mut x264_t = (*s).h;
    let mut do_edges: libc::c_int = ((*h).param.rc.b_mb_tree != 0
        || (*h).param.rc.i_vbv_buffer_size != 0 || (*h).mb.i_mb_width <= 2 as libc::c_int
        || (*h).mb.i_mb_height <= 2 as libc::c_int) as libc::c_int;
    let mut start_y: libc::c_int = if ((*h).i_threadslice_end - 1 as libc::c_int)
        < (*h).mb.i_mb_height - 2 as libc::c_int + do_edges
    {
        (*h).i_threadslice_end - 1 as libc::c_int
    } else {
        (*h).mb.i_mb_height - 2 as libc::c_int + do_edges
    };
    let mut end_y: libc::c_int = if (*h).i_threadslice_start
        > 1 as libc::c_int - do_edges
    {
        (*h).i_threadslice_start
    } else {
        1 as libc::c_int - do_edges
    };
    let mut start_x: libc::c_int = (*h).mb.i_mb_width - 2 as libc::c_int + do_edges;
    let mut end_x: libc::c_int = 1 as libc::c_int - do_edges;
    (*h).mb.i_mb_y = start_y;
    while (*h).mb.i_mb_y >= end_y {
        (*h).mb.i_mb_x = start_x;
        while (*h).mb.i_mb_x >= end_x {
            slicetype_mb_cost(
                h,
                (*s).a,
                (*s).frames,
                (*s).p0,
                (*s).p1,
                (*s).b,
                (*s).dist_scale_factor,
                (*s).do_search,
                (*s).w,
                (*s).output_inter,
                (*s).output_intra,
            );
            (*h).mb.i_mb_x -= 1;
            (*h).mb.i_mb_x;
        }
        (*h).mb.i_mb_y -= 1;
        (*h).mb.i_mb_y;
    }
}
unsafe extern "C" fn slicetype_frame_cost(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut p0: libc::c_int,
    mut p1: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut i_score: libc::c_int = 0 as libc::c_int;
    let mut do_search: [libc::c_int; 2] = [0; 2];
    let mut w: *const x264_weight_t = x264_zero.as_mut_ptr() as *const x264_weight_t;
    let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
    if (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] >= 0 as libc::c_int
        && ((*h).param.rc.i_vbv_buffer_size == 0
            || *((*fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize])
                .offset(0 as libc::c_int as isize) != -(1 as libc::c_int))
    {
        i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
    } else {
        let mut dist_scale_factor: libc::c_int = 128 as libc::c_int;
        do_search[0 as libc::c_int
            as usize] = (b != p0
            && (*((*fenc)
                .lowres_mvs[0 as libc::c_int
                as usize][(b - p0 - 1 as libc::c_int) as usize])
                .offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                as libc::c_int == 0x7fff as libc::c_int) as libc::c_int;
        do_search[1 as libc::c_int
            as usize] = (b != p1
            && (*((*fenc)
                .lowres_mvs[1 as libc::c_int
                as usize][(p1 - b - 1 as libc::c_int) as usize])
                .offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                as libc::c_int == 0x7fff as libc::c_int) as libc::c_int;
        if do_search[0 as libc::c_int as usize] != 0 {
            if (*h).param.analyse.i_weighted_pred != 0 && b == p1 {
                x264_8_weights_analyse(
                    h,
                    fenc,
                    *frames.offset(p0 as isize),
                    1 as libc::c_int,
                );
                w = ((*fenc).weight[0 as libc::c_int as usize]).as_mut_ptr();
            }
            (*((*fenc)
                .lowres_mvs[0 as libc::c_int
                as usize][(b - p0 - 1 as libc::c_int) as usize])
                .offset(
                    0 as libc::c_int as isize,
                ))[0 as libc::c_int as usize] = 0 as libc::c_int as int16_t;
        }
        if do_search[1 as libc::c_int as usize] != 0 {
            (*((*fenc)
                .lowres_mvs[1 as libc::c_int
                as usize][(p1 - b - 1 as libc::c_int) as usize])
                .offset(
                    0 as libc::c_int as isize,
                ))[0 as libc::c_int as usize] = 0 as libc::c_int as int16_t;
        }
        if p1 != p0 {
            dist_scale_factor = ((b - p0 << 8 as libc::c_int)
                + (p1 - p0 >> 1 as libc::c_int)) / (p1 - p0);
        }
        let mut output_buf_size: libc::c_int = (*h).mb.i_mb_height
            + (4 as libc::c_int + 32 as libc::c_int) * (*h).param.i_lookahead_threads;
        let mut output_inter: [*mut libc::c_int; 17] = [0 as *mut libc::c_int; 17];
        let mut output_intra: [*mut libc::c_int; 17] = [0 as *mut libc::c_int; 17];
        output_inter[0 as libc::c_int
            as usize] = (*h).scratch_buffer2 as *mut libc::c_int;
        output_intra[0 as libc::c_int
            as usize] = (output_inter[0 as libc::c_int as usize])
            .offset(output_buf_size as isize);
        if (*h).param.b_opencl != 0 {
            x264_8_opencl_lowres_init(h, fenc, (*a).i_lambda);
            if do_search[0 as libc::c_int as usize] != 0 {
                x264_8_opencl_lowres_init(h, *frames.offset(p0 as isize), (*a).i_lambda);
                x264_8_opencl_motionsearch(
                    h,
                    frames,
                    b,
                    p0,
                    0 as libc::c_int,
                    (*a).i_lambda,
                    w,
                );
            }
            if do_search[1 as libc::c_int as usize] != 0 {
                x264_8_opencl_lowres_init(h, *frames.offset(p1 as isize), (*a).i_lambda);
                x264_8_opencl_motionsearch(
                    h,
                    frames,
                    b,
                    p1,
                    1 as libc::c_int,
                    (*a).i_lambda,
                    0 as *const x264_weight_t,
                );
            }
            if b != p0 {
                x264_8_opencl_finalize_cost(
                    h,
                    (*a).i_lambda,
                    frames,
                    p0,
                    p1,
                    b,
                    dist_scale_factor,
                );
            }
            x264_8_opencl_flush(h);
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
        } else {
            if (*h).param.i_lookahead_threads > 1 as libc::c_int {
                let mut s: [x264_slicetype_slice_t; 16] = [x264_slicetype_slice_t {
                    h: 0 as *mut x264_t,
                    a: 0 as *mut x264_mb_analysis_t,
                    frames: 0 as *mut *mut x264_frame_t,
                    p0: 0,
                    p1: 0,
                    b: 0,
                    dist_scale_factor: 0,
                    do_search: 0 as *mut libc::c_int,
                    w: 0 as *const x264_weight_t,
                    output_inter: 0 as *mut libc::c_int,
                    output_intra: 0 as *mut libc::c_int,
                }; 16];
                let mut i: libc::c_int = 0 as libc::c_int;
                while i < (*h).param.i_lookahead_threads {
                    let mut t: *mut x264_t = (*h).lookahead_thread[i as usize];
                    (*t).mb.i_me_method = (*h).mb.i_me_method;
                    (*t).mb.i_subpel_refine = (*h).mb.i_subpel_refine;
                    (*t).mb.b_chroma_me = (*h).mb.b_chroma_me;
                    s[i
                        as usize] = {
                        let mut init = x264_slicetype_slice_t {
                            h: t,
                            a: a,
                            frames: frames,
                            p0: p0,
                            p1: p1,
                            b: b,
                            dist_scale_factor: dist_scale_factor,
                            do_search: do_search.as_mut_ptr(),
                            w: w,
                            output_inter: output_inter[i as usize],
                            output_intra: output_intra[i as usize],
                        };
                        init
                    };
                    (*t)
                        .i_threadslice_start = ((*h).mb.i_mb_height * i
                        + (*h).param.i_lookahead_threads / 2 as libc::c_int)
                        / (*h).param.i_lookahead_threads;
                    (*t)
                        .i_threadslice_end = ((*h).mb.i_mb_height
                        * (i + 1 as libc::c_int)
                        + (*h).param.i_lookahead_threads / 2 as libc::c_int)
                        / (*h).param.i_lookahead_threads;
                    let mut thread_height: libc::c_int = (*t).i_threadslice_end
                        - (*t).i_threadslice_start;
                    let mut thread_output_size: libc::c_int = thread_height
                        + 4 as libc::c_int;
                    memset(
                        output_inter[i as usize] as *mut libc::c_void,
                        0 as libc::c_int,
                        (thread_output_size as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                            ),
                    );
                    memset(
                        output_intra[i as usize] as *mut libc::c_void,
                        0 as libc::c_int,
                        (thread_output_size as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                            ),
                    );
                    let ref mut fresh13 = *(output_intra[i as usize])
                        .offset(3 as libc::c_int as isize);
                    *fresh13 = thread_height;
                    *(output_inter[i as usize])
                        .offset(3 as libc::c_int as isize) = *fresh13;
                    output_inter[(i + 1 as libc::c_int)
                        as usize] = (output_inter[i as usize])
                        .offset(thread_output_size as isize)
                        .offset(32 as libc::c_int as isize);
                    output_intra[(i + 1 as libc::c_int)
                        as usize] = (output_intra[i as usize])
                        .offset(thread_output_size as isize)
                        .offset(32 as libc::c_int as isize);
                    x264_8_threadpool_run(
                        (*h).lookaheadpool,
                        ::core::mem::transmute::<
                            *mut libc::c_void,
                            Option::<
                                unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
                            >,
                        >(
                            ::core::mem::transmute::<
                                Option::<
                                    unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> (),
                                >,
                                *mut libc::c_void,
                            >(
                                Some(
                                    slicetype_slice_cost
                                        as unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> (),
                                ),
                            ),
                        ),
                        &mut *s.as_mut_ptr().offset(i as isize)
                            as *mut x264_slicetype_slice_t as *mut libc::c_void,
                    );
                    i += 1;
                    i;
                }
                let mut i_0: libc::c_int = 0 as libc::c_int;
                while i_0 < (*h).param.i_lookahead_threads {
                    x264_8_threadpool_wait(
                        (*h).lookaheadpool,
                        &mut *s.as_mut_ptr().offset(i_0 as isize)
                            as *mut x264_slicetype_slice_t as *mut libc::c_void,
                    );
                    i_0 += 1;
                    i_0;
                }
            } else {
                (*h).i_threadslice_start = 0 as libc::c_int;
                (*h).i_threadslice_end = (*h).mb.i_mb_height;
                memset(
                    output_inter[0 as libc::c_int as usize] as *mut libc::c_void,
                    0 as libc::c_int,
                    ((output_buf_size - 32 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ),
                );
                memset(
                    output_intra[0 as libc::c_int as usize] as *mut libc::c_void,
                    0 as libc::c_int,
                    ((output_buf_size - 32 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ),
                );
                let ref mut fresh14 = *(output_intra[0 as libc::c_int as usize])
                    .offset(3 as libc::c_int as isize);
                *fresh14 = (*h).mb.i_mb_height;
                *(output_inter[0 as libc::c_int as usize])
                    .offset(3 as libc::c_int as isize) = *fresh14;
                let mut s_0: x264_slicetype_slice_t = {
                    let mut init = x264_slicetype_slice_t {
                        h: h,
                        a: a,
                        frames: frames,
                        p0: p0,
                        p1: p1,
                        b: b,
                        dist_scale_factor: dist_scale_factor,
                        do_search: do_search.as_mut_ptr(),
                        w: w,
                        output_inter: output_inter[0 as libc::c_int as usize],
                        output_intra: output_intra[0 as libc::c_int as usize],
                    };
                    init
                };
                slicetype_slice_cost(&mut s_0);
            }
            if b == p1 {
                (*fenc).i_intra_mbs[(b - p0) as usize] = 0 as libc::c_int;
            }
            if (*fenc).b_intra_calculated == 0 {
                (*fenc)
                    .i_cost_est[0 as libc::c_int
                    as usize][0 as libc::c_int as usize] = 0 as libc::c_int;
                (*fenc)
                    .i_cost_est_aq[0 as libc::c_int
                    as usize][0 as libc::c_int as usize] = 0 as libc::c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = 0 as libc::c_int;
            (*fenc)
                .i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize] = 0 as libc::c_int;
            let mut row_satd_inter: *mut libc::c_int = (*fenc)
                .i_row_satds[(b - p0) as usize][(p1 - b) as usize];
            let mut row_satd_intra: *mut libc::c_int = (*fenc)
                .i_row_satds[0 as libc::c_int as usize][0 as libc::c_int as usize];
            let mut i_1: libc::c_int = 0 as libc::c_int;
            while i_1 < (*h).param.i_lookahead_threads {
                if b == p1 {
                    (*fenc).i_intra_mbs[(b - p0) as usize]
                        += *(output_inter[i_1 as usize])
                            .offset(2 as libc::c_int as isize);
                }
                if (*fenc).b_intra_calculated == 0 {
                    (*fenc)
                        .i_cost_est[0 as libc::c_int as usize][0 as libc::c_int as usize]
                        += *(output_intra[i_1 as usize])
                            .offset(0 as libc::c_int as isize);
                    (*fenc)
                        .i_cost_est_aq[0 as libc::c_int
                        as usize][0 as libc::c_int as usize]
                        += *(output_intra[i_1 as usize])
                            .offset(1 as libc::c_int as isize);
                }
                (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize]
                    += *(output_inter[i_1 as usize]).offset(0 as libc::c_int as isize);
                (*fenc).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize]
                    += *(output_inter[i_1 as usize]).offset(1 as libc::c_int as isize);
                if (*h).param.rc.i_vbv_buffer_size != 0 {
                    let mut row_count: libc::c_int = *(output_inter[i_1 as usize])
                        .offset(3 as libc::c_int as isize);
                    memcpy(
                        row_satd_inter as *mut libc::c_void,
                        (output_inter[i_1 as usize]).offset(4 as libc::c_int as isize)
                            as *const libc::c_void,
                        (row_count as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                            ),
                    );
                    if (*fenc).b_intra_calculated == 0 {
                        memcpy(
                            row_satd_intra as *mut libc::c_void,
                            (output_intra[i_1 as usize])
                                .offset(4 as libc::c_int as isize) as *const libc::c_void,
                            (row_count as libc::c_ulong)
                                .wrapping_mul(
                                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                                ),
                        );
                    }
                    row_satd_inter = row_satd_inter.offset(row_count as isize);
                    row_satd_intra = row_satd_intra.offset(row_count as isize);
                }
                i_1 += 1;
                i_1;
            }
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
            if b != p1 {
                i_score = (i_score as uint64_t * 100 as libc::c_int as uint64_t
                    / (120 as libc::c_int + (*h).param.i_bframe_bias) as uint64_t)
                    as libc::c_int;
            } else {
                (*fenc).b_intra_calculated = 1 as libc::c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = i_score;
        }
    }
    return i_score;
}
unsafe extern "C" fn slicetype_frame_cost_recalculate(
    mut h: *mut x264_t,
    mut frames: *mut *mut x264_frame_t,
    mut p0: libc::c_int,
    mut p1: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut i_score: libc::c_int = 0 as libc::c_int;
    let mut row_satd: *mut libc::c_int = (**frames.offset(b as isize))
        .i_row_satds[(b - p0) as usize][(p1 - b) as usize];
    let mut qp_offset: *mut libc::c_float = if (**frames.offset(b as isize)).i_type
        == 0x5 as libc::c_int
        || (**frames.offset(b as isize)).i_type == 0x4 as libc::c_int
    {
        (**frames.offset(b as isize)).f_qp_offset_aq
    } else {
        (**frames.offset(b as isize)).f_qp_offset
    };
    (*h).mb.i_mb_y = (*h).mb.i_mb_height - 1 as libc::c_int;
    while (*h).mb.i_mb_y >= 0 as libc::c_int {
        *row_satd.offset((*h).mb.i_mb_y as isize) = 0 as libc::c_int;
        (*h).mb.i_mb_x = (*h).mb.i_mb_width - 1 as libc::c_int;
        while (*h).mb.i_mb_x >= 0 as libc::c_int {
            let mut i_mb_xy: libc::c_int = (*h).mb.i_mb_x
                + (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
            let mut i_mb_cost: libc::c_int = *((**frames.offset(b as isize))
                .lowres_costs[(b - p0) as usize][(p1 - b) as usize])
                .offset(i_mb_xy as isize) as libc::c_int
                & ((1 as libc::c_int) << 14 as libc::c_int) - 1 as libc::c_int;
            let mut qp_adj: libc::c_float = *qp_offset.offset(i_mb_xy as isize);
            i_mb_cost = i_mb_cost * x264_exp2fix8(qp_adj) + 128 as libc::c_int
                >> 8 as libc::c_int;
            *row_satd.offset((*h).mb.i_mb_y as isize) += i_mb_cost;
            if (*h).mb.i_mb_y > 0 as libc::c_int
                && (*h).mb.i_mb_y < (*h).mb.i_mb_height - 1 as libc::c_int
                && (*h).mb.i_mb_x > 0 as libc::c_int
                && (*h).mb.i_mb_x < (*h).mb.i_mb_width - 1 as libc::c_int
                || (*h).mb.i_mb_width <= 2 as libc::c_int
                || (*h).mb.i_mb_height <= 2 as libc::c_int
            {
                i_score += i_mb_cost;
            }
            (*h).mb.i_mb_x -= 1;
            (*h).mb.i_mb_x;
        }
        (*h).mb.i_mb_y -= 1;
        (*h).mb.i_mb_y;
    }
    return i_score;
}
unsafe extern "C" fn macroblock_tree_finish(
    mut h: *mut x264_t,
    mut frame: *mut x264_frame_t,
    mut average_duration: libc::c_float,
    mut ref0_distance: libc::c_int,
) {
    let mut fps_factor: libc::c_int = round(
        x264_clip3f(
            average_duration as libc::c_double,
            (0.01f32
                / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                    + 1 as libc::c_int) as libc::c_float) as libc::c_double,
            (1.00f32
                / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                    + 1 as libc::c_int) as libc::c_float) as libc::c_double,
        )
            / x264_clip3f(
                (*frame).f_duration as libc::c_double,
                (0.01f32
                    / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                        + 1 as libc::c_int) as libc::c_float) as libc::c_double,
                (1.00f32
                    / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                        + 1 as libc::c_int) as libc::c_float) as libc::c_double,
            ) * 256 as libc::c_int as libc::c_double / 0.5f32 as libc::c_double,
    ) as libc::c_int;
    let mut weightdelta: libc::c_float = 0.0f64 as libc::c_float;
    if ref0_distance != 0
        && (*frame).f_weighted_cost_delta[(ref0_distance - 1 as libc::c_int) as usize]
            > 0 as libc::c_int as libc::c_float
    {
        weightdelta = (1.0f64
            - (*frame).f_weighted_cost_delta[(ref0_distance - 1 as libc::c_int) as usize]
                as libc::c_double) as libc::c_float;
    }
    let mut strength: libc::c_float = 5.0f32 * (1.0f32 - (*h).param.rc.f_qcompress);
    let mut mb_index: libc::c_int = 0 as libc::c_int;
    while mb_index < (*h).mb.i_mb_count {
        let mut intra_cost: libc::c_int = *((*frame).i_intra_cost)
            .offset(mb_index as isize) as libc::c_int
            * *((*frame).i_inv_qscale_factor).offset(mb_index as isize) as libc::c_int
            + 128 as libc::c_int >> 8 as libc::c_int;
        if intra_cost != 0 {
            let mut propagate_cost: libc::c_int = *((*frame).i_propagate_cost)
                .offset(mb_index as isize) as libc::c_int * fps_factor
                + 128 as libc::c_int >> 8 as libc::c_int;
            let mut log2_ratio: libc::c_float = x264_log2(
                (intra_cost + propagate_cost) as uint32_t,
            ) - x264_log2(intra_cost as uint32_t) + weightdelta;
            *((*frame).f_qp_offset)
                .offset(
                    mb_index as isize,
                ) = *((*frame).f_qp_offset_aq).offset(mb_index as isize)
                - strength * log2_ratio;
        }
        mb_index += 1;
        mb_index;
    }
}
unsafe extern "C" fn macroblock_tree_propagate(
    mut h: *mut x264_t,
    mut frames: *mut *mut x264_frame_t,
    mut average_duration: libc::c_float,
    mut p0: libc::c_int,
    mut p1: libc::c_int,
    mut b: libc::c_int,
    mut referenced: libc::c_int,
) {
    let mut ref_costs: [*mut uint16_t; 2] = [
        (**frames.offset(p0 as isize)).i_propagate_cost,
        (**frames.offset(p1 as isize)).i_propagate_cost,
    ];
    let mut dist_scale_factor: libc::c_int = ((b - p0 << 8 as libc::c_int)
        + (p1 - p0 >> 1 as libc::c_int)) / (p1 - p0);
    let mut i_bipred_weight: libc::c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
        64 as libc::c_int - (dist_scale_factor >> 2 as libc::c_int)
    } else {
        32 as libc::c_int
    };
    let mut mvs: [*mut [int16_t; 2]; 2] = [
        if b != p0 {
            (**frames.offset(b as isize))
                .lowres_mvs[0 as libc::c_int
                as usize][(b - p0 - 1 as libc::c_int) as usize]
        } else {
            0 as *mut [int16_t; 2]
        },
        if b != p1 {
            (**frames.offset(b as isize))
                .lowres_mvs[1 as libc::c_int
                as usize][(p1 - b - 1 as libc::c_int) as usize]
        } else {
            0 as *mut [int16_t; 2]
        },
    ];
    let mut bipred_weights: [libc::c_int; 2] = [
        i_bipred_weight,
        64 as libc::c_int - i_bipred_weight,
    ];
    let mut buf: *mut int16_t = (*h).scratch_buffer as *mut int16_t;
    let mut propagate_cost: *mut uint16_t = (**frames.offset(b as isize))
        .i_propagate_cost;
    let mut lowres_costs: *mut uint16_t = (**frames.offset(b as isize))
        .lowres_costs[(b - p0) as usize][(p1 - b) as usize];
    let mut fps_factor: libc::c_float = (x264_clip3f(
        (**frames.offset(b as isize)).f_duration as libc::c_double,
        (0.01f32
            / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                + 1 as libc::c_int) as libc::c_float) as libc::c_double,
        (1.00f32
            / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                + 1 as libc::c_int) as libc::c_float) as libc::c_double,
    )
        / (x264_clip3f(
            average_duration as libc::c_double,
            (0.01f32
                / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                    + 1 as libc::c_int) as libc::c_float) as libc::c_double,
            (1.00f32
                / (((*h).param.i_frame_packing == 5 as libc::c_int) as libc::c_int
                    + 1 as libc::c_int) as libc::c_float) as libc::c_double,
        ) * 256.0f32 as libc::c_double) * 0.5f32 as libc::c_double) as libc::c_float;
    if referenced == 0 {
        memset(
            (**frames.offset(b as isize)).i_propagate_cost as *mut libc::c_void,
            0 as libc::c_int,
            ((*h).mb.i_mb_width as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint16_t>() as libc::c_ulong),
        );
    }
    (*h).mb.i_mb_y = 0 as libc::c_int;
    while (*h).mb.i_mb_y < (*h).mb.i_mb_height {
        let mut mb_index: libc::c_int = (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
        ((*h).mc.mbtree_propagate_cost)
            .expect(
                "non-null function pointer",
            )(
            buf,
            propagate_cost,
            ((**frames.offset(b as isize)).i_intra_cost).offset(mb_index as isize),
            lowres_costs.offset(mb_index as isize),
            ((**frames.offset(b as isize)).i_inv_qscale_factor)
                .offset(mb_index as isize),
            &mut fps_factor,
            (*h).mb.i_mb_width,
        );
        if referenced != 0 {
            propagate_cost = propagate_cost.offset((*h).mb.i_mb_width as isize);
        }
        ((*h).mc.mbtree_propagate_list)
            .expect(
                "non-null function pointer",
            )(
            h,
            ref_costs[0 as libc::c_int as usize],
            &mut *(*mvs.as_mut_ptr().offset(0 as libc::c_int as isize))
                .offset(mb_index as isize),
            buf,
            &mut *lowres_costs.offset(mb_index as isize),
            bipred_weights[0 as libc::c_int as usize],
            (*h).mb.i_mb_y,
            (*h).mb.i_mb_width,
            0 as libc::c_int,
        );
        if b != p1 {
            ((*h).mc.mbtree_propagate_list)
                .expect(
                    "non-null function pointer",
                )(
                h,
                ref_costs[1 as libc::c_int as usize],
                &mut *(*mvs.as_mut_ptr().offset(1 as libc::c_int as isize))
                    .offset(mb_index as isize),
                buf,
                &mut *lowres_costs.offset(mb_index as isize),
                bipred_weights[1 as libc::c_int as usize],
                (*h).mb.i_mb_y,
                (*h).mb.i_mb_width,
                1 as libc::c_int,
            );
        }
        (*h).mb.i_mb_y += 1;
        (*h).mb.i_mb_y;
    }
    if (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0
        && referenced != 0
    {
        macroblock_tree_finish(
            h,
            *frames.offset(b as isize),
            average_duration,
            if b == p1 { b - p0 } else { 0 as libc::c_int },
        );
    }
}
unsafe extern "C" fn macroblock_tree(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut num_frames: libc::c_int,
    mut b_intra: libc::c_int,
) {
    let mut idx: libc::c_int = (b_intra == 0) as libc::c_int;
    let mut last_nonb: libc::c_int = 0;
    let mut cur_nonb: libc::c_int = 1 as libc::c_int;
    let mut bframes: libc::c_int = 0 as libc::c_int;
    let mut total_duration: libc::c_float = 0.0f64 as libc::c_float;
    let mut j: libc::c_int = 0 as libc::c_int;
    while j <= num_frames {
        total_duration += (**frames.offset(j as isize)).f_duration;
        j += 1;
        j;
    }
    let mut average_duration: libc::c_float = total_duration
        / (num_frames + 1 as libc::c_int) as libc::c_float;
    let mut i: libc::c_int = num_frames;
    if b_intra != 0 {
        slicetype_frame_cost(
            h,
            a,
            frames,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        );
    }
    while i > 0 as libc::c_int
        && ((**frames.offset(i as isize)).i_type == 0x5 as libc::c_int
            || (**frames.offset(i as isize)).i_type == 0x4 as libc::c_int)
    {
        i -= 1;
        i;
    }
    last_nonb = i;
    if (*h).param.rc.i_lookahead == 0 {
        if b_intra != 0 {
            memset(
                (**frames.offset(0 as libc::c_int as isize)).i_propagate_cost
                    as *mut libc::c_void,
                0 as libc::c_int,
                ((*h).mb.i_mb_count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as libc::c_ulong),
            );
            memcpy(
                (**frames.offset(0 as libc::c_int as isize)).f_qp_offset
                    as *mut libc::c_void,
                (**frames.offset(0 as libc::c_int as isize)).f_qp_offset_aq
                    as *const libc::c_void,
                ((*h).mb.i_mb_count as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<libc::c_float>() as libc::c_ulong,
                    ),
            );
            return;
        }
        let mut t: *mut uint16_t = (**frames.offset(last_nonb as isize))
            .i_propagate_cost;
        let ref mut fresh15 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
        *fresh15 = (**frames.offset(0 as libc::c_int as isize)).i_propagate_cost;
        let ref mut fresh16 = (**frames.offset(0 as libc::c_int as isize))
            .i_propagate_cost;
        *fresh16 = t;
        memset(
            (**frames.offset(0 as libc::c_int as isize)).i_propagate_cost
                as *mut libc::c_void,
            0 as libc::c_int,
            ((*h).mb.i_mb_count as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint16_t>() as libc::c_ulong),
        );
    } else {
        if last_nonb < idx {
            return;
        }
        memset(
            (**frames.offset(last_nonb as isize)).i_propagate_cost as *mut libc::c_void,
            0 as libc::c_int,
            ((*h).mb.i_mb_count as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint16_t>() as libc::c_ulong),
        );
    }
    loop {
        let fresh17 = i;
        i = i - 1;
        if !(fresh17 > idx) {
            break;
        }
        cur_nonb = i;
        while ((**frames.offset(cur_nonb as isize)).i_type == 0x5 as libc::c_int
            || (**frames.offset(cur_nonb as isize)).i_type == 0x4 as libc::c_int)
            && cur_nonb > 0 as libc::c_int
        {
            cur_nonb -= 1;
            cur_nonb;
        }
        if cur_nonb < idx {
            break;
        }
        slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, last_nonb);
        memset(
            (**frames.offset(cur_nonb as isize)).i_propagate_cost as *mut libc::c_void,
            0 as libc::c_int,
            ((*h).mb.i_mb_count as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint16_t>() as libc::c_ulong),
        );
        bframes = last_nonb - cur_nonb - 1 as libc::c_int;
        if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as libc::c_int {
            let mut middle: libc::c_int = (bframes + 1 as libc::c_int) / 2 as libc::c_int
                + cur_nonb;
            slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, middle);
            memset(
                (**frames.offset(middle as isize)).i_propagate_cost as *mut libc::c_void,
                0 as libc::c_int,
                ((*h).mb.i_mb_count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as libc::c_ulong),
            );
            while i > cur_nonb {
                let mut p0: libc::c_int = if i > middle { middle } else { cur_nonb };
                let mut p1: libc::c_int = if i < middle { middle } else { last_nonb };
                if i != middle {
                    slicetype_frame_cost(h, a, frames, p0, p1, i);
                    macroblock_tree_propagate(
                        h,
                        frames,
                        average_duration,
                        p0,
                        p1,
                        i,
                        0 as libc::c_int,
                    );
                }
                i -= 1;
                i;
            }
            macroblock_tree_propagate(
                h,
                frames,
                average_duration,
                cur_nonb,
                last_nonb,
                middle,
                1 as libc::c_int,
            );
        } else {
            while i > cur_nonb {
                slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, i);
                macroblock_tree_propagate(
                    h,
                    frames,
                    average_duration,
                    cur_nonb,
                    last_nonb,
                    i,
                    0 as libc::c_int,
                );
                i -= 1;
                i;
            }
        }
        macroblock_tree_propagate(
            h,
            frames,
            average_duration,
            cur_nonb,
            last_nonb,
            last_nonb,
            1 as libc::c_int,
        );
        last_nonb = cur_nonb;
    }
    if (*h).param.rc.i_lookahead == 0 {
        slicetype_frame_cost(h, a, frames, 0 as libc::c_int, last_nonb, last_nonb);
        macroblock_tree_propagate(
            h,
            frames,
            average_duration,
            0 as libc::c_int,
            last_nonb,
            last_nonb,
            1 as libc::c_int,
        );
        let mut t_0: *mut uint16_t = (**frames.offset(last_nonb as isize))
            .i_propagate_cost;
        let ref mut fresh18 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
        *fresh18 = (**frames.offset(0 as libc::c_int as isize)).i_propagate_cost;
        let ref mut fresh19 = (**frames.offset(0 as libc::c_int as isize))
            .i_propagate_cost;
        *fresh19 = t_0;
    }
    macroblock_tree_finish(
        h,
        *frames.offset(last_nonb as isize),
        average_duration,
        last_nonb,
    );
    if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as libc::c_int
        && (*h).param.rc.i_vbv_buffer_size == 0
    {
        macroblock_tree_finish(
            h,
            *frames
                .offset(
                    (last_nonb + (bframes + 1 as libc::c_int) / 2 as libc::c_int)
                        as isize,
                ),
            average_duration,
            0 as libc::c_int,
        );
    }
}
unsafe extern "C" fn vbv_frame_cost(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut p0: libc::c_int,
    mut p1: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut cost: libc::c_int = slicetype_frame_cost(h, a, frames, p0, p1, b);
    if (*h).param.rc.i_aq_mode != 0 {
        if (*h).param.rc.b_mb_tree != 0 {
            return slicetype_frame_cost_recalculate(h, frames, p0, p1, b)
        } else {
            return (**frames.offset(b as isize))
                .i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize]
        }
    }
    return cost;
}
unsafe extern "C" fn calculate_durations(
    mut h: *mut x264_t,
    mut cur_frame: *mut x264_frame_t,
    mut prev_frame: *mut x264_frame_t,
    mut i_cpb_delay: *mut int64_t,
    mut i_coded_fields: *mut int64_t,
) {
    (*cur_frame).i_cpb_delay = *i_cpb_delay;
    (*cur_frame).i_dpb_output_delay = (*cur_frame).i_field_cnt - *i_coded_fields;
    (*cur_frame).i_dpb_output_delay
        += ((*((*h).sps).as_mut_ptr()).vui.i_num_reorder_frames * 2 as libc::c_int)
            as int64_t;
    if (*cur_frame).i_dpb_output_delay < 0 as libc::c_int as int64_t {
        (*cur_frame).i_cpb_delay += (*cur_frame).i_dpb_output_delay;
        (*cur_frame).i_dpb_output_delay = 0 as libc::c_int as int64_t;
        if !prev_frame.is_null() {
            (*prev_frame).i_cpb_duration += (*cur_frame).i_dpb_output_delay;
        }
    }
    if (*cur_frame).b_keyframe != 0 && (*h).param.b_intra_refresh == 0 {
        *i_cpb_delay = 0 as libc::c_int as int64_t;
    }
    *i_cpb_delay += (*cur_frame).i_duration;
    *i_coded_fields += (*cur_frame).i_duration;
    (*cur_frame).i_cpb_duration = (*cur_frame).i_duration;
}
unsafe extern "C" fn vbv_lookahead(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut num_frames: libc::c_int,
    mut keyframe: libc::c_int,
) {
    let mut last_nonb: libc::c_int = 0 as libc::c_int;
    let mut cur_nonb: libc::c_int = 1 as libc::c_int;
    let mut idx: libc::c_int = 0 as libc::c_int;
    let mut prev_frame: *mut x264_frame_t = 0 as *mut x264_frame_t;
    let mut prev_frame_idx: libc::c_int = 0 as libc::c_int;
    while cur_nonb < num_frames
        && ((**frames.offset(cur_nonb as isize)).i_type == 0x5 as libc::c_int
            || (**frames.offset(cur_nonb as isize)).i_type == 0x4 as libc::c_int)
    {
        cur_nonb += 1;
        cur_nonb;
    }
    let mut next_nonb: libc::c_int = if keyframe != 0 { last_nonb } else { cur_nonb };
    if (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead
        >= 0 as libc::c_int as int64_t
    {
        (*h)
            .i_coded_fields_lookahead = (**frames.offset(cur_nonb as isize))
            .i_coded_fields_lookahead;
        (*h)
            .i_cpb_delay_lookahead = (**frames.offset(cur_nonb as isize))
            .i_cpb_delay_lookahead;
    }
    while cur_nonb < num_frames {
        if next_nonb != cur_nonb {
            let mut p0: libc::c_int = if (**frames.offset(cur_nonb as isize)).i_type
                == 0x2 as libc::c_int
                || (**frames.offset(cur_nonb as isize)).i_type == 0x1 as libc::c_int
                || (**frames.offset(cur_nonb as isize)).i_type == 0x6 as libc::c_int
            {
                cur_nonb
            } else {
                last_nonb
            };
            (**frames.offset(next_nonb as isize))
                .i_planned_satd[idx
                as usize] = vbv_frame_cost(h, a, frames, p0, cur_nonb, cur_nonb);
            (**frames.offset(next_nonb as isize))
                .i_planned_type[idx
                as usize] = (**frames.offset(cur_nonb as isize)).i_type as uint8_t;
            (**frames.offset(cur_nonb as isize))
                .i_coded_fields_lookahead = (*h).i_coded_fields_lookahead;
            (**frames.offset(cur_nonb as isize))
                .i_cpb_delay_lookahead = (*h).i_cpb_delay_lookahead;
            calculate_durations(
                h,
                *frames.offset(cur_nonb as isize),
                prev_frame,
                &mut (*h).i_cpb_delay_lookahead,
                &mut (*h).i_coded_fields_lookahead,
            );
            if !prev_frame.is_null() {
                (**frames.offset(next_nonb as isize))
                    .f_planned_cpb_duration[prev_frame_idx
                    as usize] = (*prev_frame).i_cpb_duration as libc::c_double
                    * (*((*h).sps).as_mut_ptr()).vui.i_num_units_in_tick
                        as libc::c_double
                    / (*((*h).sps).as_mut_ptr()).vui.i_time_scale as libc::c_double;
            }
            (**frames.offset(next_nonb as isize))
                .f_planned_cpb_duration[idx
                as usize] = (**frames.offset(cur_nonb as isize)).i_cpb_duration
                as libc::c_double
                * (*((*h).sps).as_mut_ptr()).vui.i_num_units_in_tick as libc::c_double
                / (*((*h).sps).as_mut_ptr()).vui.i_time_scale as libc::c_double;
            prev_frame = *frames.offset(cur_nonb as isize);
            prev_frame_idx = idx;
            idx += 1;
            idx;
        }
        let mut i: libc::c_int = last_nonb + 1 as libc::c_int;
        while i < cur_nonb {
            (**frames.offset(next_nonb as isize))
                .i_planned_satd[idx
                as usize] = vbv_frame_cost(h, a, frames, last_nonb, cur_nonb, i);
            (**frames.offset(next_nonb as isize))
                .i_planned_type[idx as usize] = 0x5 as libc::c_int as uint8_t;
            (**frames.offset(i as isize))
                .i_coded_fields_lookahead = (*h).i_coded_fields_lookahead;
            (**frames.offset(i as isize))
                .i_cpb_delay_lookahead = (*h).i_cpb_delay_lookahead;
            calculate_durations(
                h,
                *frames.offset(i as isize),
                prev_frame,
                &mut (*h).i_cpb_delay_lookahead,
                &mut (*h).i_coded_fields_lookahead,
            );
            if !prev_frame.is_null() {
                (**frames.offset(next_nonb as isize))
                    .f_planned_cpb_duration[prev_frame_idx
                    as usize] = (*prev_frame).i_cpb_duration as libc::c_double
                    * (*((*h).sps).as_mut_ptr()).vui.i_num_units_in_tick
                        as libc::c_double
                    / (*((*h).sps).as_mut_ptr()).vui.i_time_scale as libc::c_double;
            }
            (**frames.offset(next_nonb as isize))
                .f_planned_cpb_duration[idx
                as usize] = (**frames.offset(i as isize)).i_cpb_duration
                as libc::c_double
                * (*((*h).sps).as_mut_ptr()).vui.i_num_units_in_tick as libc::c_double
                / (*((*h).sps).as_mut_ptr()).vui.i_time_scale as libc::c_double;
            prev_frame = *frames.offset(i as isize);
            prev_frame_idx = idx;
            i += 1;
            i;
            idx += 1;
            idx;
        }
        last_nonb = cur_nonb;
        cur_nonb += 1;
        cur_nonb;
        while cur_nonb <= num_frames
            && ((**frames.offset(cur_nonb as isize)).i_type == 0x5 as libc::c_int
                || (**frames.offset(cur_nonb as isize)).i_type == 0x4 as libc::c_int)
        {
            cur_nonb += 1;
            cur_nonb;
        }
    }
    (**frames.offset(next_nonb as isize))
        .i_planned_type[idx as usize] = 0 as libc::c_int as uint8_t;
}
unsafe extern "C" fn slicetype_path_cost(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut path: *mut libc::c_char,
    mut threshold: uint64_t,
) -> uint64_t {
    let mut cost: uint64_t = 0 as libc::c_int as uint64_t;
    let mut loc: libc::c_int = 1 as libc::c_int;
    let mut cur_nonb: libc::c_int = 0 as libc::c_int;
    path = path.offset(-1);
    path;
    while *path.offset(loc as isize) != 0 {
        let mut next_nonb: libc::c_int = loc;
        while *path.offset(next_nonb as isize) as libc::c_int == 'B' as i32 {
            next_nonb += 1;
            next_nonb;
        }
        if *path.offset(next_nonb as isize) as libc::c_int == 'P' as i32 {
            cost = cost
                .wrapping_add(
                    slicetype_frame_cost(h, a, frames, cur_nonb, next_nonb, next_nonb)
                        as uint64_t,
                );
        } else {
            cost = cost
                .wrapping_add(
                    slicetype_frame_cost(h, a, frames, next_nonb, next_nonb, next_nonb)
                        as uint64_t,
                );
        }
        if cost > threshold {
            break;
        }
        if (*h).param.i_bframe_pyramid != 0 && next_nonb - cur_nonb > 2 as libc::c_int {
            let mut middle: libc::c_int = cur_nonb
                + (next_nonb - cur_nonb) / 2 as libc::c_int;
            cost = cost
                .wrapping_add(
                    slicetype_frame_cost(h, a, frames, cur_nonb, next_nonb, middle)
                        as uint64_t,
                );
            let mut next_b: libc::c_int = loc;
            while next_b < middle && cost < threshold {
                cost = cost
                    .wrapping_add(
                        slicetype_frame_cost(h, a, frames, cur_nonb, middle, next_b)
                            as uint64_t,
                    );
                next_b += 1;
                next_b;
            }
            let mut next_b_0: libc::c_int = middle + 1 as libc::c_int;
            while next_b_0 < next_nonb && cost < threshold {
                cost = cost
                    .wrapping_add(
                        slicetype_frame_cost(h, a, frames, middle, next_nonb, next_b_0)
                            as uint64_t,
                    );
                next_b_0 += 1;
                next_b_0;
            }
        } else {
            let mut next_b_1: libc::c_int = loc;
            while next_b_1 < next_nonb && cost < threshold {
                cost = cost
                    .wrapping_add(
                        slicetype_frame_cost(h, a, frames, cur_nonb, next_nonb, next_b_1)
                            as uint64_t,
                    );
                next_b_1 += 1;
                next_b_1;
            }
        }
        loc = next_nonb + 1 as libc::c_int;
        cur_nonb = next_nonb;
    }
    return cost;
}
unsafe extern "C" fn slicetype_path(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut length: libc::c_int,
    mut best_paths: *mut [libc::c_char; 251],
) {
    let mut paths: [[libc::c_char; 251]; 2] = [[0; 251]; 2];
    let mut num_paths: libc::c_int = if ((*h).param.i_bframe + 1 as libc::c_int) < length
    {
        (*h).param.i_bframe + 1 as libc::c_int
    } else {
        length
    };
    let mut best_cost: uint64_t = ((1 as libc::c_ulonglong) << 60 as libc::c_int)
        as uint64_t;
    let mut best_possible: libc::c_int = 0 as libc::c_int;
    let mut idx: libc::c_int = 0 as libc::c_int;
    let mut path: libc::c_int = 0 as libc::c_int;
    while path < num_paths {
        let mut len: libc::c_int = length - (path + 1 as libc::c_int);
        memcpy(
            (paths[idx as usize]).as_mut_ptr() as *mut libc::c_void,
            (*best_paths.offset((len % (16 as libc::c_int + 1 as libc::c_int)) as isize))
                .as_mut_ptr() as *const libc::c_void,
            len as libc::c_ulong,
        );
        memset(
            (paths[idx as usize]).as_mut_ptr().offset(len as isize) as *mut libc::c_void,
            'B' as i32,
            path as libc::c_ulong,
        );
        strcpy(
            (paths[idx as usize])
                .as_mut_ptr()
                .offset(len as isize)
                .offset(path as isize),
            b"P\0" as *const u8 as *const libc::c_char,
        );
        let mut possible: libc::c_int = 1 as libc::c_int;
        let mut i: libc::c_int = 1 as libc::c_int;
        while i <= length {
            let mut i_type: libc::c_int = (**frames.offset(i as isize)).i_type;
            if !(i_type == 0 as libc::c_int) {
                if i_type == 0x5 as libc::c_int || i_type == 0x4 as libc::c_int {
                    possible = (possible != 0
                        && (i < len || i == length
                            || paths[idx as usize][(i - 1 as libc::c_int) as usize]
                                as libc::c_int == 'B' as i32)) as libc::c_int;
                } else {
                    possible = (possible != 0
                        && (i < len
                            || paths[idx as usize][(i - 1 as libc::c_int) as usize]
                                as libc::c_int != 'B' as i32)) as libc::c_int;
                    paths[idx
                        as usize][(i - 1 as libc::c_int)
                        as usize] = (if i_type == 0x2 as libc::c_int
                        || i_type == 0x1 as libc::c_int || i_type == 0x6 as libc::c_int
                    {
                        'I' as i32
                    } else {
                        'P' as i32
                    }) as libc::c_char;
                }
            }
            i += 1;
            i;
        }
        if possible != 0 || best_possible == 0 {
            if possible != 0 && best_possible == 0 {
                best_cost = ((1 as libc::c_ulonglong) << 60 as libc::c_int) as uint64_t;
            }
            let mut cost: uint64_t = slicetype_path_cost(
                h,
                a,
                frames,
                (paths[idx as usize]).as_mut_ptr(),
                best_cost,
            );
            if cost < best_cost {
                best_cost = cost;
                best_possible = possible;
                idx ^= 1 as libc::c_int;
            }
        }
        path += 1;
        path;
    }
    memcpy(
        (*best_paths.offset((length % (16 as libc::c_int + 1 as libc::c_int)) as isize))
            .as_mut_ptr() as *mut libc::c_void,
        (paths[(idx ^ 1 as libc::c_int) as usize]).as_mut_ptr() as *const libc::c_void,
        length as libc::c_ulong,
    );
}
unsafe extern "C" fn scenecut_internal(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut p0: libc::c_int,
    mut p1: libc::c_int,
    mut real_scenecut: libc::c_int,
) -> libc::c_int {
    let mut frame: *mut x264_frame_t = *frames.offset(p1 as isize);
    if real_scenecut != 0 && (*h).param.i_frame_packing == 5 as libc::c_int
        && (*frame).i_frame & 1 as libc::c_int != 0
    {
        return 0 as libc::c_int;
    }
    slicetype_frame_cost(h, a, frames, p0, p1, p1);
    let mut icost: libc::c_int = (*frame)
        .i_cost_est[0 as libc::c_int as usize][0 as libc::c_int as usize];
    let mut pcost: libc::c_int = (*frame)
        .i_cost_est[(p1 - p0) as usize][0 as libc::c_int as usize];
    let mut f_bias: libc::c_float = 0.;
    let mut i_gop_size: libc::c_int = (*frame).i_frame
        - (*(*h).lookahead).i_last_keyframe;
    let mut f_thresh_max: libc::c_float = ((*h).param.i_scenecut_threshold
        as libc::c_double / 100.0f64) as libc::c_float;
    let mut f_thresh_min: libc::c_float = (f_thresh_max as libc::c_double * 0.25f64)
        as libc::c_float;
    let mut res: libc::c_int = 0;
    if (*h).param.i_keyint_min == (*h).param.i_keyint_max {
        f_thresh_min = f_thresh_max;
    }
    if i_gop_size <= (*h).param.i_keyint_min / 4 as libc::c_int
        || (*h).param.b_intra_refresh != 0
    {
        f_bias = f_thresh_min / 4 as libc::c_int as libc::c_float;
    } else if i_gop_size <= (*h).param.i_keyint_min {
        f_bias = f_thresh_min * i_gop_size as libc::c_float
            / (*h).param.i_keyint_min as libc::c_float;
    } else {
        f_bias = f_thresh_min
            + (f_thresh_max - f_thresh_min)
                * (i_gop_size - (*h).param.i_keyint_min) as libc::c_float
                / ((*h).param.i_keyint_max - (*h).param.i_keyint_min) as libc::c_float;
    }
    res = (pcost as libc::c_double
        >= (1.0f64 - f_bias as libc::c_double) * icost as libc::c_double) as libc::c_int;
    if res != 0 && real_scenecut != 0 {
        let mut imb: libc::c_int = (*frame).i_intra_mbs[(p1 - p0) as usize];
        let mut pmb: libc::c_int = (if (*h).mb.i_mb_width > 2 as libc::c_int
            && (*h).mb.i_mb_height > 2 as libc::c_int
        {
            ((*h).mb.i_mb_width - 2 as libc::c_int)
                * ((*h).mb.i_mb_height - 2 as libc::c_int)
        } else {
            (*h).mb.i_mb_width * (*h).mb.i_mb_height
        }) - imb;
        x264_8_log(
            h,
            3 as libc::c_int,
            b"scene cut at %d Icost:%d Pcost:%d ratio:%.4f bias:%.4f gop:%d (imb:%d pmb:%d)\n\0"
                as *const u8 as *const libc::c_char,
            (*frame).i_frame,
            icost,
            pcost,
            1.0f64 - pcost as libc::c_double / icost as libc::c_double,
            f_bias as libc::c_double,
            i_gop_size,
            imb,
            pmb,
        );
    }
    return res;
}
unsafe extern "C" fn scenecut(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut frames: *mut *mut x264_frame_t,
    mut p0: libc::c_int,
    mut p1: libc::c_int,
    mut real_scenecut: libc::c_int,
    mut num_frames: libc::c_int,
    mut i_max_search: libc::c_int,
) -> libc::c_int {
    if real_scenecut != 0 && (*h).param.i_bframe != 0 {
        let mut origmaxp1: libc::c_int = p0 + 1 as libc::c_int;
        if (*h).param.i_bframe_adaptive == 2 as libc::c_int {
            origmaxp1 += (*h).param.i_bframe;
        } else {
            origmaxp1 += 1;
            origmaxp1;
        }
        let mut maxp1: libc::c_int = if origmaxp1 < num_frames {
            origmaxp1
        } else {
            num_frames
        };
        let mut curp1: libc::c_int = p1;
        while curp1 <= maxp1 {
            if scenecut_internal(h, a, frames, p0, curp1, 0 as libc::c_int) == 0 {
                let mut i: libc::c_int = curp1;
                while i > p0 {
                    (**frames.offset(i as isize)).b_scenecut = 0 as libc::c_int;
                    i -= 1;
                    i;
                }
            }
            curp1 += 1;
            curp1;
        }
        let mut curp0: libc::c_int = p0;
        while curp0 <= maxp1 {
            if origmaxp1 > i_max_search
                || curp0 < maxp1
                    && scenecut_internal(h, a, frames, curp0, maxp1, 0 as libc::c_int)
                        != 0
            {
                (**frames.offset(curp0 as isize)).b_scenecut = 0 as libc::c_int;
            }
            curp0 += 1;
            curp0;
        }
    }
    if (**frames.offset(p1 as isize)).b_scenecut == 0 {
        return 0 as libc::c_int;
    }
    return scenecut_internal(h, a, frames, p0, p1, real_scenecut);
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_slicetype_analyse(
    mut h: *mut x264_t,
    mut intra_minigop: libc::c_int,
) {
    let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
        i_lambda: 0,
        i_lambda2: 0,
        i_qp: 0,
        p_cost_mv: 0 as *mut uint16_t,
        p_cost_ref: [0 as *mut uint16_t; 2],
        i_mbrd: 0,
        b_fast_intra: 0,
        b_force_intra: 0,
        b_avoid_topright: 0,
        b_try_skip: 0,
        i_satd_i16x16: 0,
        i_satd_i16x16_dir: [0; 7],
        i_predict16x16: 0,
        i_satd_i8x8: 0,
        i_cbp_i8x8_luma: 0,
        i_satd_i8x8_dir: [[0; 16]; 4],
        i_predict8x8: [0; 4],
        i_satd_i4x4: 0,
        i_predict4x4: [0; 16],
        i_satd_pcm: 0,
        i_satd_chroma: 0,
        i_satd_chroma_dir: [0; 7],
        i_predict8x8chroma: 0,
        l0: x264_mb_analysis_list_t {
            me16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            bi16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            me8x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4],
            me4x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4]; 4],
            me8x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me4x8: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me16x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            me8x16: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            i_rd16x16: 0,
            i_cost8x8: 0,
            i_cost4x4: [0; 4],
            i_cost8x4: [0; 4],
            i_cost4x8: [0; 4],
            i_cost16x8: 0,
            i_cost8x16: 0,
            mvc: [[[0; 2]; 6]; 32],
        },
        l1: x264_mb_analysis_list_t {
            me16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            bi16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            me8x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4],
            me4x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4]; 4],
            me8x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me4x8: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me16x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            me8x16: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            i_rd16x16: 0,
            i_cost8x8: 0,
            i_cost4x4: [0; 4],
            i_cost8x4: [0; 4],
            i_cost4x8: [0; 4],
            i_cost16x8: 0,
            i_cost8x16: 0,
            mvc: [[[0; 2]; 6]; 32],
        },
        i_cost16x16bi: 0,
        i_cost16x16direct: 0,
        i_cost8x8bi: 0,
        i_cost8x8direct: [0; 4],
        i_satd8x8: [[0; 4]; 3],
        i_cost_est16x8: [0; 2],
        i_cost_est8x16: [0; 2],
        i_cost16x8bi: 0,
        i_cost8x16bi: 0,
        i_rd16x16bi: 0,
        i_rd16x16direct: 0,
        i_rd16x8bi: 0,
        i_rd8x16bi: 0,
        i_rd8x8bi: 0,
        i_mb_partition16x8: [0; 2],
        i_mb_partition8x16: [0; 2],
        i_mb_type16x8: 0,
        i_mb_type8x16: 0,
        b_direct_available: 0,
        b_early_terminate: 0,
    };
    let mut frames: [*mut x264_frame_t; 253] = [
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
        0 as *mut x264_frame_t,
    ];
    let mut num_frames: libc::c_int = 0;
    let mut orig_num_frames: libc::c_int = 0;
    let mut keyint_limit: libc::c_int = 0;
    let mut framecnt: libc::c_int = 0;
    let mut i_max_search: libc::c_int = if (*(*h).lookahead).next.i_size
        < 250 as libc::c_int
    {
        (*(*h).lookahead).next.i_size
    } else {
        250 as libc::c_int
    };
    let mut b_vbv_lookahead: libc::c_int = ((*h).param.rc.i_vbv_buffer_size != 0
        && (*h).param.rc.i_lookahead != 0) as libc::c_int;
    if (*h).param.b_deterministic != 0 {
        i_max_search = if i_max_search
            < (*(*h).lookahead).i_slicetype_length + 1 as libc::c_int - intra_minigop
        {
            i_max_search
        } else {
            (*(*h).lookahead).i_slicetype_length + 1 as libc::c_int - intra_minigop
        };
    }
    let mut keyframe: libc::c_int = (intra_minigop != 0) as libc::c_int;
    if (*h).frames.b_have_lowres != 0 {} else {
        __assert_fail(
            b"h->frames.b_have_lowres\0" as *const u8 as *const libc::c_char,
            b"encoder/slicetype.c\0" as *const u8 as *const libc::c_char,
            1488 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 45],
                &[libc::c_char; 45],
            >(b"void x264_8_slicetype_analyse(x264_t *, int)\0"))
                .as_ptr(),
        );
    }
    'c_125276: {
        if (*h).frames.b_have_lowres != 0 {} else {
            __assert_fail(
                b"h->frames.b_have_lowres\0" as *const u8 as *const libc::c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const libc::c_char,
                1488 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 45],
                    &[libc::c_char; 45],
                >(b"void x264_8_slicetype_analyse(x264_t *, int)\0"))
                    .as_ptr(),
            );
        }
    };
    if ((*(*h).lookahead).last_nonb).is_null() {
        return;
    }
    frames[0 as libc::c_int as usize] = (*(*h).lookahead).last_nonb;
    framecnt = 0 as libc::c_int;
    while framecnt < i_max_search {
        frames[(framecnt + 1 as libc::c_int)
            as usize] = *((*(*h).lookahead).next.list).offset(framecnt as isize);
        framecnt += 1;
        framecnt;
    }
    lowres_context_init(h, &mut a);
    if framecnt == 0 {
        if (*h).param.rc.b_mb_tree != 0 {
            macroblock_tree(h, &mut a, frames.as_mut_ptr(), 0 as libc::c_int, keyframe);
        }
        return;
    }
    keyint_limit = (*h).param.i_keyint_max - (*frames[0 as libc::c_int as usize]).i_frame
        + (*(*h).lookahead).i_last_keyframe - 1 as libc::c_int;
    num_frames = if (*h).param.b_intra_refresh != 0 {
        framecnt
    } else if framecnt < keyint_limit {
        framecnt
    } else {
        keyint_limit
    };
    orig_num_frames = num_frames;
    if (*h).param.analyse.b_psy != 0 && (*h).param.rc.b_mb_tree != 0
        || b_vbv_lookahead != 0
    {
        num_frames = framecnt;
    } else if (*h).param.b_open_gop != 0 && num_frames < framecnt {
        num_frames += 1;
        num_frames;
    } else if num_frames == 0 as libc::c_int {
        (*frames[1 as libc::c_int as usize]).i_type = 0x2 as libc::c_int;
        return;
    }
    if ((*frames[1 as libc::c_int as usize]).i_type == 0 as libc::c_int
        || ((*frames[1 as libc::c_int as usize]).i_type == 0x2 as libc::c_int
            || (*frames[1 as libc::c_int as usize]).i_type == 0x1 as libc::c_int
            || (*frames[1 as libc::c_int as usize]).i_type == 0x6 as libc::c_int))
        && (*h).param.i_scenecut_threshold != 0
        && scenecut(
            h,
            &mut a,
            frames.as_mut_ptr(),
            0 as libc::c_int,
            1 as libc::c_int,
            1 as libc::c_int,
            orig_num_frames,
            i_max_search,
        ) != 0
    {
        if (*frames[1 as libc::c_int as usize]).i_type == 0 as libc::c_int {
            (*frames[1 as libc::c_int as usize]).i_type = 0x2 as libc::c_int;
        }
        return;
    }
    x264_8_opencl_slicetype_prep(h, frames.as_mut_ptr(), num_frames, a.i_lambda);
    let mut j: libc::c_int = 1 as libc::c_int;
    while j <= num_frames {
        if (*frames[j as usize]).i_type == 0x6 as libc::c_int {
            (*frames[j as usize])
                .i_type = if (*h).param.b_open_gop != 0 {
                0x2 as libc::c_int
            } else {
                0x1 as libc::c_int
            };
        }
        j += 1;
        j;
    }
    let mut j_0: libc::c_int = 2 as libc::c_int;
    while j_0 <= num_frames {
        if (*frames[j_0 as usize]).i_type == 0x1 as libc::c_int
            && ((*frames[(j_0 - 1 as libc::c_int) as usize]).i_type == 0 as libc::c_int
                || ((*frames[(j_0 - 1 as libc::c_int) as usize]).i_type
                    == 0x5 as libc::c_int
                    || (*frames[(j_0 - 1 as libc::c_int) as usize]).i_type
                        == 0x4 as libc::c_int))
        {
            (*frames[(j_0 - 1 as libc::c_int) as usize]).i_type = 0x3 as libc::c_int;
        }
        j_0 += 1;
        j_0;
    }
    let mut num_analysed_frames: libc::c_int = num_frames;
    let mut reset_start: libc::c_int = 0;
    if (*h).param.i_bframe != 0 {
        if (*h).param.i_bframe_adaptive == 2 as libc::c_int {
            if num_frames > 1 as libc::c_int {
                let mut best_paths: [[libc::c_char; 251]; 17] = [
                    *::core::mem::transmute::<
                        &[u8; 251],
                        &mut [libc::c_char; 251],
                    >(
                        b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                    ),
                    *::core::mem::transmute::<
                        &[u8; 251],
                        &mut [libc::c_char; 251],
                    >(
                        b"P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                    ),
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                    [0; 251],
                ];
                let mut best_path_index: libc::c_int = num_frames
                    % (16 as libc::c_int + 1 as libc::c_int);
                let mut j_1: libc::c_int = 2 as libc::c_int;
                while j_1 <= num_frames {
                    slicetype_path(
                        h,
                        &mut a,
                        frames.as_mut_ptr(),
                        j_1,
                        best_paths.as_mut_ptr(),
                    );
                    j_1 += 1;
                    j_1;
                }
                let mut j_2: libc::c_int = 1 as libc::c_int;
                while j_2 < num_frames {
                    if best_paths[best_path_index
                        as usize][(j_2 - 1 as libc::c_int) as usize] as libc::c_int
                        != 'B' as i32
                    {
                        if (*frames[j_2 as usize]).i_type == 0 as libc::c_int
                            || ((*frames[j_2 as usize]).i_type == 0x5 as libc::c_int
                                || (*frames[j_2 as usize]).i_type == 0x4 as libc::c_int)
                        {
                            (*frames[j_2 as usize]).i_type = 0x3 as libc::c_int;
                        }
                    } else if (*frames[j_2 as usize]).i_type == 0 as libc::c_int {
                        (*frames[j_2 as usize]).i_type = 0x5 as libc::c_int;
                    }
                    j_2 += 1;
                    j_2;
                }
            }
        } else if (*h).param.i_bframe_adaptive == 1 as libc::c_int {
            let mut last_nonb: libc::c_int = 0 as libc::c_int;
            let mut num_bframes: libc::c_int = (*h).param.i_bframe;
            let mut path: [libc::c_char; 251] = [0; 251];
            let mut j_3: libc::c_int = 1 as libc::c_int;
            while j_3 < num_frames {
                if j_3 - 1 as libc::c_int > 0 as libc::c_int
                    && ((*frames[(j_3 - 1 as libc::c_int) as usize]).i_type
                        == 0x5 as libc::c_int
                        || (*frames[(j_3 - 1 as libc::c_int) as usize]).i_type
                            == 0x4 as libc::c_int)
                {
                    num_bframes -= 1;
                    num_bframes;
                } else {
                    last_nonb = j_3 - 1 as libc::c_int;
                    num_bframes = (*h).param.i_bframe;
                }
                if num_bframes == 0 {
                    if (*frames[j_3 as usize]).i_type == 0 as libc::c_int
                        || ((*frames[j_3 as usize]).i_type == 0x5 as libc::c_int
                            || (*frames[j_3 as usize]).i_type == 0x4 as libc::c_int)
                    {
                        (*frames[j_3 as usize]).i_type = 0x3 as libc::c_int;
                    }
                } else if !((*frames[j_3 as usize]).i_type != 0 as libc::c_int) {
                    if (*frames[(j_3 + 1 as libc::c_int) as usize]).i_type
                        == 0x5 as libc::c_int
                        || (*frames[(j_3 + 1 as libc::c_int) as usize]).i_type
                            == 0x4 as libc::c_int
                    {
                        (*frames[j_3 as usize]).i_type = 0x3 as libc::c_int;
                    } else {
                        let mut bframes: libc::c_int = j_3 - last_nonb
                            - 1 as libc::c_int;
                        memset(
                            path.as_mut_ptr() as *mut libc::c_void,
                            'B' as i32,
                            bframes as libc::c_ulong,
                        );
                        strcpy(
                            path.as_mut_ptr().offset(bframes as isize),
                            b"PP\0" as *const u8 as *const libc::c_char,
                        );
                        let mut cost_p: uint64_t = slicetype_path_cost(
                            h,
                            &mut a,
                            frames.as_mut_ptr().offset(last_nonb as isize),
                            path.as_mut_ptr(),
                            ((1 as libc::c_ulonglong) << 60 as libc::c_int) as uint64_t,
                        );
                        strcpy(
                            path.as_mut_ptr().offset(bframes as isize),
                            b"BP\0" as *const u8 as *const libc::c_char,
                        );
                        let mut cost_b: uint64_t = slicetype_path_cost(
                            h,
                            &mut a,
                            frames.as_mut_ptr().offset(last_nonb as isize),
                            path.as_mut_ptr(),
                            cost_p,
                        );
                        if cost_b < cost_p {
                            (*frames[j_3 as usize]).i_type = 0x5 as libc::c_int;
                        } else {
                            (*frames[j_3 as usize]).i_type = 0x3 as libc::c_int;
                        }
                    }
                }
                j_3 += 1;
                j_3;
            }
        } else {
            let mut num_bframes_0: libc::c_int = (*h).param.i_bframe;
            let mut j_4: libc::c_int = 1 as libc::c_int;
            while j_4 < num_frames {
                if num_bframes_0 == 0 {
                    if (*frames[j_4 as usize]).i_type == 0 as libc::c_int
                        || ((*frames[j_4 as usize]).i_type == 0x5 as libc::c_int
                            || (*frames[j_4 as usize]).i_type == 0x4 as libc::c_int)
                    {
                        (*frames[j_4 as usize]).i_type = 0x3 as libc::c_int;
                    }
                } else if (*frames[j_4 as usize]).i_type == 0 as libc::c_int {
                    if (*frames[(j_4 + 1 as libc::c_int) as usize]).i_type
                        == 0x5 as libc::c_int
                        || (*frames[(j_4 + 1 as libc::c_int) as usize]).i_type
                            == 0x4 as libc::c_int
                    {
                        (*frames[j_4 as usize]).i_type = 0x3 as libc::c_int;
                    } else {
                        (*frames[j_4 as usize]).i_type = 0x5 as libc::c_int;
                    }
                }
                if (*frames[j_4 as usize]).i_type == 0x5 as libc::c_int
                    || (*frames[j_4 as usize]).i_type == 0x4 as libc::c_int
                {
                    num_bframes_0 -= 1;
                    num_bframes_0;
                } else {
                    num_bframes_0 = (*h).param.i_bframe;
                }
                j_4 += 1;
                j_4;
            }
        }
        if (*frames[num_frames as usize]).i_type == 0 as libc::c_int
            || ((*frames[num_frames as usize]).i_type == 0x5 as libc::c_int
                || (*frames[num_frames as usize]).i_type == 0x4 as libc::c_int)
        {
            (*frames[num_frames as usize]).i_type = 0x3 as libc::c_int;
        }
        let mut num_bframes_1: libc::c_int = 0 as libc::c_int;
        while num_bframes_1 < num_frames
            && ((*frames[(num_bframes_1 + 1 as libc::c_int) as usize]).i_type
                == 0x5 as libc::c_int
                || (*frames[(num_bframes_1 + 1 as libc::c_int) as usize]).i_type
                    == 0x4 as libc::c_int)
        {
            num_bframes_1 += 1;
            num_bframes_1;
        }
        let mut j_5: libc::c_int = 1 as libc::c_int;
        while j_5 < num_bframes_1 + 1 as libc::c_int {
            if (*frames[j_5 as usize]).i_forced_type == 0 as libc::c_int
                && ((*frames[(j_5 + 1 as libc::c_int) as usize]).i_forced_type
                    == 0 as libc::c_int
                    || ((*frames[(j_5 + 1 as libc::c_int) as usize]).i_forced_type
                        == 0x2 as libc::c_int
                        || (*frames[(j_5 + 1 as libc::c_int) as usize]).i_forced_type
                            == 0x1 as libc::c_int
                        || (*frames[(j_5 + 1 as libc::c_int) as usize]).i_forced_type
                            == 0x6 as libc::c_int))
                && (*h).param.i_scenecut_threshold != 0
                && scenecut(
                    h,
                    &mut a,
                    frames.as_mut_ptr(),
                    j_5,
                    j_5 + 1 as libc::c_int,
                    0 as libc::c_int,
                    orig_num_frames,
                    i_max_search,
                ) != 0
            {
                (*frames[j_5 as usize]).i_type = 0x3 as libc::c_int;
                num_analysed_frames = j_5;
                break;
            } else {
                j_5 += 1;
                j_5;
            }
        }
        reset_start = if keyframe != 0 {
            1 as libc::c_int
        } else if (num_bframes_1 + 2 as libc::c_int)
            < num_analysed_frames + 1 as libc::c_int
        {
            num_bframes_1 + 2 as libc::c_int
        } else {
            num_analysed_frames + 1 as libc::c_int
        };
    } else {
        let mut j_6: libc::c_int = 1 as libc::c_int;
        while j_6 <= num_frames {
            if (*frames[j_6 as usize]).i_type == 0 as libc::c_int
                || ((*frames[j_6 as usize]).i_type == 0x5 as libc::c_int
                    || (*frames[j_6 as usize]).i_type == 0x4 as libc::c_int)
            {
                (*frames[j_6 as usize]).i_type = 0x3 as libc::c_int;
            }
            j_6 += 1;
            j_6;
        }
        reset_start = (keyframe == 0) as libc::c_int + 1 as libc::c_int;
    }
    if (*h).param.rc.b_mb_tree != 0 {
        macroblock_tree(
            h,
            &mut a,
            frames.as_mut_ptr(),
            if num_frames < (*h).param.i_keyint_max {
                num_frames
            } else {
                (*h).param.i_keyint_max
            },
            keyframe,
        );
    }
    if (*h).param.b_intra_refresh == 0 {
        let mut last_keyframe: libc::c_int = (*(*h).lookahead).i_last_keyframe;
        let mut last_possible: libc::c_int = 0 as libc::c_int;
        let mut j_7: libc::c_int = 1 as libc::c_int;
        while j_7 <= num_frames {
            let mut frm: *mut x264_frame_t = frames[j_7 as usize];
            let mut keyframe_dist: libc::c_int = (*frm).i_frame - last_keyframe;
            if (*frm).i_forced_type == 0 as libc::c_int
                || ((*frm).i_forced_type == 0x2 as libc::c_int
                    || (*frm).i_forced_type == 0x1 as libc::c_int
                    || (*frm).i_forced_type == 0x6 as libc::c_int)
            {
                if (*h).param.b_open_gop != 0
                    || !((*frames[(j_7 - 1 as libc::c_int) as usize]).i_forced_type
                        == 0x5 as libc::c_int
                        || (*frames[(j_7 - 1 as libc::c_int) as usize]).i_forced_type
                            == 0x4 as libc::c_int)
                {
                    last_possible = j_7;
                }
            }
            if keyframe_dist >= (*h).param.i_keyint_max {
                if last_possible != 0 as libc::c_int && last_possible != j_7 {
                    j_7 = last_possible;
                    frm = frames[j_7 as usize];
                    keyframe_dist = (*frm).i_frame - last_keyframe;
                }
                last_possible = 0 as libc::c_int;
                if (*frm).i_type != 0x1 as libc::c_int {
                    (*frm)
                        .i_type = if (*h).param.b_open_gop != 0 {
                        0x2 as libc::c_int
                    } else {
                        0x1 as libc::c_int
                    };
                }
            }
            if (*frm).i_type == 0x2 as libc::c_int
                && keyframe_dist >= (*h).param.i_keyint_min
            {
                if (*h).param.b_open_gop != 0 {
                    last_keyframe = (*frm).i_frame;
                    if (*h).param.b_bluray_compat != 0 {
                        let mut bframes_0: libc::c_int = 0 as libc::c_int;
                        while bframes_0 < j_7 - 1 as libc::c_int
                            && ((*frames[(j_7 - 1 as libc::c_int - bframes_0) as usize])
                                .i_type == 0x5 as libc::c_int
                                || (*frames[(j_7 - 1 as libc::c_int - bframes_0) as usize])
                                    .i_type == 0x4 as libc::c_int)
                        {
                            bframes_0 += 1;
                            bframes_0;
                        }
                        last_keyframe -= bframes_0;
                    }
                } else if (*frm).i_forced_type != 0x2 as libc::c_int {
                    (*frm).i_type = 0x1 as libc::c_int;
                }
            }
            if (*frm).i_type == 0x1 as libc::c_int {
                last_keyframe = (*frm).i_frame;
                if j_7 > 1 as libc::c_int
                    && ((*frames[(j_7 - 1 as libc::c_int) as usize]).i_type
                        == 0x5 as libc::c_int
                        || (*frames[(j_7 - 1 as libc::c_int) as usize]).i_type
                            == 0x4 as libc::c_int)
                {
                    (*frames[(j_7 - 1 as libc::c_int) as usize])
                        .i_type = 0x3 as libc::c_int;
                }
            }
            j_7 += 1;
            j_7;
        }
    }
    if b_vbv_lookahead != 0 {
        vbv_lookahead(h, &mut a, frames.as_mut_ptr(), num_frames, keyframe);
    }
    let mut j_8: libc::c_int = reset_start;
    while j_8 <= num_frames {
        (*frames[j_8 as usize]).i_type = (*frames[j_8 as usize]).i_forced_type;
        j_8 += 1;
        j_8;
    }
    x264_8_opencl_slicetype_end(h);
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_slicetype_decide(mut h: *mut x264_t) {
    let mut frames: [*mut x264_frame_t; 18] = [0 as *mut x264_frame_t; 18];
    let mut frm: *mut x264_frame_t = 0 as *mut x264_frame_t;
    let mut bframes: libc::c_int = 0;
    let mut brefs: libc::c_int = 0;
    if (*(*h).lookahead).next.i_size == 0 {
        return;
    }
    let mut lookahead_size: libc::c_int = (*(*h).lookahead).next.i_size;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < (*(*h).lookahead).next.i_size {
        if (*h).param.b_vfr_input != 0 {
            let fresh20 = lookahead_size;
            lookahead_size = lookahead_size - 1;
            if fresh20 > 1 as libc::c_int {
                (**((*(*h).lookahead).next.list).offset(i as isize))
                    .i_duration = 2 as libc::c_int as int64_t
                    * ((**((*(*h).lookahead).next.list)
                        .offset((i + 1 as libc::c_int) as isize))
                        .i_pts
                        - (**((*(*h).lookahead).next.list).offset(i as isize)).i_pts);
            } else {
                (**((*(*h).lookahead).next.list).offset(i as isize))
                    .i_duration = (*h).i_prev_duration;
            }
        } else {
            (**((*(*h).lookahead).next.list).offset(i as isize))
                .i_duration = delta_tfi_divisor[(**((*(*h).lookahead).next.list)
                .offset(i as isize))
                .i_pic_struct as usize] as int64_t;
        }
        (*h)
            .i_prev_duration = (**((*(*h).lookahead).next.list).offset(i as isize))
            .i_duration;
        (**((*(*h).lookahead).next.list).offset(i as isize))
            .f_duration = ((**((*(*h).lookahead).next.list).offset(i as isize))
            .i_duration as libc::c_double
            * (*((*h).sps).as_mut_ptr()).vui.i_num_units_in_tick as libc::c_double
            / (*((*h).sps).as_mut_ptr()).vui.i_time_scale as libc::c_double)
            as libc::c_float;
        if (**((*(*h).lookahead).next.list).offset(i as isize)).i_frame
            > (*h).i_disp_fields_last_frame && lookahead_size > 0 as libc::c_int
        {
            (**((*(*h).lookahead).next.list).offset(i as isize))
                .i_field_cnt = (*h).i_disp_fields;
            (*h).i_disp_fields
                += (**((*(*h).lookahead).next.list).offset(i as isize)).i_duration;
            (*h)
                .i_disp_fields_last_frame = (**((*(*h).lookahead).next.list)
                .offset(i as isize))
                .i_frame;
        } else if lookahead_size == 0 as libc::c_int {
            (**((*(*h).lookahead).next.list).offset(i as isize))
                .i_field_cnt = (*h).i_disp_fields;
            (**((*(*h).lookahead).next.list).offset(i as isize))
                .i_duration = (*h).i_prev_duration;
        }
        i += 1;
        i;
    }
    if (*h).param.rc.b_stat_read != 0 {
        let mut i_0: libc::c_int = 0 as libc::c_int;
        while i_0 < (*(*h).lookahead).next.i_size {
            (**((*(*h).lookahead).next.list).offset(i_0 as isize))
                .i_type = x264_8_ratecontrol_slice_type(
                h,
                (**((*(*h).lookahead).next.list).offset(i_0 as isize)).i_frame,
            );
            i_0 += 1;
            i_0;
        }
    } else if (*h).param.i_bframe != 0 && (*h).param.i_bframe_adaptive != 0
        || (*h).param.i_scenecut_threshold != 0 || (*h).param.rc.b_mb_tree != 0
        || (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0
    {
        x264_8_slicetype_analyse(h, 0 as libc::c_int);
    }
    bframes = 0 as libc::c_int;
    brefs = 0 as libc::c_int;
    loop {
        frm = *((*(*h).lookahead).next.list).offset(bframes as isize);
        if (*frm).i_forced_type != 0 as libc::c_int
            && (*frm).i_type != (*frm).i_forced_type
            && !((*frm).i_forced_type == 0x6 as libc::c_int
                && ((*frm).i_type == 0x2 as libc::c_int
                    || (*frm).i_type == 0x1 as libc::c_int
                    || (*frm).i_type == 0x6 as libc::c_int))
        {
            x264_8_log(
                h,
                1 as libc::c_int,
                b"forced frame type (%d) at %d was changed to frame type (%d)\n\0"
                    as *const u8 as *const libc::c_char,
                (*frm).i_forced_type,
                (*frm).i_frame,
                (*frm).i_type,
            );
        }
        if (*frm).i_type == 0x4 as libc::c_int
            && (*h).param.i_bframe_pyramid < 2 as libc::c_int
            && brefs == (*h).param.i_bframe_pyramid
        {
            (*frm).i_type = 0x5 as libc::c_int;
            x264_8_log(
                h,
                1 as libc::c_int,
                b"B-ref at frame %d incompatible with B-pyramid %s \n\0" as *const u8
                    as *const libc::c_char,
                (*frm).i_frame,
                x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
            );
        } else if (*frm).i_type == 0x4 as libc::c_int
            && (*h).param.i_bframe_pyramid == 2 as libc::c_int && brefs != 0
            && (*h).param.i_frame_reference <= brefs + 3 as libc::c_int
        {
            (*frm).i_type = 0x5 as libc::c_int;
            x264_8_log(
                h,
                1 as libc::c_int,
                b"B-ref at frame %d incompatible with B-pyramid %s and %d reference frames\n\0"
                    as *const u8 as *const libc::c_char,
                (*frm).i_frame,
                x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
                (*h).param.i_frame_reference,
            );
        }
        if (*frm).i_type == 0x6 as libc::c_int {
            (*frm)
                .i_type = if (*h).param.b_open_gop != 0 {
                0x2 as libc::c_int
            } else {
                0x1 as libc::c_int
            };
        }
        if ((*h).param.b_intra_refresh == 0 || (*frm).i_frame == 0 as libc::c_int)
            && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe
                >= (*h).param.i_keyint_max
        {
            if (*frm).i_type == 0 as libc::c_int || (*frm).i_type == 0x2 as libc::c_int {
                (*frm)
                    .i_type = if (*h).param.b_open_gop != 0
                    && (*(*h).lookahead).i_last_keyframe >= 0 as libc::c_int
                {
                    0x2 as libc::c_int
                } else {
                    0x1 as libc::c_int
                };
            }
            let mut warn: libc::c_int = ((*frm).i_type != 0x1 as libc::c_int)
                as libc::c_int;
            if warn != 0 && (*h).param.b_open_gop != 0 {
                warn &= ((*frm).i_type != 0x2 as libc::c_int) as libc::c_int;
            }
            if warn != 0 {
                x264_8_log(
                    h,
                    1 as libc::c_int,
                    b"specified frame type (%d) at %d is not compatible with keyframe interval\n\0"
                        as *const u8 as *const libc::c_char,
                    (*frm).i_type,
                    (*frm).i_frame,
                );
                (*frm)
                    .i_type = if (*h).param.b_open_gop != 0
                    && (*(*h).lookahead).i_last_keyframe >= 0 as libc::c_int
                {
                    0x2 as libc::c_int
                } else {
                    0x1 as libc::c_int
                };
            }
        }
        if (*frm).i_type == 0x2 as libc::c_int
            && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe
                >= (*h).param.i_keyint_min
        {
            if (*h).param.b_open_gop != 0 {
                (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
                if (*h).param.b_bluray_compat != 0 {
                    (*(*h).lookahead).i_last_keyframe -= bframes;
                }
                (*frm).b_keyframe = 1 as libc::c_int;
            } else {
                (*frm).i_type = 0x1 as libc::c_int;
            }
        }
        if (*frm).i_type == 0x1 as libc::c_int {
            (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
            (*frm).b_keyframe = 1 as libc::c_int;
            if bframes > 0 as libc::c_int {
                bframes -= 1;
                bframes;
                (**((*(*h).lookahead).next.list).offset(bframes as isize))
                    .i_type = 0x3 as libc::c_int;
            }
        }
        if bframes == (*h).param.i_bframe
            || (*((*(*h).lookahead).next.list)
                .offset((bframes + 1 as libc::c_int) as isize))
                .is_null()
        {
            if (*frm).i_type == 0x5 as libc::c_int || (*frm).i_type == 0x4 as libc::c_int
            {
                x264_8_log(
                    h,
                    1 as libc::c_int,
                    b"specified frame type is not compatible with max B-frames\n\0"
                        as *const u8 as *const libc::c_char,
                );
            }
            if (*frm).i_type == 0 as libc::c_int
                || ((*frm).i_type == 0x5 as libc::c_int
                    || (*frm).i_type == 0x4 as libc::c_int)
            {
                (*frm).i_type = 0x3 as libc::c_int;
            }
        }
        if (*frm).i_type == 0x4 as libc::c_int {
            brefs += 1;
            brefs;
        }
        if (*frm).i_type == 0 as libc::c_int {
            (*frm).i_type = 0x5 as libc::c_int;
        } else if !((*frm).i_type == 0x5 as libc::c_int
            || (*frm).i_type == 0x4 as libc::c_int)
        {
            break;
        }
        bframes += 1;
        bframes;
    }
    if bframes != 0 {
        (**((*(*h).lookahead).next.list).offset((bframes - 1 as libc::c_int) as isize))
            .b_last_minigop_bframe = 1 as libc::c_int as uint8_t;
    }
    (**((*(*h).lookahead).next.list).offset(bframes as isize))
        .i_bframes = bframes as uint8_t;
    if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as libc::c_int && brefs == 0 {
        (**((*(*h).lookahead).next.list)
            .offset(((bframes - 1 as libc::c_int) / 2 as libc::c_int) as isize))
            .i_type = 0x4 as libc::c_int;
        brefs += 1;
        brefs;
    }
    if (*h).param.rc.i_rc_method != 0 as libc::c_int {
        let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
            i_lambda: 0,
            i_lambda2: 0,
            i_qp: 0,
            p_cost_mv: 0 as *mut uint16_t,
            p_cost_ref: [0 as *mut uint16_t; 2],
            i_mbrd: 0,
            b_fast_intra: 0,
            b_force_intra: 0,
            b_avoid_topright: 0,
            b_try_skip: 0,
            i_satd_i16x16: 0,
            i_satd_i16x16_dir: [0; 7],
            i_predict16x16: 0,
            i_satd_i8x8: 0,
            i_cbp_i8x8_luma: 0,
            i_satd_i8x8_dir: [[0; 16]; 4],
            i_predict8x8: [0; 4],
            i_satd_i4x4: 0,
            i_predict4x4: [0; 16],
            i_satd_pcm: 0,
            i_satd_chroma: 0,
            i_satd_chroma_dir: [0; 7],
            i_predict8x8chroma: 0,
            l0: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            l1: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            i_cost16x16bi: 0,
            i_cost16x16direct: 0,
            i_cost8x8bi: 0,
            i_cost8x8direct: [0; 4],
            i_satd8x8: [[0; 4]; 3],
            i_cost_est16x8: [0; 2],
            i_cost_est8x16: [0; 2],
            i_cost16x8bi: 0,
            i_cost8x16bi: 0,
            i_rd16x16bi: 0,
            i_rd16x16direct: 0,
            i_rd16x8bi: 0,
            i_rd8x16bi: 0,
            i_rd8x8bi: 0,
            i_mb_partition16x8: [0; 2],
            i_mb_partition8x16: [0; 2],
            i_mb_type16x8: 0,
            i_mb_type8x16: 0,
            b_direct_available: 0,
            b_early_terminate: 0,
        };
        let mut p0: libc::c_int = 0;
        let mut p1: libc::c_int = 0;
        let mut b: libc::c_int = 0;
        b = bframes + 1 as libc::c_int;
        p1 = b;
        lowres_context_init(h, &mut a);
        frames[0 as libc::c_int as usize] = (*(*h).lookahead).last_nonb;
        memcpy(
            &mut *frames.as_mut_ptr().offset(1 as libc::c_int as isize)
                as *mut *mut x264_frame_t as *mut libc::c_void,
            (*(*h).lookahead).next.list as *const libc::c_void,
            ((bframes + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut x264_frame_t>() as libc::c_ulong,
                ),
        );
        if (**((*(*h).lookahead).next.list).offset(bframes as isize)).i_type
            == 0x2 as libc::c_int
            || (**((*(*h).lookahead).next.list).offset(bframes as isize)).i_type
                == 0x1 as libc::c_int
            || (**((*(*h).lookahead).next.list).offset(bframes as isize)).i_type
                == 0x6 as libc::c_int
        {
            p0 = bframes + 1 as libc::c_int;
        } else {
            p0 = 0 as libc::c_int;
        }
        slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
        if (p0 != p1 || bframes != 0) && (*h).param.rc.i_vbv_buffer_size != 0 {
            slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), b, b, b);
            p0 = 0 as libc::c_int;
            b = 1 as libc::c_int;
            while b <= bframes {
                if (*frames[b as usize]).i_type == 0x5 as libc::c_int {
                    p1 = b;
                    while (*frames[p1 as usize]).i_type == 0x5 as libc::c_int {
                        p1 += 1;
                        p1;
                    }
                } else {
                    p1 = bframes + 1 as libc::c_int;
                }
                slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
                if (*frames[b as usize]).i_type == 0x4 as libc::c_int {
                    p0 = b;
                }
                b += 1;
                b;
            }
        }
    }
    if (*h).param.rc.b_stat_read == 0
        && (**((*(*h).lookahead).next.list).offset(bframes as isize)).i_type
            == 0x3 as libc::c_int
        && (*h).param.analyse.i_weighted_pred >= 1 as libc::c_int
    {
        x264_8_weights_analyse(
            h,
            *((*(*h).lookahead).next.list).offset(bframes as isize),
            (*(*h).lookahead).last_nonb,
            0 as libc::c_int,
        );
    }
    let mut i_coded: libc::c_int = (**((*(*h).lookahead).next.list)
        .offset(0 as libc::c_int as isize))
        .i_frame;
    if bframes != 0 {
        let mut idx_list: [libc::c_int; 2] = [
            brefs + 1 as libc::c_int,
            1 as libc::c_int,
        ];
        let mut i_1: libc::c_int = 0 as libc::c_int;
        while i_1 < bframes {
            let fresh21 = idx_list[((**((*(*h).lookahead).next.list)
                .offset(i_1 as isize))
                .i_type == 0x4 as libc::c_int) as libc::c_int as usize];
            idx_list[((**((*(*h).lookahead).next.list).offset(i_1 as isize)).i_type
                == 0x4 as libc::c_int) as libc::c_int
                as usize] = idx_list[((**((*(*h).lookahead).next.list)
                .offset(i_1 as isize))
                .i_type == 0x4 as libc::c_int) as libc::c_int as usize] + 1;
            let mut idx: libc::c_int = fresh21;
            frames[idx as usize] = *((*(*h).lookahead).next.list).offset(i_1 as isize);
            (*frames[idx as usize])
                .i_reordered_pts = (**((*(*h).lookahead).next.list).offset(idx as isize))
                .i_pts;
            i_1 += 1;
            i_1;
        }
        frames[0 as libc::c_int
            as usize] = *((*(*h).lookahead).next.list).offset(bframes as isize);
        (*frames[0 as libc::c_int as usize])
            .i_reordered_pts = (**((*(*h).lookahead).next.list)
            .offset(0 as libc::c_int as isize))
            .i_pts;
        memcpy(
            (*(*h).lookahead).next.list as *mut libc::c_void,
            frames.as_mut_ptr() as *const libc::c_void,
            ((bframes + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut x264_frame_t>() as libc::c_ulong,
                ),
        );
    }
    let mut i_2: libc::c_int = 0 as libc::c_int;
    while i_2 <= bframes {
        let fresh22 = i_coded;
        i_coded = i_coded + 1;
        (**((*(*h).lookahead).next.list).offset(i_2 as isize)).i_coded = fresh22;
        if i_2 != 0 {
            calculate_durations(
                h,
                *((*(*h).lookahead).next.list).offset(i_2 as isize),
                *((*(*h).lookahead).next.list).offset((i_2 - 1 as libc::c_int) as isize),
                &mut (*h).i_cpb_delay,
                &mut (*h).i_coded_fields,
            );
            (**((*(*h).lookahead).next.list).offset(0 as libc::c_int as isize))
                .f_planned_cpb_duration[(i_2 - 1 as libc::c_int)
                as usize] = (**((*(*h).lookahead).next.list).offset(i_2 as isize))
                .i_cpb_duration as libc::c_double
                * (*((*h).sps).as_mut_ptr()).vui.i_num_units_in_tick as libc::c_double
                / (*((*h).sps).as_mut_ptr()).vui.i_time_scale as libc::c_double;
        } else {
            calculate_durations(
                h,
                *((*(*h).lookahead).next.list).offset(i_2 as isize),
                0 as *mut x264_frame_t,
                &mut (*h).i_cpb_delay,
                &mut (*h).i_coded_fields,
            );
        }
        i_2 += 1;
        i_2;
    }
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_rc_analyse_slice(mut h: *mut x264_t) -> libc::c_int {
    let mut p0: libc::c_int = 0 as libc::c_int;
    let mut p1: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut cost: libc::c_int = 0;
    if (*(*h).fenc).i_type == 0x2 as libc::c_int
        || (*(*h).fenc).i_type == 0x1 as libc::c_int
        || (*(*h).fenc).i_type == 0x6 as libc::c_int
    {
        b = 0 as libc::c_int;
        p1 = b;
    } else if (*(*h).fenc).i_type == 0x3 as libc::c_int {
        b = (*(*h).fenc).i_bframes as libc::c_int + 1 as libc::c_int;
        p1 = b;
    } else {
        p1 = ((*(*h).fref_nearest[1 as libc::c_int as usize]).i_poc
            - (*(*h).fref_nearest[0 as libc::c_int as usize]).i_poc) / 2 as libc::c_int;
        b = ((*(*h).fenc).i_poc - (*(*h).fref_nearest[0 as libc::c_int as usize]).i_poc)
            / 2 as libc::c_int;
    }
    let mut frames: *mut *mut x264_frame_t = (&mut (*h).fenc as *mut *mut x264_frame_t)
        .offset(-(b as isize));
    cost = (**frames.offset(b as isize))
        .i_cost_est[(b - p0) as usize][(p1 - b) as usize];
    if cost >= 0 as libc::c_int {} else {
        __assert_fail(
            b"cost >= 0\0" as *const u8 as *const libc::c_char,
            b"encoder/slicetype.c\0" as *const u8 as *const libc::c_char,
            1996 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 38],
                &[libc::c_char; 38],
            >(b"int x264_8_rc_analyse_slice(x264_t *)\0"))
                .as_ptr(),
        );
    }
    'c_55506: {
        if cost >= 0 as libc::c_int {} else {
            __assert_fail(
                b"cost >= 0\0" as *const u8 as *const libc::c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const libc::c_char,
                1996 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 38],
                    &[libc::c_char; 38],
                >(b"int x264_8_rc_analyse_slice(x264_t *)\0"))
                    .as_ptr(),
            );
        }
    };
    if (*h).param.rc.b_mb_tree != 0 && (*h).param.rc.b_stat_read == 0 {
        cost = slicetype_frame_cost_recalculate(h, frames, p0, p1, b);
        if b != 0 && (*h).param.rc.i_vbv_buffer_size != 0 {
            slicetype_frame_cost_recalculate(h, frames, b, b, b);
        }
    } else if (*h).param.rc.i_aq_mode != 0 {
        cost = (**frames.offset(b as isize))
            .i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize];
    }
    (*(*h).fenc)
        .i_row_satd = (*(*h).fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
    (*(*h).fdec)
        .i_row_satd = (*(*h).fdec).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
    (*(*h).fdec).i_satd = cost;
    memcpy(
        (*(*h).fdec).i_row_satd as *mut libc::c_void,
        (*(*h).fenc).i_row_satd as *const libc::c_void,
        ((*h).mb.i_mb_height as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    if !((*(*h).fenc).i_type == 0x2 as libc::c_int
        || (*(*h).fenc).i_type == 0x1 as libc::c_int
        || (*(*h).fenc).i_type == 0x6 as libc::c_int)
    {
        memcpy(
            (*(*h).fdec)
                .i_row_satds[0 as libc::c_int as usize][0 as libc::c_int as usize]
                as *mut libc::c_void,
            (*(*h).fenc)
                .i_row_satds[0 as libc::c_int as usize][0 as libc::c_int as usize]
                as *const libc::c_void,
            ((*h).mb.i_mb_height as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
    }
    if (*h).param.b_intra_refresh != 0 && (*h).param.rc.i_vbv_buffer_size != 0
        && (*(*h).fenc).i_type == 0x3 as libc::c_int
    {
        let mut ip_factor: libc::c_int = (256 as libc::c_int as libc::c_float
            * (*h).param.rc.f_ip_factor) as libc::c_int;
        let mut y: libc::c_int = 0 as libc::c_int;
        while y < (*h).mb.i_mb_height {
            let mut mb_xy: libc::c_int = y * (*h).mb.i_mb_stride
                + (*(*h).fdec).i_pir_start_col;
            let mut x: libc::c_int = (*(*h).fdec).i_pir_start_col;
            while x <= (*(*h).fdec).i_pir_end_col {
                let mut intra_cost: libc::c_int = *((*(*h).fenc).i_intra_cost)
                    .offset(mb_xy as isize) as libc::c_int * ip_factor
                    + 128 as libc::c_int >> 8 as libc::c_int;
                let mut inter_cost: libc::c_int = *((*(*h).fenc)
                    .lowres_costs[(b - p0) as usize][(p1 - b) as usize])
                    .offset(mb_xy as isize) as libc::c_int
                    & ((1 as libc::c_int) << 14 as libc::c_int) - 1 as libc::c_int;
                let mut diff: libc::c_int = intra_cost - inter_cost;
                if (*h).param.rc.i_aq_mode != 0 {
                    *((*(*h).fdec).i_row_satd).offset(y as isize)
                        += diff
                            * *((**frames.offset(b as isize)).i_inv_qscale_factor)
                                .offset(mb_xy as isize) as libc::c_int + 128 as libc::c_int
                            >> 8 as libc::c_int;
                } else {
                    *((*(*h).fdec).i_row_satd).offset(y as isize) += diff;
                }
                cost += diff;
                x += 1;
                x;
                mb_xy += 1;
                mb_xy;
            }
            y += 1;
            y;
        }
    }
    return cost;
}
static mut cbp_to_golomb: [[[uint8_t; 48]; 2]; 2] = [
    [
        [
            0 as libc::c_int as uint8_t,
            1 as libc::c_int as uint8_t,
            2 as libc::c_int as uint8_t,
            5 as libc::c_int as uint8_t,
            3 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            14 as libc::c_int as uint8_t,
            10 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            15 as libc::c_int as uint8_t,
            7 as libc::c_int as uint8_t,
            11 as libc::c_int as uint8_t,
            8 as libc::c_int as uint8_t,
            12 as libc::c_int as uint8_t,
            13 as libc::c_int as uint8_t,
            9 as libc::c_int as uint8_t,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ],
        [
            1 as libc::c_int as uint8_t,
            10 as libc::c_int as uint8_t,
            11 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            12 as libc::c_int as uint8_t,
            7 as libc::c_int as uint8_t,
            14 as libc::c_int as uint8_t,
            2 as libc::c_int as uint8_t,
            13 as libc::c_int as uint8_t,
            15 as libc::c_int as uint8_t,
            8 as libc::c_int as uint8_t,
            3 as libc::c_int as uint8_t,
            9 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            5 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ],
    ],
    [
        [
            0 as libc::c_int as uint8_t,
            2 as libc::c_int as uint8_t,
            3 as libc::c_int as uint8_t,
            7 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            8 as libc::c_int as uint8_t,
            17 as libc::c_int as uint8_t,
            13 as libc::c_int as uint8_t,
            5 as libc::c_int as uint8_t,
            18 as libc::c_int as uint8_t,
            9 as libc::c_int as uint8_t,
            14 as libc::c_int as uint8_t,
            10 as libc::c_int as uint8_t,
            15 as libc::c_int as uint8_t,
            16 as libc::c_int as uint8_t,
            11 as libc::c_int as uint8_t,
            1 as libc::c_int as uint8_t,
            32 as libc::c_int as uint8_t,
            33 as libc::c_int as uint8_t,
            36 as libc::c_int as uint8_t,
            34 as libc::c_int as uint8_t,
            37 as libc::c_int as uint8_t,
            44 as libc::c_int as uint8_t,
            40 as libc::c_int as uint8_t,
            35 as libc::c_int as uint8_t,
            45 as libc::c_int as uint8_t,
            38 as libc::c_int as uint8_t,
            41 as libc::c_int as uint8_t,
            39 as libc::c_int as uint8_t,
            42 as libc::c_int as uint8_t,
            43 as libc::c_int as uint8_t,
            19 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            24 as libc::c_int as uint8_t,
            25 as libc::c_int as uint8_t,
            20 as libc::c_int as uint8_t,
            26 as libc::c_int as uint8_t,
            21 as libc::c_int as uint8_t,
            46 as libc::c_int as uint8_t,
            28 as libc::c_int as uint8_t,
            27 as libc::c_int as uint8_t,
            47 as libc::c_int as uint8_t,
            22 as libc::c_int as uint8_t,
            29 as libc::c_int as uint8_t,
            23 as libc::c_int as uint8_t,
            30 as libc::c_int as uint8_t,
            31 as libc::c_int as uint8_t,
            12 as libc::c_int as uint8_t,
        ],
        [
            3 as libc::c_int as uint8_t,
            29 as libc::c_int as uint8_t,
            30 as libc::c_int as uint8_t,
            17 as libc::c_int as uint8_t,
            31 as libc::c_int as uint8_t,
            18 as libc::c_int as uint8_t,
            37 as libc::c_int as uint8_t,
            8 as libc::c_int as uint8_t,
            32 as libc::c_int as uint8_t,
            38 as libc::c_int as uint8_t,
            19 as libc::c_int as uint8_t,
            9 as libc::c_int as uint8_t,
            20 as libc::c_int as uint8_t,
            10 as libc::c_int as uint8_t,
            11 as libc::c_int as uint8_t,
            2 as libc::c_int as uint8_t,
            16 as libc::c_int as uint8_t,
            33 as libc::c_int as uint8_t,
            34 as libc::c_int as uint8_t,
            21 as libc::c_int as uint8_t,
            35 as libc::c_int as uint8_t,
            22 as libc::c_int as uint8_t,
            39 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            36 as libc::c_int as uint8_t,
            40 as libc::c_int as uint8_t,
            23 as libc::c_int as uint8_t,
            5 as libc::c_int as uint8_t,
            24 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            7 as libc::c_int as uint8_t,
            1 as libc::c_int as uint8_t,
            41 as libc::c_int as uint8_t,
            42 as libc::c_int as uint8_t,
            43 as libc::c_int as uint8_t,
            25 as libc::c_int as uint8_t,
            44 as libc::c_int as uint8_t,
            26 as libc::c_int as uint8_t,
            46 as libc::c_int as uint8_t,
            12 as libc::c_int as uint8_t,
            45 as libc::c_int as uint8_t,
            47 as libc::c_int as uint8_t,
            27 as libc::c_int as uint8_t,
            13 as libc::c_int as uint8_t,
            28 as libc::c_int as uint8_t,
            14 as libc::c_int as uint8_t,
            15 as libc::c_int as uint8_t,
            0 as libc::c_int as uint8_t,
        ],
    ],
];
static mut mb_type_b_to_golomb: [[uint8_t; 9]; 3] = [
    [
        4 as libc::c_int as uint8_t,
        8 as libc::c_int as uint8_t,
        12 as libc::c_int as uint8_t,
        10 as libc::c_int as uint8_t,
        6 as libc::c_int as uint8_t,
        14 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        18 as libc::c_int as uint8_t,
        20 as libc::c_int as uint8_t,
    ],
    [
        5 as libc::c_int as uint8_t,
        9 as libc::c_int as uint8_t,
        13 as libc::c_int as uint8_t,
        11 as libc::c_int as uint8_t,
        7 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
        17 as libc::c_int as uint8_t,
        19 as libc::c_int as uint8_t,
        21 as libc::c_int as uint8_t,
    ],
    [
        1 as libc::c_int as uint8_t,
        -(1 as libc::c_int) as uint8_t,
        -(1 as libc::c_int) as uint8_t,
        -(1 as libc::c_int) as uint8_t,
        2 as libc::c_int as uint8_t,
        -(1 as libc::c_int) as uint8_t,
        -(1 as libc::c_int) as uint8_t,
        -(1 as libc::c_int) as uint8_t,
        3 as libc::c_int as uint8_t,
    ],
];
static mut subpartition_p_to_golomb: [uint8_t; 4] = [
    3 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
];
static mut subpartition_b_to_golomb: [uint8_t; 13] = [
    10 as libc::c_int as uint8_t,
    4 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    11 as libc::c_int as uint8_t,
    6 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    12 as libc::c_int as uint8_t,
    8 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
];
#[inline]
unsafe extern "C" fn cavlc_block_residual_escape(
    mut h: *mut x264_t,
    mut i_suffix_length: libc::c_int,
    mut level: libc::c_int,
) -> libc::c_int {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    static mut next_suffix: [uint16_t; 7] = [
        0 as libc::c_int as uint16_t,
        3 as libc::c_int as uint16_t,
        6 as libc::c_int as uint16_t,
        12 as libc::c_int as uint16_t,
        24 as libc::c_int as uint16_t,
        48 as libc::c_int as uint16_t,
        0xffff as libc::c_int as uint16_t,
    ];
    let mut i_level_prefix: libc::c_int = 15 as libc::c_int;
    let mut mask: libc::c_int = level >> 31 as libc::c_int;
    let mut abs_level: libc::c_int = (level ^ mask) - mask;
    let mut i_level_code: libc::c_int = abs_level * 2 as libc::c_int - mask
        - 2 as libc::c_int;
    if i_level_code >> i_suffix_length < 15 as libc::c_int {
        (*s).i_bits_encoded
            += (i_level_code >> i_suffix_length) + 1 as libc::c_int + i_suffix_length;
    } else {
        i_level_code -= (15 as libc::c_int) << i_suffix_length;
        if i_suffix_length == 0 as libc::c_int {
            i_level_code -= 15 as libc::c_int;
        }
        if i_level_code >= (1 as libc::c_int) << 12 as libc::c_int {
            if (*((*h).sps).as_mut_ptr()).i_profile_idc >= PROFILE_HIGH as libc::c_int {
                while i_level_code
                    >= (1 as libc::c_int) << i_level_prefix - 3 as libc::c_int
                {
                    i_level_code
                        -= (1 as libc::c_int) << i_level_prefix - 3 as libc::c_int;
                    i_level_prefix += 1;
                    i_level_prefix;
                }
            } else {
                (*s).i_bits_encoded += 2000 as libc::c_int;
            }
        }
        (*s).i_bits_encoded += i_level_prefix + 1 as libc::c_int;
        (*s).i_bits_encoded += i_level_prefix - 3 as libc::c_int;
    }
    if i_suffix_length == 0 as libc::c_int {
        i_suffix_length += 1;
        i_suffix_length;
    }
    if abs_level > next_suffix[i_suffix_length as usize] as libc::c_int {
        i_suffix_length += 1;
        i_suffix_length;
    }
    return i_suffix_length;
}
unsafe extern "C" fn cavlc_block_residual_internal(
    mut h: *mut x264_t,
    mut ctx_block_cat: libc::c_int,
    mut l: *mut dctcoef,
    mut nC: libc::c_int,
) -> libc::c_int {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    static mut ctz_index: [uint8_t; 8] = [
        3 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        2 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        1 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
    ];
    static mut count_cat: [uint8_t; 14] = [
        16 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
        64 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        64 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
        16 as libc::c_int as uint8_t,
        64 as libc::c_int as uint8_t,
    ];
    let mut runlevel: x264_run_level_t = x264_run_level_t {
        last: 0,
        mask: 0,
        level: [0; 18],
    };
    let mut i_total: libc::c_int = 0;
    let mut i_trailing: libc::c_int = 0;
    let mut i_total_zero: libc::c_int = 0;
    let mut i_suffix_length: libc::c_int = 0;
    let mut i_sign: libc::c_uint = 0;
    i_total = ((*h).quantf.coeff_level_run[ctx_block_cat as usize])
        .expect("non-null function pointer")(l, &mut runlevel);
    &mut *x264_8_run_before.as_mut_ptr().offset(runlevel.mask as isize) as *mut uint32_t;
    i_total_zero = runlevel.last + 1 as libc::c_int - i_total;
    runlevel.level[(i_total + 0 as libc::c_int) as usize] = 2 as libc::c_int as dctcoef;
    runlevel.level[(i_total + 1 as libc::c_int) as usize] = 2 as libc::c_int as dctcoef;
    i_trailing = (runlevel.level[0 as libc::c_int as usize] as libc::c_int
        + 1 as libc::c_int
        | 1 as libc::c_int - runlevel.level[0 as libc::c_int as usize] as libc::c_int)
        >> 31 as libc::c_int & 1 as libc::c_int
        | (runlevel.level[1 as libc::c_int as usize] as libc::c_int + 1 as libc::c_int
            | 1 as libc::c_int
                - runlevel.level[1 as libc::c_int as usize] as libc::c_int)
            >> 31 as libc::c_int & 2 as libc::c_int
        | (runlevel.level[2 as libc::c_int as usize] as libc::c_int + 1 as libc::c_int
            | 1 as libc::c_int
                - runlevel.level[2 as libc::c_int as usize] as libc::c_int)
            >> 31 as libc::c_int & 4 as libc::c_int;
    i_trailing = ctz_index[i_trailing as usize] as libc::c_int;
    i_sign = (runlevel.level[2 as libc::c_int as usize] as libc::c_int
        >> 31 as libc::c_int & 1 as libc::c_int
        | runlevel.level[1 as libc::c_int as usize] as libc::c_int >> 31 as libc::c_int
            & 2 as libc::c_int
        | runlevel.level[0 as libc::c_int as usize] as libc::c_int >> 31 as libc::c_int
            & 4 as libc::c_int) as libc::c_uint;
    i_sign >>= 3 as libc::c_int - i_trailing;
    (*s).i_bits_encoded
        += x264_coeff_token[nC
                as usize][(i_total - 1 as libc::c_int) as usize][i_trailing as usize]
            .i_size as libc::c_int;
    i_suffix_length = (i_total > 10 as libc::c_int && i_trailing < 3 as libc::c_int)
        as libc::c_int;
    (*s).i_bits_encoded += i_trailing;
    if i_trailing < i_total {
        let mut val: libc::c_int = runlevel.level[i_trailing as usize] as libc::c_int;
        let mut val_original: libc::c_int = runlevel.level[i_trailing as usize]
            as libc::c_int + 128 as libc::c_int / 2 as libc::c_int;
        val
            -= (val >> 31 as libc::c_int | 1 as libc::c_int)
                & -((i_trailing < 3 as libc::c_int) as libc::c_int);
        val += 128 as libc::c_int / 2 as libc::c_int;
        if (val_original as libc::c_uint) < 128 as libc::c_int as libc::c_uint {
            (*s).i_bits_encoded
                += x264_8_level_token[i_suffix_length as usize][val as usize].i_size
                    as libc::c_int;
            i_suffix_length = x264_8_level_token[i_suffix_length
                    as usize][val_original as usize]
                .i_next as libc::c_int;
        } else {
            i_suffix_length = cavlc_block_residual_escape(
                h,
                i_suffix_length,
                val - 128 as libc::c_int / 2 as libc::c_int,
            );
        }
        let mut i: libc::c_int = i_trailing + 1 as libc::c_int;
        while i < i_total {
            val = runlevel.level[i as usize] as libc::c_int
                + 128 as libc::c_int / 2 as libc::c_int;
            if (val as libc::c_uint) < 128 as libc::c_int as libc::c_uint {
                (*s).i_bits_encoded
                    += x264_8_level_token[i_suffix_length as usize][val as usize].i_size
                        as libc::c_int;
                i_suffix_length = x264_8_level_token[i_suffix_length
                        as usize][val as usize]
                    .i_next as libc::c_int;
            } else {
                i_suffix_length = cavlc_block_residual_escape(
                    h,
                    i_suffix_length,
                    val - 128 as libc::c_int / 2 as libc::c_int,
                );
            }
            i += 1;
            i;
        }
    }
    if ctx_block_cat == DCT_CHROMA_DC as libc::c_int {
        if i_total < 8 as libc::c_int >> (*h).mb.chroma_v_shift {
            let mut total_zeros: vlc_t = if (*((*h).sps).as_mut_ptr())
                .i_chroma_format_idc == CHROMA_420 as libc::c_int
            {
                x264_total_zeros_2x2_dc[(i_total - 1 as libc::c_int)
                    as usize][i_total_zero as usize]
            } else {
                x264_total_zeros_2x4_dc[(i_total - 1 as libc::c_int)
                    as usize][i_total_zero as usize]
            };
            (*s).i_bits_encoded += total_zeros.i_size as libc::c_int;
        }
    } else if (i_total as uint8_t as libc::c_int)
        < count_cat[ctx_block_cat as usize] as libc::c_int
    {
        (*s).i_bits_encoded
            += x264_total_zeros[(i_total - 1 as libc::c_int)
                    as usize][i_total_zero as usize]
                .i_size as libc::c_int;
    }
    let mut zero_run_code: libc::c_int = x264_8_run_before[runlevel.mask as usize]
        as libc::c_int;
    (*s).i_bits_encoded += zero_run_code & 0x1f as libc::c_int;
    return i_total;
}
static mut ct_index: [uint8_t; 17] = [
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
];
unsafe extern "C" fn cavlc_qp_delta(mut h: *mut x264_t) {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    let mut i_dqp: libc::c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
    if (*h).mb.i_type == I_16x16 as libc::c_int
        && (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma == 0
        && (*h).mb.cache.non_zero_count[x264_scan8[48 as libc::c_int as usize] as usize]
            == 0
        && (*h)
            .mb
            .cache
            .non_zero_count[x264_scan8[(49 as libc::c_int + 0 as libc::c_int) as usize]
            as usize] == 0
        && (*h)
            .mb
            .cache
            .non_zero_count[x264_scan8[(49 as libc::c_int + 1 as libc::c_int) as usize]
            as usize] == 0 && (*h).mb.i_qp > (*h).mb.i_last_qp
    {
        i_dqp = 0 as libc::c_int;
    }
    if i_dqp != 0 {
        if i_dqp
            < -(51 as libc::c_int
                + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                + 1 as libc::c_int) / 2 as libc::c_int
        {
            i_dqp
                += 51 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                    + 1 as libc::c_int;
        } else if i_dqp
            > (51 as libc::c_int
                + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int))
                / 2 as libc::c_int
        {
            i_dqp
                -= 51 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                    + 1 as libc::c_int;
        }
    }
    (*s).i_bits_encoded += bs_size_se(i_dqp);
}
unsafe extern "C" fn cavlc_mvd(
    mut h: *mut x264_t,
    mut i_list: libc::c_int,
    mut idx: libc::c_int,
    mut width: libc::c_int,
) {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    let mut mvp: [int16_t; 2] = [0; 2];
    x264_8_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
    (*s).i_bits_encoded
        += bs_size_se(
            (*h)
                .mb
                .cache
                .mv[i_list
                as usize][x264_scan8[idx as usize] as usize][0 as libc::c_int as usize]
                as libc::c_int - mvp[0 as libc::c_int as usize] as libc::c_int,
        );
    (*s).i_bits_encoded
        += bs_size_se(
            (*h)
                .mb
                .cache
                .mv[i_list
                as usize][x264_scan8[idx as usize] as usize][1 as libc::c_int as usize]
                as libc::c_int - mvp[1 as libc::c_int as usize] as libc::c_int,
        );
}
#[inline]
unsafe extern "C" fn cavlc_8x8_mvd(mut h: *mut x264_t, mut i: libc::c_int) {
    match (*h).mb.i_sub_partition[i as usize] as libc::c_int {
        3 => {
            cavlc_mvd(h, 0 as libc::c_int, 4 as libc::c_int * i, 2 as libc::c_int);
        }
        1 => {
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 0 as libc::c_int,
                2 as libc::c_int,
            );
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 2 as libc::c_int,
                2 as libc::c_int,
            );
        }
        2 => {
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 0 as libc::c_int,
                1 as libc::c_int,
            );
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 1 as libc::c_int,
                1 as libc::c_int,
            );
        }
        0 => {
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 0 as libc::c_int,
                1 as libc::c_int,
            );
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 1 as libc::c_int,
                1 as libc::c_int,
            );
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 2 as libc::c_int,
                1 as libc::c_int,
            );
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i + 3 as libc::c_int,
                1 as libc::c_int,
            );
        }
        _ => {}
    };
}
#[inline(always)]
unsafe extern "C" fn cavlc_macroblock_luma_residual(
    mut h: *mut x264_t,
    mut plane_count: libc::c_int,
) {
    if (*h).mb.b_transform_8x8 != 0 {
        let mut p: libc::c_int = 0 as libc::c_int;
        while p < plane_count {
            let mut i8: libc::c_int = 0 as libc::c_int;
            while i8 < 4 as libc::c_int {
                if (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(p * 16 as libc::c_int
                    + i8 * 4 as libc::c_int) as usize] as usize] != 0
                {
                    ((*h).zigzagf.interleave_8x8_cavlc)
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*h)
                            .dct
                            .luma4x4[(p * 16 as libc::c_int + i8 * 4 as libc::c_int)
                            as usize])
                            .as_mut_ptr(),
                        ((*h).dct.luma8x8[(p * 4 as libc::c_int + i8) as usize])
                            .as_mut_ptr(),
                        &mut *((*h).mb.cache.non_zero_count)
                            .as_mut_ptr()
                            .offset(
                                *x264_scan8
                                    .as_ptr()
                                    .offset(
                                        (p * 16 as libc::c_int + i8 * 4 as libc::c_int) as isize,
                                    ) as isize,
                            ),
                    );
                }
                i8 += 1;
                i8;
            }
            p += 1;
            p;
        }
    }
    let mut p_0: libc::c_int = 0 as libc::c_int;
    while p_0 < plane_count {
        let mut i8_0: libc::c_int = 0 as libc::c_int;
        let mut msk: libc::c_int = (*h).mb.i_cbp_luma;
        let mut skip: libc::c_int = 0;
        while msk != 0
            && {
                skip = x264_ctz_4bit(msk as uint32_t);
                i8_0 += skip;
                msk >>= skip + 1 as libc::c_int;
                1 as libc::c_int != 0
            }
        {
            let mut i4: libc::c_int = 0 as libc::c_int;
            while i4 < 4 as libc::c_int {
                let mut nC: libc::c_int = if DCT_LUMA_4x4 as libc::c_int
                    == DCT_CHROMA_DC as libc::c_int
                {
                    5 as libc::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as libc::c_int == DCT_LUMA_DC as libc::c_int {
                            (i4 + i8_0 * 4 as libc::c_int + p_0 * 16 as libc::c_int
                                - 48 as libc::c_int) * 16 as libc::c_int
                        } else {
                            i4 + i8_0 * 4 as libc::c_int + p_0 * 16 as libc::c_int
                        },
                    ) as usize] as libc::c_int
                };
                let mut nnz: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8
                            .as_ptr()
                            .offset(
                                (i4 + i8_0 * 4 as libc::c_int + p_0 * 16 as libc::c_int)
                                    as isize,
                            ) as isize,
                    ) as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded
                        += x264_coeff0_token[nC as usize].i_size as libc::c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_4x4 as libc::c_int,
                        ((*h)
                            .dct
                            .luma4x4[(i4 + i8_0 * 4 as libc::c_int
                            + p_0 * 16 as libc::c_int) as usize])
                            .as_mut_ptr(),
                        nC,
                    ) as uint8_t;
                }
                i4 += 1;
                i4;
            }
            i8_0 += 1;
            i8_0;
        }
        p_0 += 1;
        p_0;
    }
}
#[inline(always)]
unsafe extern "C" fn cavlc_partition_luma_residual(
    mut h: *mut x264_t,
    mut i8: libc::c_int,
    mut p: libc::c_int,
) {
    if (*h).mb.b_transform_8x8 != 0
        && (*h)
            .mb
            .cache
            .non_zero_count[x264_scan8[(i8 * 4 as libc::c_int + p * 16 as libc::c_int)
            as usize] as usize] as libc::c_int != 0
    {
        ((*h).zigzagf.interleave_8x8_cavlc)
            .expect(
                "non-null function pointer",
            )(
            ((*h).dct.luma4x4[(i8 * 4 as libc::c_int + p * 16 as libc::c_int) as usize])
                .as_mut_ptr(),
            ((*h).dct.luma8x8[(i8 + p * 4 as libc::c_int) as usize]).as_mut_ptr(),
            &mut *((*h).mb.cache.non_zero_count)
                .as_mut_ptr()
                .offset(
                    *x264_scan8
                        .as_ptr()
                        .offset((i8 * 4 as libc::c_int + p * 16 as libc::c_int) as isize)
                        as isize,
                ),
        );
    }
    if (*h).mb.i_cbp_luma & (1 as libc::c_int) << i8 != 0 {
        let mut i4: libc::c_int = 0 as libc::c_int;
        while i4 < 4 as libc::c_int {
            let mut nC: libc::c_int = if DCT_LUMA_4x4 as libc::c_int
                == DCT_CHROMA_DC as libc::c_int
            {
                5 as libc::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_LUMA_4x4 as libc::c_int == DCT_LUMA_DC as libc::c_int {
                        (i4 + i8 * 4 as libc::c_int + p * 16 as libc::c_int
                            - 48 as libc::c_int) * 16 as libc::c_int
                    } else {
                        i4 + i8 * 4 as libc::c_int + p * 16 as libc::c_int
                    },
                ) as usize] as libc::c_int
            };
            let mut nnz: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                .as_mut_ptr()
                .offset(
                    *x264_scan8
                        .as_ptr()
                        .offset(
                            (i4 + i8 * 4 as libc::c_int + p * 16 as libc::c_int) as isize,
                        ) as isize,
                ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded
                    += x264_coeff0_token[nC as usize].i_size as libc::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as libc::c_int,
                    ((*h)
                        .dct
                        .luma4x4[(i4 + i8 * 4 as libc::c_int + p * 16 as libc::c_int)
                        as usize])
                        .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            i4 += 1;
            i4;
        }
    }
}
unsafe extern "C" fn cavlc_mb_header_i(
    mut h: *mut x264_t,
    mut i_mb_type: libc::c_int,
    mut i_mb_i_offset: libc::c_int,
    mut chroma: libc::c_int,
) {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    if i_mb_type == I_16x16 as libc::c_int {
        (*s).i_bits_encoded
            += bs_size_ue(
                (i_mb_i_offset + 1 as libc::c_int
                    + x264_mb_pred_mode16x16_fix[(*h).mb.i_intra16x16_pred_mode as usize]
                        as libc::c_int + (*h).mb.i_cbp_chroma * 4 as libc::c_int
                    + (if (*h).mb.i_cbp_luma == 0 as libc::c_int {
                        0 as libc::c_int
                    } else {
                        12 as libc::c_int
                    })) as libc::c_uint,
            );
    } else {
        let mut di: libc::c_int = if i_mb_type == I_8x8 as libc::c_int {
            4 as libc::c_int
        } else {
            1 as libc::c_int
        };
        (*s).i_bits_encoded
            += bs_size_ue((i_mb_i_offset + 0 as libc::c_int) as libc::c_uint);
        if (*((*h).pps).as_mut_ptr()).b_transform_8x8_mode != 0 {
            (*s).i_bits_encoded += 1 as libc::c_int;
        }
        let mut i: libc::c_int = 0 as libc::c_int;
        while i < 16 as libc::c_int {
            let mut i_pred: libc::c_int = x264_mb_predict_intra4x4_mode(h, i);
            let mut i_mode: libc::c_int = x264_mb_pred_mode4x4_fix[((*h)
                .mb
                .cache
                .intra4x4_pred_mode[x264_scan8[i as usize] as usize] as libc::c_int
                + 1 as libc::c_int) as usize] as libc::c_int;
            if i_pred == i_mode {
                (*s).i_bits_encoded += 1 as libc::c_int;
            } else {
                (*s).i_bits_encoded += 4 as libc::c_int;
            }
            i += di;
        }
    }
    if chroma != 0 {
        (*s).i_bits_encoded
            += bs_size_ue(
                x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize]
                    as libc::c_uint,
            );
    }
}
#[inline(always)]
unsafe extern "C" fn cavlc_mb_header_p(
    mut h: *mut x264_t,
    mut i_mb_type: libc::c_int,
    mut chroma: libc::c_int,
) {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    if i_mb_type == P_L0 as libc::c_int {
        if (*h).mb.i_partition == D_16x16 as libc::c_int {
            (*s).i_bits_encoded += 1 as libc::c_int;
            if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
                (*s).i_bits_encoded
                    += bs_size_te(
                        (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            cavlc_mvd(h, 0 as libc::c_int, 0 as libc::c_int, 4 as libc::c_int);
        } else if (*h).mb.i_partition == D_16x8 as libc::c_int {
            (*s).i_bits_encoded += bs_size_ue(1 as libc::c_int as libc::c_uint);
            if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
                (*s).i_bits_encoded
                    += bs_size_te(
                        (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
                (*s).i_bits_encoded
                    += bs_size_te(
                        (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[8 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            cavlc_mvd(h, 0 as libc::c_int, 0 as libc::c_int, 4 as libc::c_int);
            cavlc_mvd(h, 0 as libc::c_int, 8 as libc::c_int, 4 as libc::c_int);
        } else if (*h).mb.i_partition == D_8x16 as libc::c_int {
            (*s).i_bits_encoded += bs_size_ue(2 as libc::c_int as libc::c_uint);
            if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
                (*s).i_bits_encoded
                    += bs_size_te(
                        (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
                (*s).i_bits_encoded
                    += bs_size_te(
                        (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[4 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            cavlc_mvd(h, 0 as libc::c_int, 0 as libc::c_int, 2 as libc::c_int);
            cavlc_mvd(h, 0 as libc::c_int, 4 as libc::c_int, 2 as libc::c_int);
        }
    } else if i_mb_type == P_8x8 as libc::c_int {
        let mut b_sub_ref: libc::c_int = 0;
        if (*h)
            .mb
            .cache
            .ref_0[0 as libc::c_int
            as usize][x264_scan8[0 as libc::c_int as usize] as usize] as libc::c_int
            | (*h)
                .mb
                .cache
                .ref_0[0 as libc::c_int
                as usize][x264_scan8[4 as libc::c_int as usize] as usize] as libc::c_int
            | (*h)
                .mb
                .cache
                .ref_0[0 as libc::c_int
                as usize][x264_scan8[8 as libc::c_int as usize] as usize] as libc::c_int
            | (*h)
                .mb
                .cache
                .ref_0[0 as libc::c_int
                as usize][x264_scan8[12 as libc::c_int as usize] as usize] as libc::c_int
            == 0 as libc::c_int
        {
            (*s).i_bits_encoded += bs_size_ue(4 as libc::c_int as libc::c_uint);
            b_sub_ref = 0 as libc::c_int;
        } else {
            (*s).i_bits_encoded += bs_size_ue(3 as libc::c_int as libc::c_uint);
            b_sub_ref = 1 as libc::c_int;
        }
        if (*h).param.analyse.inter & 0x20 as libc::c_uint != 0 {
            let mut i: libc::c_int = 0 as libc::c_int;
            while i < 4 as libc::c_int {
                (*s).i_bits_encoded
                    += bs_size_ue(
                        subpartition_p_to_golomb[(*h).mb.i_sub_partition[i as usize]
                            as usize] as libc::c_uint,
                    );
                i += 1;
                i;
            }
        } else {
            (*s).i_bits_encoded += 4 as libc::c_int;
        }
        if b_sub_ref != 0 {
            (*s).i_bits_encoded
                += bs_size_te(
                    (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                    (*h)
                        .mb
                        .cache
                        .ref_0[0 as libc::c_int
                        as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                        as libc::c_int,
                );
            (*s).i_bits_encoded
                += bs_size_te(
                    (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                    (*h)
                        .mb
                        .cache
                        .ref_0[0 as libc::c_int
                        as usize][x264_scan8[4 as libc::c_int as usize] as usize]
                        as libc::c_int,
                );
            (*s).i_bits_encoded
                += bs_size_te(
                    (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                    (*h)
                        .mb
                        .cache
                        .ref_0[0 as libc::c_int
                        as usize][x264_scan8[8 as libc::c_int as usize] as usize]
                        as libc::c_int,
                );
            (*s).i_bits_encoded
                += bs_size_te(
                    (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
                    (*h)
                        .mb
                        .cache
                        .ref_0[0 as libc::c_int
                        as usize][x264_scan8[12 as libc::c_int as usize] as usize]
                        as libc::c_int,
                );
        }
        let mut i_0: libc::c_int = 0 as libc::c_int;
        while i_0 < 4 as libc::c_int {
            cavlc_8x8_mvd(h, i_0);
            i_0 += 1;
            i_0;
        }
    } else {
        cavlc_mb_header_i(h, i_mb_type, 5 as libc::c_int, chroma);
    };
}
#[inline(always)]
unsafe extern "C" fn cavlc_mb_header_b(
    mut h: *mut x264_t,
    mut i_mb_type: libc::c_int,
    mut chroma: libc::c_int,
) {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    if i_mb_type == B_8x8 as libc::c_int {
        (*s).i_bits_encoded += bs_size_ue(22 as libc::c_int as libc::c_uint);
        let mut i: libc::c_int = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            (*s).i_bits_encoded
                += bs_size_ue(
                    subpartition_b_to_golomb[(*h).mb.i_sub_partition[i as usize]
                        as usize] as libc::c_uint,
                );
            i += 1;
            i;
        }
        if (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int {
            let mut i_0: libc::c_int = 0 as libc::c_int;
            while i_0 < 4 as libc::c_int {
                if x264_mb_partition_listX_table[0 as libc::c_int
                    as usize][(*h).mb.i_sub_partition[i_0 as usize] as usize] != 0
                {
                    (*s).i_bits_encoded
                        += bs_size_te(
                            (*h).mb.pic.i_fref[0 as libc::c_int as usize]
                                - 1 as libc::c_int,
                            (*h)
                                .mb
                                .cache
                                .ref_0[0 as libc::c_int
                                as usize][x264_scan8[(i_0 * 4 as libc::c_int) as usize]
                                as usize] as libc::c_int,
                        );
                }
                i_0 += 1;
                i_0;
            }
        }
        if (*h).mb.pic.i_fref[1 as libc::c_int as usize] > 1 as libc::c_int {
            let mut i_1: libc::c_int = 0 as libc::c_int;
            while i_1 < 4 as libc::c_int {
                if x264_mb_partition_listX_table[1 as libc::c_int
                    as usize][(*h).mb.i_sub_partition[i_1 as usize] as usize] != 0
                {
                    (*s).i_bits_encoded
                        += bs_size_te(
                            (*h).mb.pic.i_fref[1 as libc::c_int as usize]
                                - 1 as libc::c_int,
                            (*h)
                                .mb
                                .cache
                                .ref_0[1 as libc::c_int
                                as usize][x264_scan8[(i_1 * 4 as libc::c_int) as usize]
                                as usize] as libc::c_int,
                        );
                }
                i_1 += 1;
                i_1;
            }
        }
        let mut i_2: libc::c_int = 0 as libc::c_int;
        while i_2 < 4 as libc::c_int {
            if x264_mb_partition_listX_table[0 as libc::c_int
                as usize][(*h).mb.i_sub_partition[i_2 as usize] as usize] != 0
            {
                cavlc_mvd(h, 0 as libc::c_int, 4 as libc::c_int * i_2, 2 as libc::c_int);
            }
            i_2 += 1;
            i_2;
        }
        let mut i_3: libc::c_int = 0 as libc::c_int;
        while i_3 < 4 as libc::c_int {
            if x264_mb_partition_listX_table[1 as libc::c_int
                as usize][(*h).mb.i_sub_partition[i_3 as usize] as usize] != 0
            {
                cavlc_mvd(h, 1 as libc::c_int, 4 as libc::c_int * i_3, 2 as libc::c_int);
            }
            i_3 += 1;
            i_3;
        }
    } else if i_mb_type >= B_L0_L0 as libc::c_int && i_mb_type <= B_BI_BI as libc::c_int
    {
        let mut b_list: *const [uint8_t; 2] = (x264_mb_type_list_table[i_mb_type
            as usize])
            .as_ptr();
        let i_ref0_max: libc::c_int = (*h).mb.pic.i_fref[0 as libc::c_int as usize]
            - 1 as libc::c_int;
        let i_ref1_max: libc::c_int = (*h).mb.pic.i_fref[1 as libc::c_int as usize]
            - 1 as libc::c_int;
        (*s).i_bits_encoded
            += bs_size_ue(
                mb_type_b_to_golomb[((*h).mb.i_partition - D_16x8 as libc::c_int)
                    as usize][(i_mb_type - B_L0_L0 as libc::c_int) as usize]
                    as libc::c_uint,
            );
        if (*h).mb.i_partition == D_16x16 as libc::c_int {
            if i_ref0_max != 0
                && (*b_list.offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                    as libc::c_int != 0
            {
                (*s).i_bits_encoded
                    += bs_size_te(
                        i_ref0_max,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            if i_ref1_max != 0
                && (*b_list.offset(1 as libc::c_int as isize))[0 as libc::c_int as usize]
                    as libc::c_int != 0
            {
                (*s).i_bits_encoded
                    += bs_size_te(
                        i_ref1_max,
                        (*h)
                            .mb
                            .cache
                            .ref_0[1 as libc::c_int
                            as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            if (*b_list.offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                != 0
            {
                cavlc_mvd(h, 0 as libc::c_int, 0 as libc::c_int, 4 as libc::c_int);
            }
            if (*b_list.offset(1 as libc::c_int as isize))[0 as libc::c_int as usize]
                != 0
            {
                cavlc_mvd(h, 1 as libc::c_int, 0 as libc::c_int, 4 as libc::c_int);
            }
        } else {
            if i_ref0_max != 0
                && (*b_list.offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                    as libc::c_int != 0
            {
                (*s).i_bits_encoded
                    += bs_size_te(
                        i_ref0_max,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            if i_ref0_max != 0
                && (*b_list.offset(0 as libc::c_int as isize))[1 as libc::c_int as usize]
                    as libc::c_int != 0
            {
                (*s).i_bits_encoded
                    += bs_size_te(
                        i_ref0_max,
                        (*h)
                            .mb
                            .cache
                            .ref_0[0 as libc::c_int
                            as usize][x264_scan8[12 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            if i_ref1_max != 0
                && (*b_list.offset(1 as libc::c_int as isize))[0 as libc::c_int as usize]
                    as libc::c_int != 0
            {
                (*s).i_bits_encoded
                    += bs_size_te(
                        i_ref1_max,
                        (*h)
                            .mb
                            .cache
                            .ref_0[1 as libc::c_int
                            as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            if i_ref1_max != 0
                && (*b_list.offset(1 as libc::c_int as isize))[1 as libc::c_int as usize]
                    as libc::c_int != 0
            {
                (*s).i_bits_encoded
                    += bs_size_te(
                        i_ref1_max,
                        (*h)
                            .mb
                            .cache
                            .ref_0[1 as libc::c_int
                            as usize][x264_scan8[12 as libc::c_int as usize] as usize]
                            as libc::c_int,
                    );
            }
            if (*h).mb.i_partition == D_16x8 as libc::c_int {
                if (*b_list.offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 0 as libc::c_int, 0 as libc::c_int, 4 as libc::c_int);
                }
                if (*b_list.offset(0 as libc::c_int as isize))[1 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 0 as libc::c_int, 8 as libc::c_int, 4 as libc::c_int);
                }
                if (*b_list.offset(1 as libc::c_int as isize))[0 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 1 as libc::c_int, 0 as libc::c_int, 4 as libc::c_int);
                }
                if (*b_list.offset(1 as libc::c_int as isize))[1 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 1 as libc::c_int, 8 as libc::c_int, 4 as libc::c_int);
                }
            } else {
                if (*b_list.offset(0 as libc::c_int as isize))[0 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 0 as libc::c_int, 0 as libc::c_int, 2 as libc::c_int);
                }
                if (*b_list.offset(0 as libc::c_int as isize))[1 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 0 as libc::c_int, 4 as libc::c_int, 2 as libc::c_int);
                }
                if (*b_list.offset(1 as libc::c_int as isize))[0 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 1 as libc::c_int, 0 as libc::c_int, 2 as libc::c_int);
                }
                if (*b_list.offset(1 as libc::c_int as isize))[1 as libc::c_int as usize]
                    != 0
                {
                    cavlc_mvd(h, 1 as libc::c_int, 4 as libc::c_int, 2 as libc::c_int);
                }
            }
        }
    } else if i_mb_type == B_DIRECT as libc::c_int {
        (*s).i_bits_encoded += 1 as libc::c_int;
    } else {
        cavlc_mb_header_i(h, i_mb_type, 23 as libc::c_int, chroma);
    };
}
unsafe extern "C" fn macroblock_size_cavlc(mut h: *mut x264_t) {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    let i_mb_type: libc::c_int = (*h).mb.i_type;
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    let mut chroma: libc::c_int = ((*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_420 as libc::c_int
        || (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as libc::c_int)
        as libc::c_int;
    (*s).i_bits_encoded = 0 as libc::c_int;
    if (*h).sh.b_mbaff != 0
        && ((*h).mb.i_mb_y & 1 as libc::c_int == 0
            || (*((*h).mb.type_0)
                .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize) as libc::c_int
                == P_SKIP as libc::c_int
                || *((*h).mb.type_0)
                    .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize)
                    as libc::c_int == B_SKIP as libc::c_int))
    {
        (*s).i_bits_encoded += 1 as libc::c_int;
    }
    if (*h).sh.i_type == SLICE_TYPE_P as libc::c_int {
        cavlc_mb_header_p(h, i_mb_type, chroma);
    } else if (*h).sh.i_type == SLICE_TYPE_B as libc::c_int {
        cavlc_mb_header_b(h, i_mb_type, chroma);
    } else {
        cavlc_mb_header_i(h, i_mb_type, 0 as libc::c_int, chroma);
    }
    if i_mb_type != I_16x16 as libc::c_int {
        (*s).i_bits_encoded
            += bs_size_ue(
                cbp_to_golomb[chroma
                    as usize][(i_mb_type == I_4x4 as libc::c_int
                    || i_mb_type == I_8x8 as libc::c_int
                    || i_mb_type == I_16x16 as libc::c_int
                    || i_mb_type == I_PCM as libc::c_int) as libc::c_int
                    as usize][((*h).mb.i_cbp_chroma << 4 as libc::c_int
                    | (*h).mb.i_cbp_luma) as usize] as libc::c_uint,
            );
    }
    if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
        (*s).i_bits_encoded += 1 as libc::c_int;
    }
    if i_mb_type == I_16x16 as libc::c_int {
        cavlc_qp_delta(h);
        let mut p: libc::c_int = 0 as libc::c_int;
        while p < plane_count {
            let mut nC: libc::c_int = if DCT_LUMA_DC as libc::c_int
                == DCT_CHROMA_DC as libc::c_int
            {
                5 as libc::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_LUMA_DC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                        (48 as libc::c_int + p - 48 as libc::c_int) * 16 as libc::c_int
                    } else {
                        48 as libc::c_int + p
                    },
                ) as usize] as libc::c_int
            };
            let mut nnz: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                .as_mut_ptr()
                .offset(
                    *x264_scan8.as_ptr().offset((48 as libc::c_int + p) as isize)
                        as isize,
                ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded
                    += x264_coeff0_token[nC as usize].i_size as libc::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_DC as libc::c_int,
                    ((*h).dct.luma16x16_dc[p as usize]).as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            if (*h).mb.i_cbp_luma != 0 {
                let mut i: libc::c_int = p * 16 as libc::c_int;
                while i < p * 16 as libc::c_int + 16 as libc::c_int {
                    let mut nC_0: libc::c_int = if DCT_LUMA_AC as libc::c_int
                        == DCT_CHROMA_DC as libc::c_int
                    {
                        5 as libc::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_LUMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                                (i - 48 as libc::c_int) * 16 as libc::c_int
                            } else {
                                i
                            },
                        ) as usize] as libc::c_int
                    };
                    let mut nnz_0: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(*x264_scan8.as_ptr().offset(i as isize) as isize)
                        as *mut uint8_t;
                    if *nnz_0 == 0 {
                        (*h).out.bs.i_bits_encoded
                            += x264_coeff0_token[nC_0 as usize].i_size as libc::c_int;
                    } else {
                        *nnz_0 = cavlc_block_residual_internal(
                            h,
                            DCT_LUMA_AC as libc::c_int,
                            ((*h).dct.luma4x4[i as usize])
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize),
                            nC_0,
                        ) as uint8_t;
                    }
                    i += 1;
                    i;
                }
            }
            p += 1;
            p;
        }
    } else if (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma != 0 {
        cavlc_qp_delta(h);
        cavlc_macroblock_luma_residual(h, plane_count);
    }
    if (*h).mb.i_cbp_chroma != 0 {
        let mut nC_1: libc::c_int = if DCT_CHROMA_DC as libc::c_int
            == DCT_CHROMA_DC as libc::c_int
        {
            5 as libc::c_int - (*h).mb.chroma_v_shift
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if DCT_CHROMA_DC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                    (49 as libc::c_int + 0 as libc::c_int - 48 as libc::c_int)
                        * 16 as libc::c_int
                } else {
                    49 as libc::c_int + 0 as libc::c_int
                },
            ) as usize] as libc::c_int
        };
        let mut nnz_1: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as libc::c_int + 0 as libc::c_int) as isize) as isize,
            ) as *mut uint8_t;
        if *nnz_1 == 0 {
            (*h).out.bs.i_bits_encoded
                += x264_coeff0_token[nC_1 as usize].i_size as libc::c_int;
        } else {
            *nnz_1 = cavlc_block_residual_internal(
                h,
                DCT_CHROMA_DC as libc::c_int,
                ((*h).dct.chroma_dc[0 as libc::c_int as usize]).as_mut_ptr(),
                nC_1,
            ) as uint8_t;
        }
        let mut nC_2: libc::c_int = if DCT_CHROMA_DC as libc::c_int
            == DCT_CHROMA_DC as libc::c_int
        {
            5 as libc::c_int - (*h).mb.chroma_v_shift
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if DCT_CHROMA_DC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                    (49 as libc::c_int + 1 as libc::c_int - 48 as libc::c_int)
                        * 16 as libc::c_int
                } else {
                    49 as libc::c_int + 1 as libc::c_int
                },
            ) as usize] as libc::c_int
        };
        let mut nnz_2: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as libc::c_int + 1 as libc::c_int) as isize) as isize,
            ) as *mut uint8_t;
        if *nnz_2 == 0 {
            (*h).out.bs.i_bits_encoded
                += x264_coeff0_token[nC_2 as usize].i_size as libc::c_int;
        } else {
            *nnz_2 = cavlc_block_residual_internal(
                h,
                DCT_CHROMA_DC as libc::c_int,
                ((*h).dct.chroma_dc[1 as libc::c_int as usize]).as_mut_ptr(),
                nC_2,
            ) as uint8_t;
        }
        if (*h).mb.i_cbp_chroma == 2 as libc::c_int {
            let mut step: libc::c_int = (8 as libc::c_int) << (*h).mb.chroma_v_shift;
            let mut i_0: libc::c_int = 16 as libc::c_int;
            while i_0 < 3 as libc::c_int * 16 as libc::c_int {
                let mut j: libc::c_int = i_0;
                while j < i_0 + 4 as libc::c_int {
                    let mut nC_3: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                        == DCT_CHROMA_DC as libc::c_int
                    {
                        5 as libc::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int
                            {
                                (j - 48 as libc::c_int) * 16 as libc::c_int
                            } else {
                                j
                            },
                        ) as usize] as libc::c_int
                    };
                    let mut nnz_3: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                        as *mut uint8_t;
                    if *nnz_3 == 0 {
                        (*h).out.bs.i_bits_encoded
                            += x264_coeff0_token[nC_3 as usize].i_size as libc::c_int;
                    } else {
                        *nnz_3 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as libc::c_int,
                            ((*h).dct.luma4x4[j as usize])
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize),
                            nC_3,
                        ) as uint8_t;
                    }
                    j += 1;
                    j;
                }
                i_0 += step;
            }
        }
    }
}
unsafe extern "C" fn partition_size_cavlc(
    mut h: *mut x264_t,
    mut i8: libc::c_int,
    mut i_pixel: libc::c_int,
) -> libc::c_int {
    let mut s: *mut bs_t = &mut (*h).out.bs;
    let i_mb_type: libc::c_int = (*h).mb.i_type;
    let mut b_8x16: libc::c_int = ((*h).mb.i_partition == D_8x16 as libc::c_int)
        as libc::c_int;
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    let mut j: libc::c_int = 0;
    (*h).out.bs.i_bits_encoded = 0 as libc::c_int;
    if i_mb_type == P_8x8 as libc::c_int {
        cavlc_8x8_mvd(h, i8);
        (*s).i_bits_encoded
            += bs_size_ue(
                subpartition_p_to_golomb[(*h).mb.i_sub_partition[i8 as usize] as usize]
                    as libc::c_uint,
            );
    } else if i_mb_type == P_L0 as libc::c_int {
        cavlc_mvd(
            h,
            0 as libc::c_int,
            4 as libc::c_int * i8,
            4 as libc::c_int >> b_8x16,
        );
    } else if i_mb_type > B_DIRECT as libc::c_int && i_mb_type < B_8x8 as libc::c_int {
        if x264_mb_type_list_table[i_mb_type
            as usize][0 as libc::c_int as usize][(i8 != 0) as libc::c_int as usize] != 0
        {
            cavlc_mvd(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i8,
                4 as libc::c_int >> b_8x16,
            );
        }
        if x264_mb_type_list_table[i_mb_type
            as usize][1 as libc::c_int as usize][(i8 != 0) as libc::c_int as usize] != 0
        {
            cavlc_mvd(
                h,
                1 as libc::c_int,
                4 as libc::c_int * i8,
                4 as libc::c_int >> b_8x16,
            );
        }
    } else {
        if x264_mb_partition_listX_table[0 as libc::c_int
            as usize][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
        {
            cavlc_mvd(h, 0 as libc::c_int, 4 as libc::c_int * i8, 2 as libc::c_int);
        }
        if x264_mb_partition_listX_table[1 as libc::c_int
            as usize][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
        {
            cavlc_mvd(h, 1 as libc::c_int, 4 as libc::c_int * i8, 2 as libc::c_int);
        }
    }
    j = (i_pixel < PIXEL_8x8 as libc::c_int) as libc::c_int;
    while j >= 0 as libc::c_int {
        let mut p: libc::c_int = 0 as libc::c_int;
        while p < plane_count {
            cavlc_partition_luma_residual(h, i8, p);
            p += 1;
            p;
        }
        if (*h).mb.i_cbp_chroma != 0 {
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_422 as libc::c_int
            {
                let mut offset: libc::c_int = 5 as libc::c_int * i8 & 0x9 as libc::c_int;
                let mut nC: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                    == DCT_CHROMA_DC as libc::c_int
                {
                    5 as libc::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                            (16 as libc::c_int + offset - 48 as libc::c_int)
                                * 16 as libc::c_int
                        } else {
                            16 as libc::c_int + offset
                        },
                    ) as usize] as libc::c_int
                };
                let mut nnz: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8
                            .as_ptr()
                            .offset((16 as libc::c_int + offset) as isize) as isize,
                    ) as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded
                        += x264_coeff0_token[nC as usize].i_size as libc::c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(16 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                        nC,
                    ) as uint8_t;
                }
                let mut nC_0: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                    == DCT_CHROMA_DC as libc::c_int
                {
                    5 as libc::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                            (18 as libc::c_int + offset - 48 as libc::c_int)
                                * 16 as libc::c_int
                        } else {
                            18 as libc::c_int + offset
                        },
                    ) as usize] as libc::c_int
                };
                let mut nnz_0: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8
                            .as_ptr()
                            .offset((18 as libc::c_int + offset) as isize) as isize,
                    ) as *mut uint8_t;
                if *nnz_0 == 0 {
                    (*h).out.bs.i_bits_encoded
                        += x264_coeff0_token[nC_0 as usize].i_size as libc::c_int;
                } else {
                    *nnz_0 = cavlc_block_residual_internal(
                        h,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(18 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                        nC_0,
                    ) as uint8_t;
                }
                let mut nC_1: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                    == DCT_CHROMA_DC as libc::c_int
                {
                    5 as libc::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                            (32 as libc::c_int + offset - 48 as libc::c_int)
                                * 16 as libc::c_int
                        } else {
                            32 as libc::c_int + offset
                        },
                    ) as usize] as libc::c_int
                };
                let mut nnz_1: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8
                            .as_ptr()
                            .offset((32 as libc::c_int + offset) as isize) as isize,
                    ) as *mut uint8_t;
                if *nnz_1 == 0 {
                    (*h).out.bs.i_bits_encoded
                        += x264_coeff0_token[nC_1 as usize].i_size as libc::c_int;
                } else {
                    *nnz_1 = cavlc_block_residual_internal(
                        h,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(32 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                        nC_1,
                    ) as uint8_t;
                }
                let mut nC_2: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                    == DCT_CHROMA_DC as libc::c_int
                {
                    5 as libc::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                            (34 as libc::c_int + offset - 48 as libc::c_int)
                                * 16 as libc::c_int
                        } else {
                            34 as libc::c_int + offset
                        },
                    ) as usize] as libc::c_int
                };
                let mut nnz_2: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8
                            .as_ptr()
                            .offset((34 as libc::c_int + offset) as isize) as isize,
                    ) as *mut uint8_t;
                if *nnz_2 == 0 {
                    (*h).out.bs.i_bits_encoded
                        += x264_coeff0_token[nC_2 as usize].i_size as libc::c_int;
                } else {
                    *nnz_2 = cavlc_block_residual_internal(
                        h,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(34 as libc::c_int + offset) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                        nC_2,
                    ) as uint8_t;
                }
            } else {
                let mut nC_3: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                    == DCT_CHROMA_DC as libc::c_int
                {
                    5 as libc::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                            (16 as libc::c_int + i8 - 48 as libc::c_int)
                                * 16 as libc::c_int
                        } else {
                            16 as libc::c_int + i8
                        },
                    ) as usize] as libc::c_int
                };
                let mut nnz_3: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset((16 as libc::c_int + i8) as isize)
                            as isize,
                    ) as *mut uint8_t;
                if *nnz_3 == 0 {
                    (*h).out.bs.i_bits_encoded
                        += x264_coeff0_token[nC_3 as usize].i_size as libc::c_int;
                } else {
                    *nnz_3 = cavlc_block_residual_internal(
                        h,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(16 as libc::c_int + i8) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                        nC_3,
                    ) as uint8_t;
                }
                let mut nC_4: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                    == DCT_CHROMA_DC as libc::c_int
                {
                    5 as libc::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                            (32 as libc::c_int + i8 - 48 as libc::c_int)
                                * 16 as libc::c_int
                        } else {
                            32 as libc::c_int + i8
                        },
                    ) as usize] as libc::c_int
                };
                let mut nnz_4: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset((32 as libc::c_int + i8) as isize)
                            as isize,
                    ) as *mut uint8_t;
                if *nnz_4 == 0 {
                    (*h).out.bs.i_bits_encoded
                        += x264_coeff0_token[nC_4 as usize].i_size as libc::c_int;
                } else {
                    *nnz_4 = cavlc_block_residual_internal(
                        h,
                        DCT_CHROMA_AC as libc::c_int,
                        ((*h).dct.luma4x4[(32 as libc::c_int + i8) as usize])
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                        nC_4,
                    ) as uint8_t;
                }
            }
        }
        i8 += x264_pixel_size[i_pixel as usize].h as libc::c_int >> 3 as libc::c_int;
        j -= 1;
        j;
    }
    return (*h).out.bs.i_bits_encoded;
}
unsafe extern "C" fn subpartition_size_cavlc(
    mut h: *mut x264_t,
    mut i4: libc::c_int,
    mut i_pixel: libc::c_int,
) -> libc::c_int {
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    let mut b_8x4: libc::c_int = (i_pixel == PIXEL_8x4 as libc::c_int) as libc::c_int;
    (*h).out.bs.i_bits_encoded = 0 as libc::c_int;
    cavlc_mvd(h, 0 as libc::c_int, i4, 1 as libc::c_int + b_8x4);
    let mut p: libc::c_int = 0 as libc::c_int;
    while p < plane_count {
        let mut nC: libc::c_int = if DCT_LUMA_4x4 as libc::c_int
            == DCT_CHROMA_DC as libc::c_int
        {
            5 as libc::c_int - (*h).mb.chroma_v_shift
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if DCT_LUMA_4x4 as libc::c_int == DCT_LUMA_DC as libc::c_int {
                    (p * 16 as libc::c_int + i4 - 48 as libc::c_int) * 16 as libc::c_int
                } else {
                    p * 16 as libc::c_int + i4
                },
            ) as usize] as libc::c_int
        };
        let mut nnz: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                *x264_scan8.as_ptr().offset((p * 16 as libc::c_int + i4) as isize)
                    as isize,
            ) as *mut uint8_t;
        if *nnz == 0 {
            (*h).out.bs.i_bits_encoded
                += x264_coeff0_token[nC as usize].i_size as libc::c_int;
        } else {
            *nnz = cavlc_block_residual_internal(
                h,
                DCT_LUMA_4x4 as libc::c_int,
                ((*h).dct.luma4x4[(p * 16 as libc::c_int + i4) as usize]).as_mut_ptr(),
                nC,
            ) as uint8_t;
        }
        if i_pixel != PIXEL_4x4 as libc::c_int {
            let mut nC_0: libc::c_int = if DCT_LUMA_4x4 as libc::c_int
                == DCT_CHROMA_DC as libc::c_int
            {
                5 as libc::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_LUMA_4x4 as libc::c_int == DCT_LUMA_DC as libc::c_int {
                        (p * 16 as libc::c_int + i4 + 2 as libc::c_int - b_8x4
                            - 48 as libc::c_int) * 16 as libc::c_int
                    } else {
                        p * 16 as libc::c_int + i4 + 2 as libc::c_int - b_8x4
                    },
                ) as usize] as libc::c_int
            };
            let mut nnz_0: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                .as_mut_ptr()
                .offset(
                    *x264_scan8
                        .as_ptr()
                        .offset(
                            (p * 16 as libc::c_int + i4 + 2 as libc::c_int - b_8x4)
                                as isize,
                        ) as isize,
                ) as *mut uint8_t;
            if *nnz_0 == 0 {
                (*h).out.bs.i_bits_encoded
                    += x264_coeff0_token[nC_0 as usize].i_size as libc::c_int;
            } else {
                *nnz_0 = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as libc::c_int,
                    ((*h)
                        .dct
                        .luma4x4[(p * 16 as libc::c_int + i4 + 2 as libc::c_int - b_8x4)
                        as usize])
                        .as_mut_ptr(),
                    nC_0,
                ) as uint8_t;
            }
        }
        p += 1;
        p;
    }
    return (*h).out.bs.i_bits_encoded;
}
unsafe extern "C" fn cavlc_intra4x4_pred_size(
    mut h: *mut x264_t,
    mut i4: libc::c_int,
    mut i_mode: libc::c_int,
) -> libc::c_int {
    if x264_mb_predict_intra4x4_mode(h, i4)
        == x264_mb_pred_mode4x4_fix[(i_mode + 1 as libc::c_int) as usize] as libc::c_int
    {
        return 1 as libc::c_int
    } else {
        return 4 as libc::c_int
    };
}
unsafe extern "C" fn partition_i8x8_size_cavlc(
    mut h: *mut x264_t,
    mut i8: libc::c_int,
    mut i_mode: libc::c_int,
) -> libc::c_int {
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    (*h)
        .out
        .bs
        .i_bits_encoded = cavlc_intra4x4_pred_size(h, 4 as libc::c_int * i8, i_mode);
    (*h).out.bs.i_bits_encoded
        += bs_size_ue(
            cbp_to_golomb[!((*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as libc::c_int) as libc::c_int
                as usize][1 as libc::c_int
                as usize][((*h).mb.i_cbp_chroma << 4 as libc::c_int | (*h).mb.i_cbp_luma)
                as usize] as libc::c_uint,
        );
    let mut p: libc::c_int = 0 as libc::c_int;
    while p < plane_count {
        cavlc_partition_luma_residual(h, i8, p);
        p += 1;
        p;
    }
    return (*h).out.bs.i_bits_encoded;
}
unsafe extern "C" fn partition_i4x4_size_cavlc(
    mut h: *mut x264_t,
    mut i4: libc::c_int,
    mut i_mode: libc::c_int,
) -> libc::c_int {
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    (*h).out.bs.i_bits_encoded = cavlc_intra4x4_pred_size(h, i4, i_mode);
    let mut p: libc::c_int = 0 as libc::c_int;
    while p < plane_count {
        let mut nC: libc::c_int = if DCT_LUMA_4x4 as libc::c_int
            == DCT_CHROMA_DC as libc::c_int
        {
            5 as libc::c_int - (*h).mb.chroma_v_shift
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if DCT_LUMA_4x4 as libc::c_int == DCT_LUMA_DC as libc::c_int {
                    (p * 16 as libc::c_int + i4 - 48 as libc::c_int) * 16 as libc::c_int
                } else {
                    p * 16 as libc::c_int + i4
                },
            ) as usize] as libc::c_int
        };
        let mut nnz: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                *x264_scan8.as_ptr().offset((p * 16 as libc::c_int + i4) as isize)
                    as isize,
            ) as *mut uint8_t;
        if *nnz == 0 {
            (*h).out.bs.i_bits_encoded
                += x264_coeff0_token[nC as usize].i_size as libc::c_int;
        } else {
            *nnz = cavlc_block_residual_internal(
                h,
                DCT_LUMA_4x4 as libc::c_int,
                ((*h).dct.luma4x4[(p * 16 as libc::c_int + i4) as usize]).as_mut_ptr(),
                nC,
            ) as uint8_t;
        }
        p += 1;
        p;
    }
    return (*h).out.bs.i_bits_encoded;
}
unsafe extern "C" fn chroma_size_cavlc(mut h: *mut x264_t) -> libc::c_int {
    (*h)
        .out
        .bs
        .i_bits_encoded = bs_size_ue(
        x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize] as libc::c_uint,
    );
    if (*h).mb.i_cbp_chroma != 0 {
        let mut nC: libc::c_int = if DCT_CHROMA_DC as libc::c_int
            == DCT_CHROMA_DC as libc::c_int
        {
            5 as libc::c_int - (*h).mb.chroma_v_shift
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if DCT_CHROMA_DC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                    (49 as libc::c_int + 0 as libc::c_int - 48 as libc::c_int)
                        * 16 as libc::c_int
                } else {
                    49 as libc::c_int + 0 as libc::c_int
                },
            ) as usize] as libc::c_int
        };
        let mut nnz: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as libc::c_int + 0 as libc::c_int) as isize) as isize,
            ) as *mut uint8_t;
        if *nnz == 0 {
            (*h).out.bs.i_bits_encoded
                += x264_coeff0_token[nC as usize].i_size as libc::c_int;
        } else {
            *nnz = cavlc_block_residual_internal(
                h,
                DCT_CHROMA_DC as libc::c_int,
                ((*h).dct.chroma_dc[0 as libc::c_int as usize]).as_mut_ptr(),
                nC,
            ) as uint8_t;
        }
        let mut nC_0: libc::c_int = if DCT_CHROMA_DC as libc::c_int
            == DCT_CHROMA_DC as libc::c_int
        {
            5 as libc::c_int - (*h).mb.chroma_v_shift
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if DCT_CHROMA_DC as libc::c_int == DCT_LUMA_DC as libc::c_int {
                    (49 as libc::c_int + 1 as libc::c_int - 48 as libc::c_int)
                        * 16 as libc::c_int
                } else {
                    49 as libc::c_int + 1 as libc::c_int
                },
            ) as usize] as libc::c_int
        };
        let mut nnz_0: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
            .as_mut_ptr()
            .offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as libc::c_int + 1 as libc::c_int) as isize) as isize,
            ) as *mut uint8_t;
        if *nnz_0 == 0 {
            (*h).out.bs.i_bits_encoded
                += x264_coeff0_token[nC_0 as usize].i_size as libc::c_int;
        } else {
            *nnz_0 = cavlc_block_residual_internal(
                h,
                DCT_CHROMA_DC as libc::c_int,
                ((*h).dct.chroma_dc[1 as libc::c_int as usize]).as_mut_ptr(),
                nC_0,
            ) as uint8_t;
        }
        if (*h).mb.i_cbp_chroma == 2 as libc::c_int {
            let mut step: libc::c_int = (8 as libc::c_int) << (*h).mb.chroma_v_shift;
            let mut i: libc::c_int = 16 as libc::c_int;
            while i < 3 as libc::c_int * 16 as libc::c_int {
                let mut j: libc::c_int = i;
                while j < i + 4 as libc::c_int {
                    let mut nC_1: libc::c_int = if DCT_CHROMA_AC as libc::c_int
                        == DCT_CHROMA_DC as libc::c_int
                    {
                        5 as libc::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as libc::c_int == DCT_LUMA_DC as libc::c_int
                            {
                                (j - 48 as libc::c_int) * 16 as libc::c_int
                            } else {
                                j
                            },
                        ) as usize] as libc::c_int
                    };
                    let mut nnz_1: *mut uint8_t = &mut *((*h).mb.cache.non_zero_count)
                        .as_mut_ptr()
                        .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                        as *mut uint8_t;
                    if *nnz_1 == 0 {
                        (*h).out.bs.i_bits_encoded
                            += x264_coeff0_token[nC_1 as usize].i_size as libc::c_int;
                    } else {
                        *nnz_1 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as libc::c_int,
                            ((*h).dct.luma4x4[j as usize])
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize),
                            nC_1,
                        ) as uint8_t;
                    }
                    j += 1;
                    j;
                }
                i += step;
            }
        }
    }
    return (*h).out.bs.i_bits_encoded;
}
static mut i_mb_b_cost_table: [uint8_t; 19] = [
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
];
static mut i_mb_b16x8_cost_table: [uint8_t; 17] = [
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
    9 as libc::c_int as uint8_t,
];
static mut i_sub_mb_b_cost_table: [uint8_t; 13] = [
    7 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    7 as libc::c_int as uint8_t,
    5 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
];
static mut i_sub_mb_p_cost_table: [uint8_t; 4] = [
    5 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
];
unsafe extern "C" fn init_costs(
    mut h: *mut x264_t,
    mut logs: *mut libc::c_float,
    mut qp: libc::c_int,
) -> libc::c_int {
    let mut cost_i4x4_mode: *mut uint16_t = 0 as *mut uint16_t;
    let mut current_block: u64;
    if !((*h).cost_mv[qp as usize]).is_null() {
        return 0 as libc::c_int;
    }
    let mut mv_range: libc::c_int = (*h).param.analyse.i_mv_range
        << (*h).param.b_interlaced;
    let mut lambda: libc::c_int = x264_lambda_tab[qp as usize] as libc::c_int;
    (*h)
        .cost_mv[qp
        as usize] = x264_malloc(
        ((4 as libc::c_int * 4 as libc::c_int * mv_range + 1 as libc::c_int)
            as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint16_t>() as libc::c_ulong) as int64_t,
    ) as *mut uint16_t;
    if !((*h).cost_mv[qp as usize]).is_null() {
        (*h)
            .cost_mv[qp
            as usize] = ((*h).cost_mv[qp as usize])
            .offset((2 as libc::c_int * 4 as libc::c_int * mv_range) as isize);
        let mut i: libc::c_int = 0 as libc::c_int;
        while i <= 2 as libc::c_int * 4 as libc::c_int * mv_range {
            let ref mut fresh23 = *((*h).cost_mv[qp as usize]).offset(i as isize);
            *fresh23 = (if ((lambda as libc::c_float * *logs.offset(i as isize) + 0.5f32)
                as libc::c_int) < 65535 as libc::c_int
            {
                (lambda as libc::c_float * *logs.offset(i as isize) + 0.5f32)
                    as libc::c_int
            } else {
                65535 as libc::c_int
            }) as uint16_t;
            *((*h).cost_mv[qp as usize]).offset(-i as isize) = *fresh23;
            i += 1;
            i;
        }
        let mut i_0: libc::c_int = 0 as libc::c_int;
        while i_0 < 3 as libc::c_int {
            let mut j: libc::c_int = 0 as libc::c_int;
            while j < 33 as libc::c_int {
                (*(*h).cost_table)
                    .ref_0[qp
                    as usize][i_0
                    as usize][j
                    as usize] = (if i_0 != 0 {
                    if lambda * bs_size_te(i_0, j) < 65535 as libc::c_int {
                        lambda * bs_size_te(i_0, j)
                    } else {
                        65535 as libc::c_int
                    }
                } else {
                    0 as libc::c_int
                }) as uint16_t;
                j += 1;
                j;
            }
            i_0 += 1;
            i_0;
        }
        if (*h).param.analyse.i_me_method >= 3 as libc::c_int
            && ((*h).cost_mv_fpel[qp as usize][0 as libc::c_int as usize]).is_null()
        {
            let mut j_0: libc::c_int = 0 as libc::c_int;
            loop {
                if !(j_0 < 4 as libc::c_int) {
                    current_block = 11194104282611034094;
                    break;
                }
                (*h)
                    .cost_mv_fpel[qp
                    as usize][j_0
                    as usize] = x264_malloc(
                    ((4 as libc::c_int * mv_range + 1 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
                        ) as int64_t,
                ) as *mut uint16_t;
                if ((*h).cost_mv_fpel[qp as usize][j_0 as usize]).is_null() {
                    current_block = 10293987108442703682;
                    break;
                }
                (*h)
                    .cost_mv_fpel[qp
                    as usize][j_0
                    as usize] = ((*h).cost_mv_fpel[qp as usize][j_0 as usize])
                    .offset((2 as libc::c_int * mv_range) as isize);
                let mut i_1: libc::c_int = -(2 as libc::c_int) * mv_range;
                while i_1 < 2 as libc::c_int * mv_range {
                    *((*h).cost_mv_fpel[qp as usize][j_0 as usize])
                        .offset(
                            i_1 as isize,
                        ) = *((*h).cost_mv[qp as usize])
                        .offset((i_1 * 4 as libc::c_int + j_0) as isize);
                    i_1 += 1;
                    i_1;
                }
                j_0 += 1;
                j_0;
            }
        } else {
            current_block = 11194104282611034094;
        }
        match current_block {
            10293987108442703682 => {}
            _ => {
                cost_i4x4_mode = ((*(*h).cost_table).i4x4_mode[qp as usize])
                    .as_mut_ptr();
                let mut i_2: libc::c_int = 0 as libc::c_int;
                while i_2 < 17 as libc::c_int {
                    *cost_i4x4_mode
                        .offset(
                            i_2 as isize,
                        ) = (3 as libc::c_int * lambda
                        * (i_2 != 8 as libc::c_int) as libc::c_int) as uint16_t;
                    i_2 += 1;
                    i_2;
                }
                return 0 as libc::c_int;
            }
        }
    }
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_analyse_init_costs(mut h: *mut x264_t) -> libc::c_int {
    let mut current_block: u64;
    let mut mv_range: libc::c_int = (*h).param.analyse.i_mv_range
        << (*h).param.b_interlaced;
    let mut logs: *mut libc::c_float = x264_malloc(
        ((2 as libc::c_int * 4 as libc::c_int * mv_range + 1 as libc::c_int)
            as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_float>() as libc::c_ulong)
            as int64_t,
    ) as *mut libc::c_float;
    if logs.is_null() {
        return -(1 as libc::c_int);
    }
    *logs.offset(0 as libc::c_int as isize) = 0.718f32;
    let mut i: libc::c_int = 1 as libc::c_int;
    while i <= 2 as libc::c_int * 4 as libc::c_int * mv_range {
        *logs
            .offset(
                i as isize,
            ) = log2f((i + 1 as libc::c_int) as libc::c_float) * 2.0f32 + 1.718f32;
        i += 1;
        i;
    }
    let mut qp: libc::c_int = if (*h).param.rc.i_qp_min
        < 51 as libc::c_int + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
    {
        (*h).param.rc.i_qp_min
    } else {
        51 as libc::c_int + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
    };
    loop {
        if !(qp <= (*h).param.rc.i_qp_max) {
            current_block = 10886091980245723256;
            break;
        }
        if init_costs(h, logs, qp) != 0 {
            current_block = 2726837058511494076;
            break;
        }
        qp += 1;
        qp;
    }
    match current_block {
        10886091980245723256 => {
            if !(init_costs(
                h,
                logs,
                12 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int),
            ) != 0)
            {
                x264_free(logs as *mut libc::c_void);
                return 0 as libc::c_int;
            }
        }
        _ => {}
    }
    x264_free(logs as *mut libc::c_void);
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_analyse_free_costs(mut h: *mut x264_t) {
    let mut mv_range: libc::c_int = (*h).param.analyse.i_mv_range
        << (*h).param.b_interlaced;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i
        < 51 as libc::c_int + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
            + 18 as libc::c_int + 1 as libc::c_int
    {
        if !((*h).cost_mv[i as usize]).is_null() {
            x264_free(
                ((*h).cost_mv[i as usize])
                    .offset(-((2 as libc::c_int * 4 as libc::c_int * mv_range) as isize))
                    as *mut libc::c_void,
            );
        }
        let mut j: libc::c_int = 0 as libc::c_int;
        while j < 4 as libc::c_int {
            if !((*h).cost_mv_fpel[i as usize][j as usize]).is_null() {
                x264_free(
                    ((*h).cost_mv_fpel[i as usize][j as usize])
                        .offset(-((2 as libc::c_int * mv_range) as isize))
                        as *mut libc::c_void,
                );
            }
            j += 1;
            j;
        }
        i += 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_analyse_weight_frame(
    mut h: *mut x264_t,
    mut end: libc::c_int,
) {
    let mut j: libc::c_int = 0 as libc::c_int;
    while j < (*h).i_ref[0 as libc::c_int as usize] {
        if !((*h).sh.weight[j as usize][0 as libc::c_int as usize].weightfn).is_null() {
            let mut frame: *mut x264_frame_t = (*h)
                .fref[0 as libc::c_int as usize][j as usize];
            let mut width: libc::c_int = (*frame).i_width[0 as libc::c_int as usize]
                + ((if 32 as libc::c_int
                    > 64 as libc::c_int
                        / ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int
                {
                    32 as libc::c_int
                } else {
                    64 as libc::c_int
                        / ::core::mem::size_of::<pixel>() as libc::c_ulong as libc::c_int
                }) + 32 as libc::c_int);
            let mut i_padv: libc::c_int = (32 as libc::c_int) << (*h).param.b_interlaced;
            let mut offset: libc::c_int = 0;
            let mut height: libc::c_int = 0;
            let mut src: *mut pixel = ((*frame)
                .filtered[0 as libc::c_int as usize][0 as libc::c_int as usize])
                .offset(
                    -(((*frame).i_stride[0 as libc::c_int as usize] * i_padv) as isize),
                )
                .offset(
                    -((if 32 as libc::c_int
                        > 64 as libc::c_int
                            / ::core::mem::size_of::<pixel>() as libc::c_ulong
                                as libc::c_int
                    {
                        32 as libc::c_int
                    } else {
                        64 as libc::c_int
                            / ::core::mem::size_of::<pixel>() as libc::c_ulong
                                as libc::c_int
                    }) as isize),
                );
            height = (if 16 as libc::c_int + end + i_padv
                < (*(*h).fref[0 as libc::c_int as usize][j as usize])
                    .i_lines[0 as libc::c_int as usize] + i_padv * 2 as libc::c_int
            {
                16 as libc::c_int + end + i_padv
            } else {
                (*(*h).fref[0 as libc::c_int as usize][j as usize])
                    .i_lines[0 as libc::c_int as usize] + i_padv * 2 as libc::c_int
            }) - (*(*h).fenc).i_lines_weighted;
            offset = (*(*h).fenc).i_lines_weighted
                * (*frame).i_stride[0 as libc::c_int as usize];
            (*(*h).fenc).i_lines_weighted += height;
            if height != 0 {
                let mut k: libc::c_int = j;
                while k < (*h).i_ref[0 as libc::c_int as usize] {
                    if !((*h).sh.weight[k as usize][0 as libc::c_int as usize].weightfn)
                        .is_null()
                    {
                        let mut dst: *mut pixel = ((*(*h).fenc).weighted[k as usize])
                            .offset(
                                -(((*(*h).fenc).i_stride[0 as libc::c_int as usize]
                                    * i_padv) as isize),
                            )
                            .offset(
                                -((if 32 as libc::c_int
                                    > 64 as libc::c_int
                                        / ::core::mem::size_of::<pixel>() as libc::c_ulong
                                            as libc::c_int
                                {
                                    32 as libc::c_int
                                } else {
                                    64 as libc::c_int
                                        / ::core::mem::size_of::<pixel>() as libc::c_ulong
                                            as libc::c_int
                                }) as isize),
                            );
                        x264_8_weight_scale_plane(
                            h,
                            dst.offset(offset as isize),
                            (*frame).i_stride[0 as libc::c_int as usize] as intptr_t,
                            src.offset(offset as isize),
                            (*frame).i_stride[0 as libc::c_int as usize] as intptr_t,
                            width,
                            height,
                            &mut *(*((*h).sh.weight).as_mut_ptr().offset(k as isize))
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize),
                        );
                    }
                    k += 1;
                    k;
                }
            }
            break;
        } else {
            j += 1;
            j;
        }
    }
}
unsafe extern "C" fn mb_analyse_load_costs(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    (*a).p_cost_mv = (*h).cost_mv[(*a).i_qp as usize];
    (*a)
        .p_cost_ref[0 as libc::c_int
        as usize] = ((*(*h).cost_table)
        .ref_0[(*a).i_qp
        as usize][x264_clip3(
        (*h).sh.i_num_ref_idx_l0_active - 1 as libc::c_int,
        0 as libc::c_int,
        2 as libc::c_int,
    ) as usize])
        .as_mut_ptr();
    (*a)
        .p_cost_ref[1 as libc::c_int
        as usize] = ((*(*h).cost_table)
        .ref_0[(*a).i_qp
        as usize][x264_clip3(
        (*h).sh.i_num_ref_idx_l1_active - 1 as libc::c_int,
        0 as libc::c_int,
        2 as libc::c_int,
    ) as usize])
        .as_mut_ptr();
}
unsafe extern "C" fn mb_analyse_init_qp(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut qp: libc::c_int,
) {
    let mut effective_chroma_qp: libc::c_int = *((*h).chroma_qp_table)
        .offset(
            (if qp
                < 51 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
            {
                qp
            } else {
                51 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
            }) as isize,
        ) as libc::c_int
        + (if qp
            - (51 as libc::c_int
                + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int))
            > 0 as libc::c_int
        {
            qp
                - (51 as libc::c_int
                    + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int))
        } else {
            0 as libc::c_int
        });
    (*a).i_lambda = x264_lambda_tab[qp as usize] as libc::c_int;
    (*a).i_lambda2 = x264_lambda2_tab[qp as usize];
    (*h)
        .mb
        .b_trellis = ((*h).param.analyse.i_trellis > 1 as libc::c_int
        && (*a).i_mbrd != 0) as libc::c_int;
    if (*h).param.analyse.i_trellis != 0 {
        (*h)
            .mb
            .i_trellis_lambda2[0 as libc::c_int
            as usize][0 as libc::c_int
            as usize] = x264_trellis_lambda2_tab[0 as libc::c_int as usize][qp as usize];
        (*h)
            .mb
            .i_trellis_lambda2[0 as libc::c_int
            as usize][1 as libc::c_int
            as usize] = x264_trellis_lambda2_tab[1 as libc::c_int as usize][qp as usize];
        (*h)
            .mb
            .i_trellis_lambda2[1 as libc::c_int
            as usize][0 as libc::c_int
            as usize] = x264_trellis_lambda2_tab[0 as libc::c_int
            as usize][effective_chroma_qp as usize];
        (*h)
            .mb
            .i_trellis_lambda2[1 as libc::c_int
            as usize][1 as libc::c_int
            as usize] = x264_trellis_lambda2_tab[1 as libc::c_int
            as usize][effective_chroma_qp as usize];
    }
    (*h).mb.i_psy_rd_lambda = (*a).i_lambda;
    let mut chroma_offset_idx: libc::c_int = if (qp - effective_chroma_qp
        + 12 as libc::c_int) < 36 as libc::c_int
    {
        qp - effective_chroma_qp + 12 as libc::c_int
    } else {
        36 as libc::c_int
    };
    (*h)
        .mb
        .i_chroma_lambda2_offset = if (*h).param.analyse.b_psy != 0 {
        x264_chroma_lambda2_offset_tab[chroma_offset_idx as usize] as libc::c_int
    } else {
        256 as libc::c_int
    };
    if qp > 51 as libc::c_int + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
    {
        (*h)
            .nr_offset = (*((*h).nr_offset_emergency)
            .offset(
                (qp
                    - (51 as libc::c_int
                        + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int))
                    - 1 as libc::c_int) as isize,
            ))
            .as_mut_ptr();
        (*h)
            .nr_residual_sum = ((*h).nr_residual_sum_buf[1 as libc::c_int as usize])
            .as_mut_ptr();
        (*h).nr_count = ((*h).nr_count_buf[1 as libc::c_int as usize]).as_mut_ptr();
        (*h).mb.b_noise_reduction = 1 as libc::c_int;
        qp = 51 as libc::c_int
            + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int);
    } else {
        (*h).nr_offset = ((*h).nr_offset_denoise).as_mut_ptr();
        (*h)
            .nr_residual_sum = ((*h).nr_residual_sum_buf[0 as libc::c_int as usize])
            .as_mut_ptr();
        (*h).nr_count = ((*h).nr_count_buf[0 as libc::c_int as usize]).as_mut_ptr();
        (*h).mb.b_noise_reduction = 0 as libc::c_int;
    }
    (*h).mb.i_qp = qp;
    (*a).i_qp = (*h).mb.i_qp;
    (*h).mb.i_chroma_qp = *((*h).chroma_qp_table).offset(qp as isize) as libc::c_int;
}
unsafe extern "C" fn mb_analyse_init(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut qp: libc::c_int,
) {
    let mut subme: libc::c_int = (*h).param.analyse.i_subpel_refine
        - ((*h).sh.i_type == SLICE_TYPE_B as libc::c_int) as libc::c_int;
    (*a)
        .i_mbrd = (subme >= 6 as libc::c_int) as libc::c_int
        + (subme >= 8 as libc::c_int) as libc::c_int
        + ((*h).param.analyse.i_subpel_refine >= 10 as libc::c_int) as libc::c_int;
    (*h)
        .mb
        .b_deblock_rdo = ((*h).param.analyse.i_subpel_refine >= 9 as libc::c_int
        && (*h).sh.i_disable_deblocking_filter_idc != 1 as libc::c_int) as libc::c_int;
    (*a)
        .b_early_terminate = ((*h).param.analyse.i_subpel_refine < 11 as libc::c_int)
        as libc::c_int;
    mb_analyse_init_qp(h, a, qp);
    (*h).mb.b_transform_8x8 = 0 as libc::c_int;
    (*a).i_satd_i4x4 = (1 as libc::c_int) << 28 as libc::c_int;
    (*a).i_satd_i8x8 = (*a).i_satd_i4x4;
    (*a).i_satd_i16x16 = (*a).i_satd_i8x8;
    (*a)
        .i_satd_chroma = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
        (1 as libc::c_int) << 28 as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut pcm_cost: uint64_t = ((256 as libc::c_int * 8 as libc::c_int
        + 2 as libc::c_int
            * (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                256 as libc::c_int * 8 as libc::c_int
                    >> (*h).mb.chroma_h_shift + (*h).mb.chroma_v_shift
            } else {
                0 as libc::c_int
            }) + 16 as libc::c_int) as uint64_t * (*a).i_lambda2 as uint64_t)
        .wrapping_add(128 as libc::c_int as uint64_t) >> 8 as libc::c_int;
    (*a)
        .i_satd_pcm = (if (*h).param.i_avcintra_class == 0 && (*h).mb.i_psy_rd == 0
        && (*a).i_mbrd != 0
        && pcm_cost < ((1 as libc::c_int) << 28 as libc::c_int) as uint64_t
    {
        pcm_cost
    } else {
        ((1 as libc::c_int) << 28 as libc::c_int) as uint64_t
    }) as libc::c_int;
    (*a).b_fast_intra = 0 as libc::c_int;
    (*a).b_avoid_topright = 0 as libc::c_int;
    (*h)
        .mb
        .i_skip_intra = if (*h).mb.b_lossless != 0 {
        0 as libc::c_int
    } else if (*a).i_mbrd != 0 {
        2 as libc::c_int
    } else {
        ((*h).param.analyse.i_trellis == 0 && (*h).param.analyse.i_noise_reduction == 0)
            as libc::c_int
    };
    if (*h).sh.i_type != SLICE_TYPE_I as libc::c_int {
        let mut i_fmv_range: libc::c_int = 4 as libc::c_int
            * (*h).param.analyse.i_mv_range;
        let mut i_fpel_border: libc::c_int = 6 as libc::c_int;
        (*h)
            .mb
            .mv_min[0 as libc::c_int
            as usize] = 4 as libc::c_int
            * (-(16 as libc::c_int) * (*h).mb.i_mb_x - 24 as libc::c_int);
        (*h)
            .mb
            .mv_max[0 as libc::c_int
            as usize] = 4 as libc::c_int
            * (16 as libc::c_int
                * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as libc::c_int)
                + 24 as libc::c_int);
        (*h)
            .mb
            .mv_min_spel[0 as libc::c_int
            as usize] = if (*h).mb.mv_min[0 as libc::c_int as usize] > -i_fmv_range {
            (*h).mb.mv_min[0 as libc::c_int as usize]
        } else {
            -i_fmv_range
        };
        (*h)
            .mb
            .mv_max_spel[0 as libc::c_int
            as usize] = if (*h).mb.mv_max[0 as libc::c_int as usize]
            < i_fmv_range - 1 as libc::c_int
        {
            (*h).mb.mv_max[0 as libc::c_int as usize]
        } else {
            i_fmv_range - 1 as libc::c_int
        };
        if (*h).param.b_intra_refresh != 0
            && (*h).sh.i_type == SLICE_TYPE_P as libc::c_int
        {
            let mut max_x: libc::c_int = ((*(*h)
                .fref[0 as libc::c_int as usize][0 as libc::c_int as usize])
                .i_pir_end_col * 16 as libc::c_int - 3 as libc::c_int)
                * 4 as libc::c_int;
            let mut max_mv: libc::c_int = max_x
                - 4 as libc::c_int * 16 as libc::c_int * (*h).mb.i_mb_x;
            if max_mv > 0 as libc::c_int && (*h).mb.i_mb_x < (*(*h).fdec).i_pir_start_col
            {
                (*h)
                    .mb
                    .mv_max_spel[0 as libc::c_int
                    as usize] = if (*h).mb.mv_max_spel[0 as libc::c_int as usize]
                    < max_mv
                {
                    (*h).mb.mv_max_spel[0 as libc::c_int as usize]
                } else {
                    max_mv
                };
            }
        }
        (*h)
            .mb
            .mv_limit_fpel[0 as libc::c_int
            as usize][0 as libc::c_int
            as usize] = (((*h).mb.mv_min_spel[0 as libc::c_int as usize]
            >> 2 as libc::c_int) + i_fpel_border) as int16_t;
        (*h)
            .mb
            .mv_limit_fpel[1 as libc::c_int
            as usize][0 as libc::c_int
            as usize] = (((*h).mb.mv_max_spel[0 as libc::c_int as usize]
            >> 2 as libc::c_int) - i_fpel_border) as int16_t;
        if (*h).mb.i_mb_x == 0 as libc::c_int
            && (*h).mb.i_mb_y & (*h).param.b_interlaced == 0
        {
            let mut mb_y: libc::c_int = (*h).mb.i_mb_y >> (*h).sh.b_mbaff;
            let mut thread_mvy_range: libc::c_int = i_fmv_range;
            if (*h).i_thread_frames > 1 as libc::c_int {
                let mut pix_y: libc::c_int = ((*h).mb.i_mb_y | (*h).param.b_interlaced)
                    * 16 as libc::c_int;
                let mut thresh: libc::c_int = pix_y
                    + (*h).param.analyse.i_mv_range_thread;
                let mut i: libc::c_int = ((*h).sh.i_type == SLICE_TYPE_B as libc::c_int)
                    as libc::c_int;
                while i >= 0 as libc::c_int {
                    let mut j: libc::c_int = 0 as libc::c_int;
                    while j < (*h).i_ref[i as usize] {
                        let mut completed: libc::c_int = x264_8_frame_cond_wait(
                            (*(*h).fref[i as usize][j as usize]).orig,
                            thresh,
                        );
                        thread_mvy_range = if thread_mvy_range < completed - pix_y {
                            thread_mvy_range
                        } else {
                            completed - pix_y
                        };
                        j += 1;
                        j;
                    }
                    i -= 1;
                    i;
                }
                if (*h).param.b_deterministic != 0 {
                    thread_mvy_range = (*h).param.analyse.i_mv_range_thread;
                }
                if (*h).param.b_interlaced != 0 {
                    thread_mvy_range >>= 1 as libc::c_int;
                }
                x264_8_analyse_weight_frame(h, pix_y + thread_mvy_range);
            }
            if (*h).param.b_interlaced != 0 {
                let mut i_0: libc::c_int = 0 as libc::c_int;
                while i_0 < 3 as libc::c_int {
                    let mut j_0: libc::c_int = (i_0 == 2 as libc::c_int) as libc::c_int;
                    mb_y = ((*h).mb.i_mb_y >> j_0)
                        + (i_0 == 1 as libc::c_int) as libc::c_int;
                    (*h)
                        .mb
                        .mv_miny_row[i_0
                        as usize] = 4 as libc::c_int
                        * (-(16 as libc::c_int) * mb_y - 24 as libc::c_int);
                    (*h)
                        .mb
                        .mv_maxy_row[i_0
                        as usize] = 4 as libc::c_int
                        * (16 as libc::c_int
                            * (((*h).mb.i_mb_height >> j_0) - mb_y - 1 as libc::c_int)
                            + 24 as libc::c_int);
                    (*h)
                        .mb
                        .mv_miny_spel_row[i_0
                        as usize] = if (*h).mb.mv_miny_row[i_0 as usize] > -i_fmv_range {
                        (*h).mb.mv_miny_row[i_0 as usize]
                    } else {
                        -i_fmv_range
                    };
                    (*h)
                        .mb
                        .mv_maxy_spel_row[i_0
                        as usize] = if (*h).mb.mv_maxy_row[i_0 as usize]
                        < (if (i_fmv_range - 1 as libc::c_int)
                            < 4 as libc::c_int * thread_mvy_range
                        {
                            i_fmv_range - 1 as libc::c_int
                        } else {
                            4 as libc::c_int * thread_mvy_range
                        })
                    {
                        (*h).mb.mv_maxy_row[i_0 as usize]
                    } else if (i_fmv_range - 1 as libc::c_int)
                        < 4 as libc::c_int * thread_mvy_range
                    {
                        i_fmv_range - 1 as libc::c_int
                    } else {
                        4 as libc::c_int * thread_mvy_range
                    };
                    (*h)
                        .mb
                        .mv_miny_fpel_row[i_0
                        as usize] = ((*h).mb.mv_miny_spel_row[i_0 as usize]
                        >> 2 as libc::c_int) + i_fpel_border;
                    (*h)
                        .mb
                        .mv_maxy_fpel_row[i_0
                        as usize] = ((*h).mb.mv_maxy_spel_row[i_0 as usize]
                        >> 2 as libc::c_int) - i_fpel_border;
                    i_0 += 1;
                    i_0;
                }
            } else {
                (*h)
                    .mb
                    .mv_min[1 as libc::c_int
                    as usize] = 4 as libc::c_int
                    * (-(16 as libc::c_int) * mb_y - 24 as libc::c_int);
                (*h)
                    .mb
                    .mv_max[1 as libc::c_int
                    as usize] = 4 as libc::c_int
                    * (16 as libc::c_int
                        * ((*h).mb.i_mb_height - mb_y - 1 as libc::c_int)
                        + 24 as libc::c_int);
                (*h)
                    .mb
                    .mv_min_spel[1 as libc::c_int
                    as usize] = if (*h).mb.mv_min[1 as libc::c_int as usize]
                    > -i_fmv_range
                {
                    (*h).mb.mv_min[1 as libc::c_int as usize]
                } else {
                    -i_fmv_range
                };
                (*h)
                    .mb
                    .mv_max_spel[1 as libc::c_int
                    as usize] = if (*h).mb.mv_max[1 as libc::c_int as usize]
                    < (if (i_fmv_range - 1 as libc::c_int)
                        < 4 as libc::c_int * thread_mvy_range
                    {
                        i_fmv_range - 1 as libc::c_int
                    } else {
                        4 as libc::c_int * thread_mvy_range
                    })
                {
                    (*h).mb.mv_max[1 as libc::c_int as usize]
                } else if (i_fmv_range - 1 as libc::c_int)
                    < 4 as libc::c_int * thread_mvy_range
                {
                    i_fmv_range - 1 as libc::c_int
                } else {
                    4 as libc::c_int * thread_mvy_range
                };
                (*h)
                    .mb
                    .mv_limit_fpel[0 as libc::c_int
                    as usize][1 as libc::c_int
                    as usize] = (((*h).mb.mv_min_spel[1 as libc::c_int as usize]
                    >> 2 as libc::c_int) + i_fpel_border) as int16_t;
                (*h)
                    .mb
                    .mv_limit_fpel[1 as libc::c_int
                    as usize][1 as libc::c_int
                    as usize] = (((*h).mb.mv_max_spel[1 as libc::c_int as usize]
                    >> 2 as libc::c_int) - i_fpel_border) as int16_t;
            }
        }
        if (*h).param.b_interlaced != 0 {
            let mut i_1: libc::c_int = if (*h).mb.b_interlaced != 0 {
                2 as libc::c_int
            } else {
                (*h).mb.i_mb_y & 1 as libc::c_int
            };
            (*h)
                .mb
                .mv_min[1 as libc::c_int as usize] = (*h).mb.mv_miny_row[i_1 as usize];
            (*h)
                .mb
                .mv_max[1 as libc::c_int as usize] = (*h).mb.mv_maxy_row[i_1 as usize];
            (*h)
                .mb
                .mv_min_spel[1 as libc::c_int
                as usize] = (*h).mb.mv_miny_spel_row[i_1 as usize];
            (*h)
                .mb
                .mv_max_spel[1 as libc::c_int
                as usize] = (*h).mb.mv_maxy_spel_row[i_1 as usize];
            (*h)
                .mb
                .mv_limit_fpel[0 as libc::c_int
                as usize][1 as libc::c_int
                as usize] = (*h).mb.mv_miny_fpel_row[i_1 as usize] as int16_t;
            (*h)
                .mb
                .mv_limit_fpel[1 as libc::c_int
                as usize][1 as libc::c_int
                as usize] = (*h).mb.mv_maxy_fpel_row[i_1 as usize] as int16_t;
        }
        (*a).l0.i_cost8x16 = (1 as libc::c_int) << 28 as libc::c_int;
        (*a).l0.i_cost16x8 = (*a).l0.i_cost8x16;
        (*a).l0.i_cost8x8 = (*a).l0.i_cost16x8;
        (*a).l0.i_rd16x16 = (*a).l0.i_cost8x8;
        (*a).l0.me16x16.cost = (*a).l0.i_rd16x16;
        if (*h).sh.i_type == SLICE_TYPE_B as libc::c_int {
            (*a).i_cost8x16bi = (1 as libc::c_int) << 28 as libc::c_int;
            (*a).i_cost16x8bi = (*a).i_cost8x16bi;
            (*a).i_cost8x8bi = (*a).i_cost16x8bi;
            (*a).i_cost16x16direct = (*a).i_cost8x8bi;
            (*a).i_cost16x16bi = (*a).i_cost16x16direct;
            (*a).i_rd8x16bi = (*a).i_cost16x16bi;
            (*a).i_rd16x8bi = (*a).i_rd8x16bi;
            (*a).i_rd8x8bi = (*a).i_rd16x8bi;
            (*a).i_rd16x16direct = (*a).i_rd8x8bi;
            (*a).i_rd16x16bi = (*a).i_rd16x16direct;
            (*a).l1.i_cost8x16 = (*a).i_rd16x16bi;
            (*a).l1.i_cost16x8 = (*a).l1.i_cost8x16;
            (*a).i_cost8x8direct[3 as libc::c_int as usize] = (*a).l1.i_cost16x8;
            (*a)
                .i_cost8x8direct[2 as libc::c_int
                as usize] = (*a).i_cost8x8direct[3 as libc::c_int as usize];
            (*a)
                .i_cost8x8direct[1 as libc::c_int
                as usize] = (*a).i_cost8x8direct[2 as libc::c_int as usize];
            (*a)
                .i_cost8x8direct[0 as libc::c_int
                as usize] = (*a).i_cost8x8direct[1 as libc::c_int as usize];
            (*a).l1.i_cost8x8 = (*a).i_cost8x8direct[0 as libc::c_int as usize];
            (*a).l1.i_rd16x16 = (*a).l1.i_cost8x8;
            (*a).l1.me16x16.cost = (*a).l1.i_rd16x16;
        } else if (*h).param.analyse.inter & 0x20 as libc::c_uint != 0 {
            let mut i_2: libc::c_int = 0 as libc::c_int;
            while i_2 < 4 as libc::c_int {
                (*a)
                    .l0
                    .i_cost4x8[i_2 as usize] = (1 as libc::c_int) << 28 as libc::c_int;
                (*a).l0.i_cost8x4[i_2 as usize] = (*a).l0.i_cost4x8[i_2 as usize];
                (*a).l0.i_cost4x4[i_2 as usize] = (*a).l0.i_cost8x4[i_2 as usize];
                i_2 += 1;
                i_2;
            }
        }
        if (*a).b_early_terminate != 0
            && (*h).mb.i_mb_xy - (*h).sh.i_first_mb > 4 as libc::c_int
        {
            if !((*h).mb.i_mb_type_left[0 as libc::c_int as usize]
                == I_4x4 as libc::c_int
                || (*h).mb.i_mb_type_left[0 as libc::c_int as usize]
                    == I_8x8 as libc::c_int
                || (*h).mb.i_mb_type_left[0 as libc::c_int as usize]
                    == I_16x16 as libc::c_int
                || (*h).mb.i_mb_type_left[0 as libc::c_int as usize]
                    == I_PCM as libc::c_int
                || ((*h).mb.i_mb_type_top == I_4x4 as libc::c_int
                    || (*h).mb.i_mb_type_top == I_8x8 as libc::c_int
                    || (*h).mb.i_mb_type_top == I_16x16 as libc::c_int
                    || (*h).mb.i_mb_type_top == I_PCM as libc::c_int)
                || ((*h).mb.i_mb_type_topleft == I_4x4 as libc::c_int
                    || (*h).mb.i_mb_type_topleft == I_8x8 as libc::c_int
                    || (*h).mb.i_mb_type_topleft == I_16x16 as libc::c_int
                    || (*h).mb.i_mb_type_topleft == I_PCM as libc::c_int)
                || ((*h).mb.i_mb_type_topright == I_4x4 as libc::c_int
                    || (*h).mb.i_mb_type_topright == I_8x8 as libc::c_int
                    || (*h).mb.i_mb_type_topright == I_16x16 as libc::c_int
                    || (*h).mb.i_mb_type_topright == I_PCM as libc::c_int)
                || (*h).sh.i_type == SLICE_TYPE_P as libc::c_int
                    && (*((*(*h)
                        .fref[0 as libc::c_int as usize][0 as libc::c_int as usize])
                        .mb_type)
                        .offset((*h).mb.i_mb_xy as isize) as libc::c_int
                        == I_4x4 as libc::c_int
                        || *((*(*h)
                            .fref[0 as libc::c_int as usize][0 as libc::c_int as usize])
                            .mb_type)
                            .offset((*h).mb.i_mb_xy as isize) as libc::c_int
                            == I_8x8 as libc::c_int
                        || *((*(*h)
                            .fref[0 as libc::c_int as usize][0 as libc::c_int as usize])
                            .mb_type)
                            .offset((*h).mb.i_mb_xy as isize) as libc::c_int
                            == I_16x16 as libc::c_int
                        || *((*(*h)
                            .fref[0 as libc::c_int as usize][0 as libc::c_int as usize])
                            .mb_type)
                            .offset((*h).mb.i_mb_xy as isize) as libc::c_int
                            == I_PCM as libc::c_int)
                || (*h).mb.i_mb_xy - (*h).sh.i_first_mb
                    < 3 as libc::c_int
                        * ((*h).stat.frame.i_mb_count[I_4x4 as libc::c_int as usize]
                            + (*h).stat.frame.i_mb_count[I_8x8 as libc::c_int as usize]
                            + (*h).stat.frame.i_mb_count[I_16x16 as libc::c_int as usize]
                            + (*h).stat.frame.i_mb_count[I_PCM as libc::c_int as usize]))
            {
                (*a).b_fast_intra = 1 as libc::c_int;
            }
        }
        (*h).mb.b_skip_mc = 0 as libc::c_int;
        if (*h).param.b_intra_refresh != 0
            && (*h).sh.i_type == SLICE_TYPE_P as libc::c_int
            && (*h).mb.i_mb_x >= (*(*h).fdec).i_pir_start_col
            && (*h).mb.i_mb_x <= (*(*h).fdec).i_pir_end_col
        {
            (*a).b_force_intra = 1 as libc::c_int;
            (*a).b_fast_intra = 0 as libc::c_int;
            (*a)
                .b_avoid_topright = ((*h).mb.i_mb_x == (*(*h).fdec).i_pir_end_col)
                as libc::c_int;
        } else {
            (*a).b_force_intra = 0 as libc::c_int;
        }
    }
}
static mut i16x16_mode_available: [[int8_t; 5]; 5] = [
    [
        I_PRED_16x16_DC_128 as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_DC_LEFT as libc::c_int as int8_t,
        I_PRED_16x16_H as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_DC_TOP as libc::c_int as int8_t,
        I_PRED_16x16_V as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_V as libc::c_int as int8_t,
        I_PRED_16x16_H as libc::c_int as int8_t,
        I_PRED_16x16_DC as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_V as libc::c_int as int8_t,
        I_PRED_16x16_H as libc::c_int as int8_t,
        I_PRED_16x16_DC as libc::c_int as int8_t,
        I_PRED_16x16_P as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
];
static mut chroma_mode_available: [[int8_t; 5]; 5] = [
    [
        I_PRED_CHROMA_DC_128 as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_DC_LEFT as libc::c_int as int8_t,
        I_PRED_CHROMA_H as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_DC_TOP as libc::c_int as int8_t,
        I_PRED_CHROMA_V as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_V as libc::c_int as int8_t,
        I_PRED_CHROMA_H as libc::c_int as int8_t,
        I_PRED_CHROMA_DC as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_V as libc::c_int as int8_t,
        I_PRED_CHROMA_H as libc::c_int as int8_t,
        I_PRED_CHROMA_DC as libc::c_int as int8_t,
        I_PRED_CHROMA_P as libc::c_int as int8_t,
        -(1 as libc::c_int) as int8_t,
    ],
];
static mut i8x8_mode_available: [[[int8_t; 10]; 5]; 2] = [
    [
        [
            I_PRED_4x4_DC_128 as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_TOP as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_DDL as libc::c_int as int8_t,
            I_PRED_4x4_VL as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_DDL as libc::c_int as int8_t,
            I_PRED_4x4_VL as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_DDL as libc::c_int as int8_t,
            I_PRED_4x4_DDR as libc::c_int as int8_t,
            I_PRED_4x4_VR as libc::c_int as int8_t,
            I_PRED_4x4_HD as libc::c_int as int8_t,
            I_PRED_4x4_VL as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
    ],
    [
        [
            I_PRED_4x4_DC_128 as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_HD as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
    ],
];
static mut i4x4_mode_available: [[[int8_t; 10]; 5]; 2] = [
    [
        [
            I_PRED_4x4_DC_128 as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_TOP as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_DDL as libc::c_int as int8_t,
            I_PRED_4x4_VL as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_DDL as libc::c_int as int8_t,
            I_PRED_4x4_VL as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_DDL as libc::c_int as int8_t,
            I_PRED_4x4_DDR as libc::c_int as int8_t,
            I_PRED_4x4_VR as libc::c_int as int8_t,
            I_PRED_4x4_HD as libc::c_int as int8_t,
            I_PRED_4x4_VL as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
    ],
    [
        [
            I_PRED_4x4_DC_128 as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_TOP as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as libc::c_int as int8_t,
            I_PRED_4x4_H as libc::c_int as int8_t,
            I_PRED_4x4_V as libc::c_int as int8_t,
            I_PRED_4x4_DDR as libc::c_int as int8_t,
            I_PRED_4x4_VR as libc::c_int as int8_t,
            I_PRED_4x4_HD as libc::c_int as int8_t,
            I_PRED_4x4_HU as libc::c_int as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
            -(1 as libc::c_int) as int8_t,
        ],
    ],
];
#[inline(always)]
unsafe extern "C" fn predict_16x16_mode_available(
    mut i_neighbour: libc::c_int,
) -> *const int8_t {
    let mut idx: libc::c_int = i_neighbour
        & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int);
    idx = if idx
        == MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int
    {
        4 as libc::c_int
    } else {
        idx & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int)
    };
    return (i16x16_mode_available[idx as usize]).as_ptr();
}
#[inline(always)]
unsafe extern "C" fn predict_chroma_mode_available(
    mut i_neighbour: libc::c_int,
) -> *const int8_t {
    let mut idx: libc::c_int = i_neighbour
        & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int);
    idx = if idx
        == MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int
    {
        4 as libc::c_int
    } else {
        idx & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int)
    };
    return (chroma_mode_available[idx as usize]).as_ptr();
}
#[inline(always)]
unsafe extern "C" fn predict_8x8_mode_available(
    mut force_intra: libc::c_int,
    mut i_neighbour: libc::c_int,
    mut i: libc::c_int,
) -> *const int8_t {
    let mut avoid_topright: libc::c_int = (force_intra != 0 && i & 1 as libc::c_int != 0)
        as libc::c_int;
    let mut idx: libc::c_int = i_neighbour
        & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int);
    idx = if idx
        == MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int
    {
        4 as libc::c_int
    } else {
        idx & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int)
    };
    return (i8x8_mode_available[avoid_topright as usize][idx as usize]).as_ptr();
}
#[inline(always)]
unsafe extern "C" fn predict_4x4_mode_available(
    mut force_intra: libc::c_int,
    mut i_neighbour: libc::c_int,
    mut i: libc::c_int,
) -> *const int8_t {
    let mut avoid_topright: libc::c_int = (force_intra != 0
        && i & 5 as libc::c_int == 5 as libc::c_int) as libc::c_int;
    let mut idx: libc::c_int = i_neighbour
        & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int);
    idx = if idx
        == MB_TOP as libc::c_int | MB_LEFT as libc::c_int | MB_TOPLEFT as libc::c_int
    {
        4 as libc::c_int
    } else {
        idx & (MB_TOP as libc::c_int | MB_LEFT as libc::c_int)
    };
    return (i4x4_mode_available[avoid_topright as usize][idx as usize]).as_ptr();
}
#[inline]
unsafe extern "C" fn psy_trellis_init(mut h: *mut x264_t, mut do_both_dct: libc::c_int) {
    if do_both_dct != 0 || (*h).mb.b_transform_8x8 != 0 {
        ((*h).dctf.sub16x16_dct8)
            .expect(
                "non-null function pointer",
            )(
            ((*h).mb.pic.fenc_dct8).as_mut_ptr(),
            (*h).mb.pic.p_fenc[0 as libc::c_int as usize],
            x264_zero.as_mut_ptr() as *mut pixel,
        );
    }
    if do_both_dct != 0 || (*h).mb.b_transform_8x8 == 0 {
        ((*h).dctf.sub16x16_dct)
            .expect(
                "non-null function pointer",
            )(
            ((*h).mb.pic.fenc_dct4).as_mut_ptr(),
            (*h).mb.pic.p_fenc[0 as libc::c_int as usize],
            x264_zero.as_mut_ptr() as *mut pixel,
        );
    }
}
#[inline]
unsafe extern "C" fn mb_init_fenc_cache(mut h: *mut x264_t, mut b_satd: libc::c_int) {
    if (*h).param.analyse.i_trellis == 2 as libc::c_int && (*h).mb.i_psy_trellis != 0 {
        psy_trellis_init(h, (*h).param.analyse.b_transform_8x8);
    }
    if (*h).mb.i_psy_rd == 0 {
        return;
    }
    (*(&mut *((*h).mb.pic.fenc_hadamard_cache)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut uint64_t as *mut x264_union128_sse_t))
        .i = _mm_setr_ps(
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
    );
    (*(&mut *((*h).mb.pic.fenc_hadamard_cache)
        .as_mut_ptr()
        .offset(2 as libc::c_int as isize) as *mut uint64_t as *mut x264_union128_sse_t))
        .i = _mm_setr_ps(
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
    );
    (*(&mut *((*h).mb.pic.fenc_hadamard_cache)
        .as_mut_ptr()
        .offset(4 as libc::c_int as isize) as *mut uint64_t as *mut x264_union128_sse_t))
        .i = _mm_setr_ps(
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
    );
    (*(&mut *((*h).mb.pic.fenc_hadamard_cache)
        .as_mut_ptr()
        .offset(6 as libc::c_int as isize) as *mut uint64_t as *mut x264_union128_sse_t))
        .i = _mm_setr_ps(
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
        0 as libc::c_int as libc::c_float,
    );
    (*h)
        .mb
        .pic
        .fenc_hadamard_cache[8 as libc::c_int as usize] = 0 as libc::c_int as uint64_t;
    if b_satd != 0 {
        ((*h).mc.memzero_aligned)
            .expect(
                "non-null function pointer",
            )(
            ((*h).mb.pic.fenc_satd_cache).as_mut_ptr() as *mut libc::c_void,
            ::core::mem::size_of::<[uint32_t; 32]>() as libc::c_ulong,
        );
    }
}
unsafe extern "C" fn mb_analyse_intra_chroma(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    if (*a).i_satd_chroma < (1 as libc::c_int) << 28 as libc::c_int {
        return;
    }
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
        if (*h).mb.b_chroma_me == 0 {
            (*a).i_satd_chroma = 0 as libc::c_int;
            return;
        }
        if (*h).mb.b_lossless != 0 {
            x264_8_predict_lossless_16x16(h, 1 as libc::c_int, (*a).i_predict16x16);
            x264_8_predict_lossless_16x16(h, 2 as libc::c_int, (*a).i_predict16x16);
        } else {
            ((*h).predict_16x16[(*a).i_predict16x16 as usize])
                .expect(
                    "non-null function pointer",
                )((*h).mb.pic.p_fdec[1 as libc::c_int as usize]);
            ((*h).predict_16x16[(*a).i_predict16x16 as usize])
                .expect(
                    "non-null function pointer",
                )((*h).mb.pic.p_fdec[2 as libc::c_int as usize]);
        }
        (*a)
            .i_satd_chroma = ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (*h).mb.pic.p_fdec[1 as libc::c_int as usize],
            32 as libc::c_int as intptr_t,
        )
            + ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                .expect(
                    "non-null function pointer",
                )(
                (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
                16 as libc::c_int as intptr_t,
                (*h).mb.pic.p_fdec[2 as libc::c_int as usize],
                32 as libc::c_int as intptr_t,
            );
        return;
    }
    let mut predict_mode: *const int8_t = predict_chroma_mode_available(
        (*h).mb.i_neighbour_intra as libc::c_int,
    );
    let mut chromapix: libc::c_int = (*h)
        .luma2chroma_pixel[PIXEL_16x16 as libc::c_int as usize] as libc::c_int;
    if *predict_mode.offset(3 as libc::c_int as isize) as libc::c_int >= 0 as libc::c_int
        && (*h).mb.b_lossless == 0
    {
        let mut satdu: [libc::c_int; 4] = [0; 4];
        let mut satdv: [libc::c_int; 4] = [0; 4];
        ((*h).pixf.intra_mbcmp_x3_chroma)
            .expect(
                "non-null function pointer",
            )(
            (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
            (*h).mb.pic.p_fdec[1 as libc::c_int as usize],
            satdu.as_mut_ptr(),
        );
        ((*h).pixf.intra_mbcmp_x3_chroma)
            .expect(
                "non-null function pointer",
            )(
            (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
            (*h).mb.pic.p_fdec[2 as libc::c_int as usize],
            satdv.as_mut_ptr(),
        );
        ((*h).predict_chroma[I_PRED_CHROMA_P as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )((*h).mb.pic.p_fdec[1 as libc::c_int as usize]);
        ((*h).predict_chroma[I_PRED_CHROMA_P as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )((*h).mb.pic.p_fdec[2 as libc::c_int as usize]);
        satdu[I_PRED_CHROMA_P as libc::c_int
            as usize] = ((*h).pixf.mbcmp[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (*h).mb.pic.p_fdec[1 as libc::c_int as usize],
            32 as libc::c_int as intptr_t,
        );
        satdv[I_PRED_CHROMA_P as libc::c_int
            as usize] = ((*h).pixf.mbcmp[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (*h).mb.pic.p_fdec[2 as libc::c_int as usize],
            32 as libc::c_int as intptr_t,
        );
        while *predict_mode as libc::c_int >= 0 as libc::c_int {
            let mut i_mode: libc::c_int = *predict_mode as libc::c_int;
            let mut i_satd: libc::c_int = satdu[i_mode as usize] + satdv[i_mode as usize]
                + (*a).i_lambda * bs_size_ue(i_mode as libc::c_uint);
            (*a).i_satd_chroma_dir[i_mode as usize] = i_satd;
            if i_satd < (*a).i_satd_chroma {
                (*a).i_satd_chroma = i_satd;
                (*a).i_predict8x8chroma = i_mode;
            }
            predict_mode = predict_mode.offset(1);
            predict_mode;
        }
    } else {
        while *predict_mode as libc::c_int >= 0 as libc::c_int {
            let mut i_satd_0: libc::c_int = 0;
            let mut i_mode_0: libc::c_int = *predict_mode as libc::c_int;
            if (*h).mb.b_lossless != 0 {
                x264_8_predict_lossless_chroma(h, i_mode_0);
            } else {
                ((*h).predict_chroma[i_mode_0 as usize])
                    .expect(
                        "non-null function pointer",
                    )((*h).mb.pic.p_fdec[1 as libc::c_int as usize]);
                ((*h).predict_chroma[i_mode_0 as usize])
                    .expect(
                        "non-null function pointer",
                    )((*h).mb.pic.p_fdec[2 as libc::c_int as usize]);
            }
            i_satd_0 = ((*h).pixf.mbcmp[chromapix as usize])
                .expect(
                    "non-null function pointer",
                )(
                (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
                16 as libc::c_int as intptr_t,
                (*h).mb.pic.p_fdec[1 as libc::c_int as usize],
                32 as libc::c_int as intptr_t,
            )
                + ((*h).pixf.mbcmp[chromapix as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
                    16 as libc::c_int as intptr_t,
                    (*h).mb.pic.p_fdec[2 as libc::c_int as usize],
                    32 as libc::c_int as intptr_t,
                )
                + (*a).i_lambda
                    * bs_size_ue(
                        x264_mb_chroma_pred_mode_fix[i_mode_0 as usize] as libc::c_uint,
                    );
            (*a).i_satd_chroma_dir[i_mode_0 as usize] = i_satd_0;
            if i_satd_0 < (*a).i_satd_chroma {
                (*a).i_satd_chroma = i_satd_0;
                (*a).i_predict8x8chroma = i_mode_0;
            }
            predict_mode = predict_mode.offset(1);
            predict_mode;
        }
    }
    (*h).mb.i_chroma_pred_mode = (*a).i_predict8x8chroma;
}
unsafe extern "C" fn mb_analyse_intra(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd_inter: libc::c_int,
) {
    let flags: libc::c_uint = if (*h).sh.i_type == SLICE_TYPE_I as libc::c_int {
        (*h).param.analyse.intra
    } else {
        (*h).param.analyse.inter
    };
    let mut p_src: *mut pixel = (*h).mb.pic.p_fenc[0 as libc::c_int as usize];
    let mut p_dst: *mut pixel = (*h).mb.pic.p_fdec[0 as libc::c_int as usize];
    static mut intra_analysis_shortcut: [[[[int8_t; 5]; 2]; 2]; 2] = [
        [
            [
                [
                    I_PRED_4x4_HU as libc::c_int as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
                [
                    I_PRED_4x4_DDL as libc::c_int as int8_t,
                    I_PRED_4x4_VL as libc::c_int as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
            ],
            [
                [
                    I_PRED_4x4_DDR as libc::c_int as int8_t,
                    I_PRED_4x4_HD as libc::c_int as int8_t,
                    I_PRED_4x4_HU as libc::c_int as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
                [
                    I_PRED_4x4_DDL as libc::c_int as int8_t,
                    I_PRED_4x4_DDR as libc::c_int as int8_t,
                    I_PRED_4x4_VR as libc::c_int as int8_t,
                    I_PRED_4x4_VL as libc::c_int as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
            ],
        ],
        [
            [
                [
                    I_PRED_4x4_HU as libc::c_int as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
                [
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
            ],
            [
                [
                    I_PRED_4x4_DDR as libc::c_int as int8_t,
                    I_PRED_4x4_HD as libc::c_int as int8_t,
                    I_PRED_4x4_HU as libc::c_int as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
                [
                    I_PRED_4x4_DDR as libc::c_int as int8_t,
                    I_PRED_4x4_VR as libc::c_int as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                    -(1 as libc::c_int) as int8_t,
                ],
            ],
        ],
    ];
    let mut idx: libc::c_int = 0;
    let mut lambda: libc::c_int = (*a).i_lambda;
    if (*h).param.i_avcintra_class == 0 {
        let mut predict_mode: *const int8_t = predict_16x16_mode_available(
            (*h).mb.i_neighbour_intra as libc::c_int,
        );
        static mut i16x16_thresh_lut: [uint8_t; 11] = [
            2 as libc::c_int as uint8_t,
            2 as libc::c_int as uint8_t,
            2 as libc::c_int as uint8_t,
            3 as libc::c_int as uint8_t,
            3 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
        ];
        let mut i16x16_thresh: libc::c_int = if (*a).b_fast_intra != 0 {
            i16x16_thresh_lut[(*h).mb.i_subpel_refine as usize] as libc::c_int
                * i_satd_inter >> 1 as libc::c_int
        } else {
            (1 as libc::c_int) << 28 as libc::c_int
        };
        if (*h).mb.b_lossless == 0
            && *predict_mode.offset(3 as libc::c_int as isize) as libc::c_int
                >= 0 as libc::c_int
        {
            ((*h).pixf.intra_mbcmp_x3_16x16)
                .expect(
                    "non-null function pointer",
                )(p_src, p_dst, ((*a).i_satd_i16x16_dir).as_mut_ptr());
            (*a).i_satd_i16x16_dir[0 as libc::c_int as usize]
                += lambda * bs_size_ue(0 as libc::c_int as libc::c_uint);
            (*a).i_satd_i16x16_dir[1 as libc::c_int as usize]
                += lambda * bs_size_ue(1 as libc::c_int as libc::c_uint);
            (*a).i_satd_i16x16_dir[2 as libc::c_int as usize]
                += lambda * bs_size_ue(2 as libc::c_int as libc::c_uint);
            if (*a).i_satd_i16x16_dir[0 as libc::c_int as usize] < (*a).i_satd_i16x16 {
                (*a).i_satd_i16x16 = (*a).i_satd_i16x16_dir[0 as libc::c_int as usize];
                (*a).i_predict16x16 = 0 as libc::c_int;
            }
            if (*a).i_satd_i16x16_dir[1 as libc::c_int as usize] < (*a).i_satd_i16x16 {
                (*a).i_satd_i16x16 = (*a).i_satd_i16x16_dir[1 as libc::c_int as usize];
                (*a).i_predict16x16 = 1 as libc::c_int;
            }
            if (*a).i_satd_i16x16_dir[2 as libc::c_int as usize] < (*a).i_satd_i16x16 {
                (*a).i_satd_i16x16 = (*a).i_satd_i16x16_dir[2 as libc::c_int as usize];
                (*a).i_predict16x16 = 2 as libc::c_int;
            }
            if (*a).i_satd_i16x16 <= i16x16_thresh {
                ((*h).predict_16x16[I_PRED_16x16_P as libc::c_int as usize])
                    .expect("non-null function pointer")(p_dst);
                (*a)
                    .i_satd_i16x16_dir[I_PRED_16x16_P as libc::c_int
                    as usize] = ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    p_src,
                    16 as libc::c_int as intptr_t,
                    p_dst,
                    32 as libc::c_int as intptr_t,
                );
                (*a).i_satd_i16x16_dir[I_PRED_16x16_P as libc::c_int as usize]
                    += lambda * bs_size_ue(3 as libc::c_int as libc::c_uint);
                if (*a).i_satd_i16x16_dir[I_PRED_16x16_P as libc::c_int as usize]
                    < (*a).i_satd_i16x16
                {
                    (*a)
                        .i_satd_i16x16 = (*a)
                        .i_satd_i16x16_dir[I_PRED_16x16_P as libc::c_int as usize];
                    (*a).i_predict16x16 = 3 as libc::c_int;
                }
            }
        } else {
            while *predict_mode as libc::c_int >= 0 as libc::c_int {
                let mut i_satd: libc::c_int = 0;
                let mut i_mode: libc::c_int = *predict_mode as libc::c_int;
                if (*h).mb.b_lossless != 0 {
                    x264_8_predict_lossless_16x16(h, 0 as libc::c_int, i_mode);
                } else {
                    ((*h).predict_16x16[i_mode as usize])
                        .expect("non-null function pointer")(p_dst);
                }
                i_satd = ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    p_src,
                    16 as libc::c_int as intptr_t,
                    p_dst,
                    32 as libc::c_int as intptr_t,
                )
                    + lambda
                        * bs_size_ue(
                            x264_mb_pred_mode16x16_fix[i_mode as usize] as libc::c_uint,
                        );
                if i_satd < (*a).i_satd_i16x16 {
                    (*a).i_satd_i16x16 = i_satd;
                    (*a).i_predict16x16 = i_mode;
                }
                (*a).i_satd_i16x16_dir[i_mode as usize] = i_satd;
                predict_mode = predict_mode.offset(1);
                predict_mode;
            }
        }
        if (*h).sh.i_type == SLICE_TYPE_B as libc::c_int {
            (*a).i_satd_i16x16
                += lambda
                    * i_mb_b_cost_table[I_16x16 as libc::c_int as usize] as libc::c_int;
        }
        if (*a).i_satd_i16x16 > i16x16_thresh {
            return;
        }
    }
    let mut cost_i4x4_mode: *mut uint16_t = ((*(*h).cost_table)
        .i4x4_mode[(*a).i_qp as usize])
        .as_mut_ptr()
        .offset(8 as libc::c_int as isize);
    if flags & 0x2 as libc::c_uint != 0 {
        let mut edge: [pixel; 36] = [0; 36];
        let mut sa8d: x264_pixel_cmp_t = if (*h).pixf.mbcmp[0 as libc::c_int as usize]
            == (*h).pixf.satd[0 as libc::c_int as usize]
        {
            (*h).pixf.sa8d[PIXEL_8x8 as libc::c_int as usize]
        } else {
            (*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize]
        };
        let mut i_satd_thresh: libc::c_int = if (*a).i_mbrd != 0 {
            (1 as libc::c_int) << 28 as libc::c_int
        } else if i_satd_inter < (*a).i_satd_i16x16 {
            i_satd_inter
        } else {
            (*a).i_satd_i16x16
        };
        let mut i_cost: libc::c_int = lambda * 4 as libc::c_int;
        (*h).mb.i_cbp_luma = 0 as libc::c_int;
        if (*h).sh.i_type == SLICE_TYPE_B as libc::c_int {
            i_cost
                += lambda
                    * i_mb_b_cost_table[I_8x8 as libc::c_int as usize] as libc::c_int;
        }
        idx = 0 as libc::c_int;
        loop {
            let mut x: libc::c_int = idx & 1 as libc::c_int;
            let mut y: libc::c_int = idx >> 1 as libc::c_int;
            let mut p_src_by: *mut pixel = p_src
                .offset((8 as libc::c_int * x) as isize)
                .offset((8 as libc::c_int * y * 16 as libc::c_int) as isize);
            let mut p_dst_by: *mut pixel = p_dst
                .offset((8 as libc::c_int * x) as isize)
                .offset((8 as libc::c_int * y * 32 as libc::c_int) as isize);
            let mut i_best: libc::c_int = (1 as libc::c_int) << 28 as libc::c_int;
            let mut i_pred_mode: libc::c_int = x264_mb_predict_intra4x4_mode(
                h,
                4 as libc::c_int * idx,
            );
            let mut predict_mode_0: *const int8_t = predict_8x8_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour8[idx as usize] as libc::c_int,
                idx,
            );
            ((*h).predict_8x8_filter)
                .expect(
                    "non-null function pointer",
                )(
                p_dst_by,
                edge.as_mut_ptr(),
                (*h).mb.i_neighbour8[idx as usize] as libc::c_int,
                ALL_NEIGHBORS as libc::c_int,
            );
            if ((*h).pixf.intra_mbcmp_x9_8x8).is_some()
                && *predict_mode_0.offset(8 as libc::c_int as isize) as libc::c_int
                    >= 0 as libc::c_int
            {
                i_best = ((*h).pixf.intra_mbcmp_x9_8x8)
                    .expect(
                        "non-null function pointer",
                    )(
                    p_src_by,
                    p_dst_by,
                    edge.as_mut_ptr(),
                    cost_i4x4_mode.offset(-(i_pred_mode as isize)),
                    ((*a).i_satd_i8x8_dir[idx as usize]).as_mut_ptr(),
                );
                i_cost += i_best & 0xffff as libc::c_int;
                i_best >>= 16 as libc::c_int;
                (*a).i_predict8x8[idx as usize] = i_best;
                if idx == 3 as libc::c_int || i_cost > i_satd_thresh {
                    break;
                }
                x264_macroblock_cache_intra8x8_pred(
                    h,
                    2 as libc::c_int * x,
                    2 as libc::c_int * y,
                    i_best,
                );
            } else {
                if (*h).mb.b_lossless == 0
                    && *predict_mode_0.offset(5 as libc::c_int as isize) as libc::c_int
                        >= 0 as libc::c_int
                {
                    let mut satd: [int32_t; 4] = [0; 4];
                    ((*h).pixf.intra_mbcmp_x3_8x8)
                        .expect(
                            "non-null function pointer",
                        )(p_src_by, edge.as_mut_ptr(), satd.as_mut_ptr());
                    let mut favor_vertical: libc::c_int = (satd[I_PRED_4x4_H
                        as libc::c_int as usize]
                        > satd[I_PRED_4x4_V as libc::c_int as usize]) as libc::c_int;
                    if i_pred_mode < 3 as libc::c_int {
                        satd[i_pred_mode as usize] -= 3 as libc::c_int * lambda;
                    }
                    let mut i: libc::c_int = 2 as libc::c_int;
                    while i >= 0 as libc::c_int {
                        let mut cost: libc::c_int = satd[i as usize];
                        (*a)
                            .i_satd_i8x8_dir[idx
                            as usize][i
                            as usize] = (cost + 4 as libc::c_int * lambda) as uint16_t;
                        if cost < i_best {
                            i_best = cost;
                            (*a).i_predict8x8[idx as usize] = i;
                        }
                        i -= 1;
                        i;
                    }
                    if (*a).i_mbrd < 1 as libc::c_int + (*a).b_fast_intra {
                        predict_mode_0 = (intra_analysis_shortcut[(*a).b_avoid_topright
                            as usize][(*predict_mode_0.offset(8 as libc::c_int as isize)
                            as libc::c_int >= 0 as libc::c_int) as libc::c_int
                            as usize][favor_vertical as usize])
                            .as_ptr();
                    } else {
                        predict_mode_0 = predict_mode_0
                            .offset(3 as libc::c_int as isize);
                    }
                }
                while *predict_mode_0 as libc::c_int >= 0 as libc::c_int
                    && (i_best >= 0 as libc::c_int || (*a).i_mbrd >= 2 as libc::c_int)
                {
                    let mut i_satd_0: libc::c_int = 0;
                    let mut i_mode_0: libc::c_int = *predict_mode_0 as libc::c_int;
                    if (*h).mb.b_lossless != 0 {
                        x264_8_predict_lossless_8x8(
                            h,
                            p_dst_by,
                            0 as libc::c_int,
                            idx,
                            i_mode_0,
                            edge.as_mut_ptr(),
                        );
                    } else {
                        ((*h).predict_8x8[i_mode_0 as usize])
                            .expect(
                                "non-null function pointer",
                            )(p_dst_by, edge.as_mut_ptr());
                    }
                    i_satd_0 = sa8d
                        .expect(
                            "non-null function pointer",
                        )(
                        p_dst_by,
                        32 as libc::c_int as intptr_t,
                        p_src_by,
                        16 as libc::c_int as intptr_t,
                    );
                    if i_pred_mode
                        == x264_mb_pred_mode4x4_fix[(i_mode_0 + 1 as libc::c_int)
                            as usize] as libc::c_int
                    {
                        i_satd_0 -= 3 as libc::c_int * lambda;
                    }
                    if i_satd_0 < i_best {
                        i_best = i_satd_0;
                        (*a).i_predict8x8[idx as usize] = i_mode_0;
                    }
                    (*a)
                        .i_satd_i8x8_dir[idx
                        as usize][i_mode_0
                        as usize] = (i_satd_0 + 4 as libc::c_int * lambda) as uint16_t;
                    predict_mode_0 = predict_mode_0.offset(1);
                    predict_mode_0;
                }
                i_cost += i_best + 3 as libc::c_int * lambda;
                if idx == 3 as libc::c_int || i_cost > i_satd_thresh {
                    break;
                }
                if (*h).mb.b_lossless != 0 {
                    x264_8_predict_lossless_8x8(
                        h,
                        p_dst_by,
                        0 as libc::c_int,
                        idx,
                        (*a).i_predict8x8[idx as usize],
                        edge.as_mut_ptr(),
                    );
                } else {
                    ((*h).predict_8x8[(*a).i_predict8x8[idx as usize] as usize])
                        .expect(
                            "non-null function pointer",
                        )(p_dst_by, edge.as_mut_ptr());
                }
                x264_macroblock_cache_intra8x8_pred(
                    h,
                    2 as libc::c_int * x,
                    2 as libc::c_int * y,
                    (*a).i_predict8x8[idx as usize],
                );
            }
            x264_mb_encode_i8x8(
                h,
                0 as libc::c_int,
                idx,
                (*a).i_qp,
                (*a).i_predict8x8[idx as usize],
                edge.as_mut_ptr(),
                0 as libc::c_int,
            );
            idx += 1;
            idx;
        }
        if idx == 3 as libc::c_int {
            (*a).i_satd_i8x8 = i_cost;
            if (*h).mb.i_skip_intra != 0 {
                ((*h).mc.copy[PIXEL_16x16 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*h).mb.pic.i8x8_fdec_buf).as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    p_dst,
                    32 as libc::c_int as intptr_t,
                    16 as libc::c_int,
                );
                (*h)
                    .mb
                    .pic
                    .i8x8_nnz_buf[0 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(0 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h)
                    .mb
                    .pic
                    .i8x8_nnz_buf[1 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(2 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h)
                    .mb
                    .pic
                    .i8x8_nnz_buf[2 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(8 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h)
                    .mb
                    .pic
                    .i8x8_nnz_buf[3 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(10 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h).mb.pic.i8x8_cbp = (*h).mb.i_cbp_luma;
                if (*h).mb.i_skip_intra == 2 as libc::c_int {
                    ((*h).mc.memcpy_aligned)
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*h).mb.pic.i8x8_dct_buf).as_mut_ptr() as *mut libc::c_void,
                        ((*h).dct.luma8x8).as_mut_ptr() as *const libc::c_void,
                        ::core::mem::size_of::<[[dctcoef; 64]; 3]>() as libc::c_ulong,
                    );
                }
            }
        } else {
            static mut cost_div_fix8: [uint16_t; 3] = [
                1024 as libc::c_int as uint16_t,
                512 as libc::c_int as uint16_t,
                341 as libc::c_int as uint16_t,
            ];
            (*a).i_satd_i8x8 = (1 as libc::c_int) << 28 as libc::c_int;
            i_cost = i_cost * cost_div_fix8[idx as usize] as libc::c_int
                >> 8 as libc::c_int;
        }
        static mut i8x8_thresh: [uint8_t; 11] = [
            4 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            4 as libc::c_int as uint8_t,
            5 as libc::c_int as uint8_t,
            5 as libc::c_int as uint8_t,
            5 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
            6 as libc::c_int as uint8_t,
        ];
        if (*a).b_early_terminate != 0
            && (if i_cost < (*a).i_satd_i16x16 { i_cost } else { (*a).i_satd_i16x16 })
                > i_satd_inter
                    * i8x8_thresh[(*h).mb.i_subpel_refine as usize] as libc::c_int
                    >> 2 as libc::c_int
        {
            return;
        }
    }
    if flags & 0x1 as libc::c_uint != 0 {
        let mut i_cost_0: libc::c_int = lambda * (24 as libc::c_int + 16 as libc::c_int);
        let mut i_satd_thresh_0: libc::c_int = if (*a).b_early_terminate != 0 {
            if i_satd_inter
                < (if (*a).i_satd_i16x16 < (*a).i_satd_i8x8 {
                    (*a).i_satd_i16x16
                } else {
                    (*a).i_satd_i8x8
                })
            {
                i_satd_inter
            } else if (*a).i_satd_i16x16 < (*a).i_satd_i8x8 {
                (*a).i_satd_i16x16
            } else {
                (*a).i_satd_i8x8
            }
        } else {
            (1 as libc::c_int) << 28 as libc::c_int
        };
        (*h).mb.i_cbp_luma = 0 as libc::c_int;
        if (*a).b_early_terminate != 0 && (*a).i_mbrd != 0 {
            i_satd_thresh_0 = i_satd_thresh_0 * (10 as libc::c_int - (*a).b_fast_intra)
                / 8 as libc::c_int;
        }
        if (*h).sh.i_type == SLICE_TYPE_B as libc::c_int {
            i_cost_0
                += lambda
                    * i_mb_b_cost_table[I_4x4 as libc::c_int as usize] as libc::c_int;
        }
        idx = 0 as libc::c_int;
        loop {
            let mut p_src_by_0: *mut pixel = p_src
                .offset(block_idx_xy_fenc[idx as usize] as libc::c_int as isize);
            let mut p_dst_by_0: *mut pixel = p_dst
                .offset(block_idx_xy_fdec[idx as usize] as libc::c_int as isize);
            let mut i_best_0: libc::c_int = (1 as libc::c_int) << 28 as libc::c_int;
            let mut i_pred_mode_0: libc::c_int = x264_mb_predict_intra4x4_mode(h, idx);
            let mut predict_mode_1: *const int8_t = predict_4x4_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour4[idx as usize] as libc::c_int,
                idx,
            );
            if (*h).mb.i_neighbour4[idx as usize]
                & (MB_TOPRIGHT as libc::c_int | MB_TOP as libc::c_int) as libc::c_uint
                == MB_TOP as libc::c_int as libc::c_uint
            {
                (*(&mut *p_dst_by_0
                    .offset((4 as libc::c_int - 32 as libc::c_int) as isize)
                    as *mut pixel as *mut x264_union32_t))
                    .i = (*p_dst_by_0
                    .offset((3 as libc::c_int - 32 as libc::c_int) as isize)
                    as libc::c_uint)
                    .wrapping_mul(0x1010101 as libc::c_uint);
            }
            if ((*h).pixf.intra_mbcmp_x9_4x4).is_some()
                && *predict_mode_1.offset(8 as libc::c_int as isize) as libc::c_int
                    >= 0 as libc::c_int
            {
                i_best_0 = ((*h).pixf.intra_mbcmp_x9_4x4)
                    .expect(
                        "non-null function pointer",
                    )(
                    p_src_by_0,
                    p_dst_by_0,
                    cost_i4x4_mode.offset(-(i_pred_mode_0 as isize)),
                );
                i_cost_0 += i_best_0 & 0xffff as libc::c_int;
                i_best_0 >>= 16 as libc::c_int;
                (*a).i_predict4x4[idx as usize] = i_best_0;
                if i_cost_0 > i_satd_thresh_0 || idx == 15 as libc::c_int {
                    break;
                }
                (*h)
                    .mb
                    .cache
                    .intra4x4_pred_mode[x264_scan8[idx as usize]
                    as usize] = i_best_0 as int8_t;
            } else {
                if (*h).mb.b_lossless == 0
                    && *predict_mode_1.offset(5 as libc::c_int as isize) as libc::c_int
                        >= 0 as libc::c_int
                {
                    let mut satd_0: [int32_t; 4] = [0; 4];
                    ((*h).pixf.intra_mbcmp_x3_4x4)
                        .expect(
                            "non-null function pointer",
                        )(p_src_by_0, p_dst_by_0, satd_0.as_mut_ptr());
                    let mut favor_vertical_0: libc::c_int = (satd_0[I_PRED_4x4_H
                        as libc::c_int as usize]
                        > satd_0[I_PRED_4x4_V as libc::c_int as usize]) as libc::c_int;
                    if i_pred_mode_0 < 3 as libc::c_int {
                        satd_0[i_pred_mode_0 as usize] -= 3 as libc::c_int * lambda;
                    }
                    i_best_0 = satd_0[I_PRED_4x4_DC as libc::c_int as usize];
                    (*a).i_predict4x4[idx as usize] = I_PRED_4x4_DC as libc::c_int;
                    if satd_0[I_PRED_4x4_H as libc::c_int as usize] < i_best_0 {
                        i_best_0 = satd_0[I_PRED_4x4_H as libc::c_int as usize];
                        (*a).i_predict4x4[idx as usize] = I_PRED_4x4_H as libc::c_int;
                    }
                    if satd_0[I_PRED_4x4_V as libc::c_int as usize] < i_best_0 {
                        i_best_0 = satd_0[I_PRED_4x4_V as libc::c_int as usize];
                        (*a).i_predict4x4[idx as usize] = I_PRED_4x4_V as libc::c_int;
                    }
                    if (*a).i_mbrd < 1 as libc::c_int + (*a).b_fast_intra {
                        predict_mode_1 = (intra_analysis_shortcut[(*a).b_avoid_topright
                            as usize][(*predict_mode_1.offset(8 as libc::c_int as isize)
                            as libc::c_int >= 0 as libc::c_int) as libc::c_int
                            as usize][favor_vertical_0 as usize])
                            .as_ptr();
                    } else {
                        predict_mode_1 = predict_mode_1
                            .offset(3 as libc::c_int as isize);
                    }
                }
                if i_best_0 > 0 as libc::c_int {
                    while *predict_mode_1 as libc::c_int >= 0 as libc::c_int {
                        let mut i_satd_1: libc::c_int = 0;
                        let mut i_mode_1: libc::c_int = *predict_mode_1 as libc::c_int;
                        if (*h).mb.b_lossless != 0 {
                            x264_8_predict_lossless_4x4(
                                h,
                                p_dst_by_0,
                                0 as libc::c_int,
                                idx,
                                i_mode_1,
                            );
                        } else {
                            ((*h).predict_4x4[i_mode_1 as usize])
                                .expect("non-null function pointer")(p_dst_by_0);
                        }
                        i_satd_1 = ((*h).pixf.mbcmp[PIXEL_4x4 as libc::c_int as usize])
                            .expect(
                                "non-null function pointer",
                            )(
                            p_src_by_0,
                            16 as libc::c_int as intptr_t,
                            p_dst_by_0,
                            32 as libc::c_int as intptr_t,
                        );
                        if i_pred_mode_0
                            == x264_mb_pred_mode4x4_fix[(i_mode_1 + 1 as libc::c_int)
                                as usize] as libc::c_int
                        {
                            i_satd_1 -= lambda * 3 as libc::c_int;
                            if i_satd_1 <= 0 as libc::c_int {
                                i_best_0 = i_satd_1;
                                (*a).i_predict4x4[idx as usize] = i_mode_1;
                                break;
                            }
                        }
                        if i_satd_1 < i_best_0 {
                            i_best_0 = i_satd_1;
                            (*a).i_predict4x4[idx as usize] = i_mode_1;
                        }
                        predict_mode_1 = predict_mode_1.offset(1);
                        predict_mode_1;
                    }
                }
                i_cost_0 += i_best_0 + 3 as libc::c_int * lambda;
                if i_cost_0 > i_satd_thresh_0 || idx == 15 as libc::c_int {
                    break;
                }
                if (*h).mb.b_lossless != 0 {
                    x264_8_predict_lossless_4x4(
                        h,
                        p_dst_by_0,
                        0 as libc::c_int,
                        idx,
                        (*a).i_predict4x4[idx as usize],
                    );
                } else {
                    ((*h).predict_4x4[(*a).i_predict4x4[idx as usize] as usize])
                        .expect("non-null function pointer")(p_dst_by_0);
                }
                (*h)
                    .mb
                    .cache
                    .intra4x4_pred_mode[x264_scan8[idx as usize]
                    as usize] = (*a).i_predict4x4[idx as usize] as int8_t;
            }
            x264_mb_encode_i4x4(
                h,
                0 as libc::c_int,
                idx,
                (*a).i_qp,
                (*a).i_predict4x4[idx as usize],
                0 as libc::c_int,
            );
            idx += 1;
            idx;
        }
        if idx == 15 as libc::c_int {
            (*a).i_satd_i4x4 = i_cost_0;
            if (*h).mb.i_skip_intra != 0 {
                ((*h).mc.copy[PIXEL_16x16 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*h).mb.pic.i4x4_fdec_buf).as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    p_dst,
                    32 as libc::c_int as intptr_t,
                    16 as libc::c_int,
                );
                (*h)
                    .mb
                    .pic
                    .i4x4_nnz_buf[0 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(0 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h)
                    .mb
                    .pic
                    .i4x4_nnz_buf[1 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(2 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h)
                    .mb
                    .pic
                    .i4x4_nnz_buf[2 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(8 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h)
                    .mb
                    .pic
                    .i4x4_nnz_buf[3 as libc::c_int
                    as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(10 as libc::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                    .i;
                (*h).mb.pic.i4x4_cbp = (*h).mb.i_cbp_luma;
                if (*h).mb.i_skip_intra == 2 as libc::c_int {
                    ((*h).mc.memcpy_aligned)
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*h).mb.pic.i4x4_dct_buf).as_mut_ptr() as *mut libc::c_void,
                        ((*h).dct.luma4x4).as_mut_ptr() as *const libc::c_void,
                        ::core::mem::size_of::<[[dctcoef; 16]; 15]>() as libc::c_ulong,
                    );
                }
            }
        } else {
            (*a).i_satd_i4x4 = (1 as libc::c_int) << 28 as libc::c_int;
        }
    }
}
unsafe extern "C" fn intra_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd_thresh: libc::c_int,
) {
    if (*a).b_early_terminate == 0 {
        i_satd_thresh = (1 as libc::c_int) << 28 as libc::c_int;
    }
    if (*a).i_satd_i16x16 < i_satd_thresh {
        (*h).mb.i_type = I_16x16 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_satd_i16x16 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).i_satd_i16x16 = (1 as libc::c_int) << 28 as libc::c_int;
    }
    if (*a).i_satd_i4x4 < i_satd_thresh {
        (*h).mb.i_type = I_4x4 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_satd_i4x4 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).i_satd_i4x4 = (1 as libc::c_int) << 28 as libc::c_int;
    }
    if (*a).i_satd_i8x8 < i_satd_thresh {
        (*h).mb.i_type = I_8x8 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_satd_i8x8 = rd_cost_mb(h, (*a).i_lambda2);
        (*a).i_cbp_i8x8_luma = (*h).mb.i_cbp_luma;
    } else {
        (*a).i_satd_i8x8 = (1 as libc::c_int) << 28 as libc::c_int;
    };
}
unsafe extern "C" fn intra_rd_refine(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut i_satd: uint64_t = 0;
    let mut i_best: uint64_t = 0;
    let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
        == CHROMA_444 as libc::c_int
    {
        3 as libc::c_int
    } else {
        1 as libc::c_int
    };
    (*h).mb.i_skip_intra = 0 as libc::c_int;
    if (*h).mb.i_type == I_16x16 as libc::c_int {
        let mut old_pred_mode: libc::c_int = (*a).i_predict16x16;
        let mut predict_mode: *const int8_t = predict_16x16_mode_available(
            (*h).mb.i_neighbour_intra as libc::c_int,
        );
        let mut i_thresh: libc::c_int = if (*a).b_early_terminate != 0 {
            (*a).i_satd_i16x16_dir[old_pred_mode as usize] * 9 as libc::c_int
                / 8 as libc::c_int
        } else {
            (1 as libc::c_int) << 28 as libc::c_int
        };
        i_best = (*a).i_satd_i16x16 as uint64_t;
        while *predict_mode as libc::c_int >= 0 as libc::c_int {
            let mut i_mode: libc::c_int = *predict_mode as libc::c_int;
            if !(i_mode == old_pred_mode
                || (*a).i_satd_i16x16_dir[i_mode as usize] > i_thresh)
            {
                (*h).mb.i_intra16x16_pred_mode = i_mode;
                i_satd = rd_cost_mb(h, (*a).i_lambda2) as uint64_t;
                if i_satd < i_best {
                    i_best = i_satd;
                    (*a).i_predict16x16 = i_mode;
                }
            }
            predict_mode = predict_mode.offset(1);
            predict_mode;
        }
    }
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_420 as libc::c_int
        || (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as libc::c_int
    {
        let mut predict_mode_0: *const int8_t = predict_chroma_mode_available(
            (*h).mb.i_neighbour_intra as libc::c_int,
        );
        if *predict_mode_0.offset(1 as libc::c_int as isize) as libc::c_int
            >= 0 as libc::c_int
        {
            let mut predict_mode_sorted: [int8_t; 4] = [0; 4];
            let mut i_max: libc::c_int = 0;
            let mut i_thresh_0: libc::c_int = if (*a).b_early_terminate != 0 {
                (*a).i_satd_chroma * 5 as libc::c_int / 4 as libc::c_int
            } else {
                (1 as libc::c_int) << 28 as libc::c_int
            };
            i_max = 0 as libc::c_int;
            while *predict_mode_0 as libc::c_int >= 0 as libc::c_int {
                let mut i_mode_0: libc::c_int = *predict_mode_0 as libc::c_int;
                if (*a).i_satd_chroma_dir[i_mode_0 as usize] < i_thresh_0
                    && i_mode_0 != (*a).i_predict8x8chroma
                {
                    let fresh24 = i_max;
                    i_max = i_max + 1;
                    predict_mode_sorted[fresh24 as usize] = i_mode_0 as int8_t;
                }
                predict_mode_0 = predict_mode_0.offset(1);
                predict_mode_0;
            }
            if i_max > 0 as libc::c_int {
                let mut i_cbp_chroma_best: libc::c_int = (*h).mb.i_cbp_chroma;
                let mut i_chroma_lambda: libc::c_int = x264_lambda2_tab[(*h)
                    .mb
                    .i_chroma_qp as usize];
                i_best = rd_cost_chroma(
                    h,
                    i_chroma_lambda,
                    (*a).i_predict8x8chroma,
                    0 as libc::c_int,
                );
                let mut i: libc::c_int = 0 as libc::c_int;
                while i < i_max {
                    let mut i_mode_1: libc::c_int = predict_mode_sorted[i as usize]
                        as libc::c_int;
                    if (*h).mb.b_lossless != 0 {
                        x264_8_predict_lossless_chroma(h, i_mode_1);
                    } else {
                        ((*h).predict_chroma[i_mode_1 as usize])
                            .expect(
                                "non-null function pointer",
                            )((*h).mb.pic.p_fdec[1 as libc::c_int as usize]);
                        ((*h).predict_chroma[i_mode_1 as usize])
                            .expect(
                                "non-null function pointer",
                            )((*h).mb.pic.p_fdec[2 as libc::c_int as usize]);
                    }
                    i_satd = rd_cost_chroma(
                        h,
                        i_chroma_lambda,
                        i_mode_1,
                        ((*h).mb.i_cbp_chroma != 0 as libc::c_int) as libc::c_int,
                    );
                    if i_satd < i_best {
                        i_best = i_satd;
                        (*a).i_predict8x8chroma = i_mode_1;
                        i_cbp_chroma_best = (*h).mb.i_cbp_chroma;
                    }
                    i += 1;
                    i;
                }
                (*h).mb.i_chroma_pred_mode = (*a).i_predict8x8chroma;
                (*h).mb.i_cbp_chroma = i_cbp_chroma_best;
            }
        }
    }
    if (*h).mb.i_type == I_4x4 as libc::c_int {
        let mut pels: [[pixel4; 4]; 3] = [
            [0 as libc::c_int as pixel4, 0, 0, 0],
            [0; 4],
            [0; 4],
        ];
        let mut nnz: [libc::c_int; 3] = [0 as libc::c_int, 0, 0];
        let mut idx: libc::c_int = 0 as libc::c_int;
        while idx < 16 as libc::c_int {
            let mut dst: [*mut pixel; 3] = [
                ((*h).mb.pic.p_fdec[0 as libc::c_int as usize])
                    .offset(block_idx_xy_fdec[idx as usize] as libc::c_int as isize),
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    ((*h).mb.pic.p_fdec[1 as libc::c_int as usize])
                        .offset(block_idx_xy_fdec[idx as usize] as libc::c_int as isize)
                } else {
                    0 as *mut pixel
                },
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    ((*h).mb.pic.p_fdec[2 as libc::c_int as usize])
                        .offset(block_idx_xy_fdec[idx as usize] as libc::c_int as isize)
                } else {
                    0 as *mut pixel
                },
            ];
            i_best = ((1 as libc::c_ulonglong) << 60 as libc::c_int) as uint64_t;
            let mut predict_mode_1: *const int8_t = predict_4x4_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour4[idx as usize] as libc::c_int,
                idx,
            );
            if (*h).mb.i_neighbour4[idx as usize]
                & (MB_TOPRIGHT as libc::c_int | MB_TOP as libc::c_int) as libc::c_uint
                == MB_TOP as libc::c_int as libc::c_uint
            {
                let mut p: libc::c_int = 0 as libc::c_int;
                while p < plane_count {
                    (*((dst[p as usize])
                        .offset(4 as libc::c_int as isize)
                        .offset(-(32 as libc::c_int as isize)) as *mut x264_union32_t))
                        .i = (*(dst[p as usize])
                        .offset((3 as libc::c_int - 32 as libc::c_int) as isize)
                        as libc::c_uint)
                        .wrapping_mul(0x1010101 as libc::c_uint);
                    p += 1;
                    p;
                }
            }
            while *predict_mode_1 as libc::c_int >= 0 as libc::c_int {
                let mut i_mode_2: libc::c_int = *predict_mode_1 as libc::c_int;
                i_satd = rd_cost_i4x4(h, (*a).i_lambda2, idx, i_mode_2);
                if i_best > i_satd {
                    (*a).i_predict4x4[idx as usize] = i_mode_2;
                    i_best = i_satd;
                    let mut p_0: libc::c_int = 0 as libc::c_int;
                    while p_0 < plane_count {
                        pels[p_0
                            as usize][0 as libc::c_int
                            as usize] = (*((dst[p_0 as usize])
                            .offset((0 as libc::c_int * 32 as libc::c_int) as isize)
                            as *mut x264_union32_t))
                            .i;
                        pels[p_0
                            as usize][1 as libc::c_int
                            as usize] = (*((dst[p_0 as usize])
                            .offset((1 as libc::c_int * 32 as libc::c_int) as isize)
                            as *mut x264_union32_t))
                            .i;
                        pels[p_0
                            as usize][2 as libc::c_int
                            as usize] = (*((dst[p_0 as usize])
                            .offset((2 as libc::c_int * 32 as libc::c_int) as isize)
                            as *mut x264_union32_t))
                            .i;
                        pels[p_0
                            as usize][3 as libc::c_int
                            as usize] = (*((dst[p_0 as usize])
                            .offset((3 as libc::c_int * 32 as libc::c_int) as isize)
                            as *mut x264_union32_t))
                            .i;
                        nnz[p_0
                            as usize] = (*h)
                            .mb
                            .cache
                            .non_zero_count[x264_scan8[(idx + p_0 * 16 as libc::c_int)
                            as usize] as usize] as libc::c_int;
                        p_0 += 1;
                        p_0;
                    }
                }
                predict_mode_1 = predict_mode_1.offset(1);
                predict_mode_1;
            }
            let mut p_1: libc::c_int = 0 as libc::c_int;
            while p_1 < plane_count {
                (*((dst[p_1 as usize])
                    .offset((0 as libc::c_int * 32 as libc::c_int) as isize)
                    as *mut x264_union32_t))
                    .i = pels[p_1 as usize][0 as libc::c_int as usize];
                (*((dst[p_1 as usize])
                    .offset((1 as libc::c_int * 32 as libc::c_int) as isize)
                    as *mut x264_union32_t))
                    .i = pels[p_1 as usize][1 as libc::c_int as usize];
                (*((dst[p_1 as usize])
                    .offset((2 as libc::c_int * 32 as libc::c_int) as isize)
                    as *mut x264_union32_t))
                    .i = pels[p_1 as usize][2 as libc::c_int as usize];
                (*((dst[p_1 as usize])
                    .offset((3 as libc::c_int * 32 as libc::c_int) as isize)
                    as *mut x264_union32_t))
                    .i = pels[p_1 as usize][3 as libc::c_int as usize];
                (*h)
                    .mb
                    .cache
                    .non_zero_count[x264_scan8[(idx + p_1 * 16 as libc::c_int) as usize]
                    as usize] = nnz[p_1 as usize] as uint8_t;
                p_1 += 1;
                p_1;
            }
            (*h)
                .mb
                .cache
                .intra4x4_pred_mode[x264_scan8[idx as usize]
                as usize] = (*a).i_predict4x4[idx as usize] as int8_t;
            idx += 1;
            idx;
        }
    } else if (*h).mb.i_type == I_8x8 as libc::c_int {
        let mut edge: [[pixel; 32]; 4] = [[0; 32]; 4];
        let mut pels_h: [[pixel4; 2]; 3] = [
            [0 as libc::c_int as pixel4, 0],
            [0; 2],
            [0; 2],
        ];
        let mut pels_v: [[pixel; 7]; 3] = [
            [0 as libc::c_int as pixel, 0, 0, 0, 0, 0, 0],
            [0; 7],
            [0; 7],
        ];
        let mut nnz_0: [[uint16_t; 2]; 3] = [
            [0 as libc::c_int as uint16_t, 0],
            [0; 2],
            [0; 2],
        ];
        let mut idx_0: libc::c_int = 0 as libc::c_int;
        while idx_0 < 4 as libc::c_int {
            let mut x: libc::c_int = idx_0 & 1 as libc::c_int;
            let mut y: libc::c_int = idx_0 >> 1 as libc::c_int;
            let mut s8: libc::c_int = 4 as libc::c_int
                + 1 as libc::c_int * 8 as libc::c_int + 2 as libc::c_int * x
                + 16 as libc::c_int * y;
            let mut dst_0: [*mut pixel; 3] = [
                ((*h).mb.pic.p_fdec[0 as libc::c_int as usize])
                    .offset((8 as libc::c_int * x) as isize)
                    .offset((8 as libc::c_int * y * 32 as libc::c_int) as isize),
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    ((*h).mb.pic.p_fdec[1 as libc::c_int as usize])
                        .offset((8 as libc::c_int * x) as isize)
                        .offset((8 as libc::c_int * y * 32 as libc::c_int) as isize)
                } else {
                    0 as *mut pixel
                },
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    ((*h).mb.pic.p_fdec[2 as libc::c_int as usize])
                        .offset((8 as libc::c_int * x) as isize)
                        .offset((8 as libc::c_int * y * 32 as libc::c_int) as isize)
                } else {
                    0 as *mut pixel
                },
            ];
            let mut cbp_luma_new: libc::c_int = 0 as libc::c_int;
            let mut i_thresh_1: libc::c_int = if (*a).b_early_terminate != 0 {
                (*a)
                    .i_satd_i8x8_dir[idx_0
                    as usize][(*a).i_predict8x8[idx_0 as usize] as usize] as libc::c_int
                    * 11 as libc::c_int / 8 as libc::c_int
            } else {
                (1 as libc::c_int) << 28 as libc::c_int
            };
            i_best = ((1 as libc::c_ulonglong) << 60 as libc::c_int) as uint64_t;
            let mut predict_mode_2: *const int8_t = predict_8x8_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour8[idx_0 as usize] as libc::c_int,
                idx_0,
            );
            let mut p_2: libc::c_int = 0 as libc::c_int;
            while p_2 < plane_count {
                ((*h).predict_8x8_filter)
                    .expect(
                        "non-null function pointer",
                    )(
                    dst_0[p_2 as usize],
                    (edge[p_2 as usize]).as_mut_ptr(),
                    (*h).mb.i_neighbour8[idx_0 as usize] as libc::c_int,
                    ALL_NEIGHBORS as libc::c_int,
                );
                p_2 += 1;
                p_2;
            }
            while *predict_mode_2 as libc::c_int >= 0 as libc::c_int {
                let mut i_mode_3: libc::c_int = *predict_mode_2 as libc::c_int;
                if !((*a).i_satd_i8x8_dir[idx_0 as usize][i_mode_3 as usize]
                    as libc::c_int > i_thresh_1)
                {
                    (*h).mb.i_cbp_luma = (*a).i_cbp_i8x8_luma;
                    i_satd = rd_cost_i8x8(
                        h,
                        (*a).i_lambda2,
                        idx_0,
                        i_mode_3,
                        edge.as_mut_ptr(),
                    );
                    if i_best > i_satd {
                        (*a).i_predict8x8[idx_0 as usize] = i_mode_3;
                        cbp_luma_new = (*h).mb.i_cbp_luma;
                        i_best = i_satd;
                        let mut p_3: libc::c_int = 0 as libc::c_int;
                        while p_3 < plane_count {
                            pels_h[p_3
                                as usize][0 as libc::c_int
                                as usize] = (*((dst_0[p_3 as usize])
                                .offset((7 as libc::c_int * 32 as libc::c_int) as isize)
                                .offset(0 as libc::c_int as isize) as *mut x264_union32_t))
                                .i;
                            pels_h[p_3
                                as usize][1 as libc::c_int
                                as usize] = (*((dst_0[p_3 as usize])
                                .offset((7 as libc::c_int * 32 as libc::c_int) as isize)
                                .offset(4 as libc::c_int as isize) as *mut x264_union32_t))
                                .i;
                            if idx_0 & 1 as libc::c_int == 0 {
                                let mut j: libc::c_int = 0 as libc::c_int;
                                while j < 7 as libc::c_int {
                                    pels_v[p_3
                                        as usize][j
                                        as usize] = *(dst_0[p_3 as usize])
                                        .offset(
                                            (7 as libc::c_int + j * 32 as libc::c_int) as isize,
                                        );
                                    j += 1;
                                    j;
                                }
                            }
                            nnz_0[p_3
                                as usize][0 as libc::c_int
                                as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                                .as_mut_ptr()
                                .offset(
                                    (s8 + 0 as libc::c_int * 8 as libc::c_int
                                        + p_3 * 16 as libc::c_int) as isize,
                                ) as *mut uint8_t as *mut x264_union16_t))
                                .i;
                            nnz_0[p_3
                                as usize][1 as libc::c_int
                                as usize] = (*(&mut *((*h).mb.cache.non_zero_count)
                                .as_mut_ptr()
                                .offset(
                                    (s8 + 1 as libc::c_int * 8 as libc::c_int
                                        + p_3 * 16 as libc::c_int) as isize,
                                ) as *mut uint8_t as *mut x264_union16_t))
                                .i;
                            p_3 += 1;
                            p_3;
                        }
                    }
                }
                predict_mode_2 = predict_mode_2.offset(1);
                predict_mode_2;
            }
            (*a).i_cbp_i8x8_luma = cbp_luma_new;
            let mut p_4: libc::c_int = 0 as libc::c_int;
            while p_4 < plane_count {
                (*((dst_0[p_4 as usize])
                    .offset((7 as libc::c_int * 32 as libc::c_int) as isize)
                    .offset(0 as libc::c_int as isize) as *mut x264_union32_t))
                    .i = pels_h[p_4 as usize][0 as libc::c_int as usize];
                (*((dst_0[p_4 as usize])
                    .offset((7 as libc::c_int * 32 as libc::c_int) as isize)
                    .offset(4 as libc::c_int as isize) as *mut x264_union32_t))
                    .i = pels_h[p_4 as usize][1 as libc::c_int as usize];
                if idx_0 & 1 as libc::c_int == 0 {
                    let mut j_0: libc::c_int = 0 as libc::c_int;
                    while j_0 < 7 as libc::c_int {
                        *(dst_0[p_4 as usize])
                            .offset(
                                (7 as libc::c_int + j_0 * 32 as libc::c_int) as isize,
                            ) = pels_v[p_4 as usize][j_0 as usize];
                        j_0 += 1;
                        j_0;
                    }
                }
                (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        (s8 + 0 as libc::c_int * 8 as libc::c_int
                            + p_4 * 16 as libc::c_int) as isize,
                    ) as *mut uint8_t as *mut x264_union16_t))
                    .i = nnz_0[p_4 as usize][0 as libc::c_int as usize];
                (*(&mut *((*h).mb.cache.non_zero_count)
                    .as_mut_ptr()
                    .offset(
                        (s8 + 1 as libc::c_int * 8 as libc::c_int
                            + p_4 * 16 as libc::c_int) as isize,
                    ) as *mut uint8_t as *mut x264_union16_t))
                    .i = nnz_0[p_4 as usize][1 as libc::c_int as usize];
                p_4 += 1;
                p_4;
            }
            x264_macroblock_cache_intra8x8_pred(
                h,
                2 as libc::c_int * x,
                2 as libc::c_int * y,
                (*a).i_predict8x8[idx_0 as usize],
            );
            idx_0 += 1;
            idx_0;
        }
    }
}
unsafe extern "C" fn mb_analyse_inter_p16x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut i_mvc: libc::c_int = 0;
    let mut mvc: [[int16_t; 2]; 8] = [[0; 2]; 8];
    let mut i_halfpel_thresh: libc::c_int = 2147483647 as libc::c_int;
    let mut p_halfpel_thresh: *mut libc::c_int = if (*a).b_early_terminate != 0
        && (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int
    {
        &mut i_halfpel_thresh
    } else {
        0 as *mut libc::c_int
    };
    m.i_pixel = PIXEL_16x16 as libc::c_int;
    m.p_cost_mv = (*a).p_cost_mv;
    m
        .i_stride[0 as libc::c_int
        as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
    m
        .i_stride[1 as libc::c_int
        as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
    m
        .i_stride[2 as libc::c_int
        as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
    m
        .p_fenc[0 as libc::c_int
        as usize] = &mut *(*((*h).mb.pic.p_fenc)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize))
        .offset((0 as libc::c_int + 0 as libc::c_int * 16 as libc::c_int) as isize)
        as *mut pixel;
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
        m
            .p_fenc[1 as libc::c_int
            as usize] = &mut *(*((*h).mb.pic.p_fenc)
            .as_mut_ptr()
            .offset(1 as libc::c_int as isize))
            .offset(
                ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                    + (0 as libc::c_int >> (*h).mb.chroma_v_shift) * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        m
            .p_fenc[2 as libc::c_int
            as usize] = &mut *(*((*h).mb.pic.p_fenc)
            .as_mut_ptr()
            .offset(2 as libc::c_int as isize))
            .offset(
                ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                    + (0 as libc::c_int >> (*h).mb.chroma_v_shift) * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
    }
    (*a).l0.me16x16.cost = 2147483647 as libc::c_int;
    let mut i_ref: libc::c_int = 0 as libc::c_int;
    while i_ref < (*h).mb.pic.i_fref[0 as libc::c_int as usize] {
        m
            .i_ref_cost = *((*a).p_cost_ref[0 as libc::c_int as usize])
            .offset(i_ref as isize) as libc::c_int;
        i_halfpel_thresh -= m.i_ref_cost;
        m
            .p_fref[0 as libc::c_int
            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .offset(
                (0 as libc::c_int
                    + 0 as libc::c_int
                        * *(m.i_stride).as_mut_ptr().offset(0 as libc::c_int as isize))
                    as isize,
            ) as *mut pixel;
        m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            m
                .p_fref[1 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .offset(
                    (0 as libc::c_int
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m
                .p_fref[2 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize))
                .offset(
                    (0 as libc::c_int
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m
                .p_fref[3 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(3 as libc::c_int as isize))
                .offset(
                    (0 as libc::c_int
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            m
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as libc::c_int as isize))
                .offset(
                    (0 as libc::c_int
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m
                .p_fref[8 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as libc::c_int as isize))
                .offset(
                    (0 as libc::c_int
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                m
                    .p_fref[5 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(5 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[6 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(6 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[7 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(7 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[9 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(9 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[10 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(10 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[11 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(11 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
        } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            m
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as libc::c_int as isize))
                .offset(
                    (0 as libc::c_int
                        + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
            m
                .integral = &mut *(*(*((*h).mb.pic.p_integral)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (0 as libc::c_int
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut uint16_t;
        }
        m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        m.i_ref = i_ref;
        m
            .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (0 as libc::c_int
                    + 0 as libc::c_int
                        * *(m.i_stride).as_mut_ptr().offset(0 as libc::c_int as isize))
                    as isize,
            ) as *mut pixel;
        m.weight = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
        x264_8_mb_predict_mv_16x16(h, 0 as libc::c_int, i_ref, (m.mvp).as_mut_ptr());
        if (*h).mb.ref_blind_dupe == i_ref {
            (*((m.mv).as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*a)
                .l0
                .mvc[0 as libc::c_int as usize][0 as libc::c_int as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i;
            x264_8_me_refine_qpel_refdupe(h, &mut m, p_halfpel_thresh);
        } else {
            x264_8_mb_predict_mv_ref16x16(
                h,
                0 as libc::c_int,
                i_ref,
                mvc.as_mut_ptr(),
                &mut i_mvc,
            );
            x264_8_me_search_ref(h, &mut m, mvc.as_mut_ptr(), i_mvc, p_halfpel_thresh);
        }
        (*((*((*h).mb.mvr[0 as libc::c_int as usize][i_ref as usize])
            .offset((*h).mb.i_mb_xy as isize))
            .as_mut_ptr() as *mut x264_union32_t))
            .i = (*((m.mv).as_mut_ptr() as *mut x264_union32_t)).i;
        (*(((*a).l0.mvc[i_ref as usize][0 as libc::c_int as usize]).as_mut_ptr()
            as *mut x264_union32_t))
            .i = (*((m.mv).as_mut_ptr() as *mut x264_union32_t)).i;
        if i_ref == 0 as libc::c_int && (*a).b_try_skip != 0
            && m.cost - m.cost_mv < 300 as libc::c_int * (*a).i_lambda
            && abs(
                m.mv[0 as libc::c_int as usize] as libc::c_int
                    - (*h).mb.cache.pskip_mv[0 as libc::c_int as usize] as libc::c_int,
            )
                + abs(
                    m.mv[1 as libc::c_int as usize] as libc::c_int
                        - (*h).mb.cache.pskip_mv[1 as libc::c_int as usize]
                            as libc::c_int,
                ) <= 1 as libc::c_int
            && x264_8_macroblock_probe_skip(h, 0 as libc::c_int) != 0
        {
            (*h).mb.i_type = P_SKIP as libc::c_int;
            analyse_update_cache(h, a);
            if (*h).mb.cache.pskip_mv[1 as libc::c_int as usize] as libc::c_int
                <= (*h).mb.mv_max_spel[1 as libc::c_int as usize]
                || (*h).i_thread_frames == 1 as libc::c_int
            {} else {
                __assert_fail(
                    b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                        as *const u8 as *const libc::c_char,
                    b"encoder/analyse.c\0" as *const u8 as *const libc::c_char,
                    1305 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 61],
                        &[libc::c_char; 61],
                    >(b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0"))
                        .as_ptr(),
                );
            }
            'c_105063: {
                if (*h).mb.cache.pskip_mv[1 as libc::c_int as usize] as libc::c_int
                    <= (*h).mb.mv_max_spel[1 as libc::c_int as usize]
                    || (*h).i_thread_frames == 1 as libc::c_int
                {} else {
                    __assert_fail(
                        b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                            as *const u8 as *const libc::c_char,
                        b"encoder/analyse.c\0" as *const u8 as *const libc::c_char,
                        1305 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 61],
                            &[libc::c_char; 61],
                        >(
                            b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            return;
        }
        m.cost += m.i_ref_cost;
        i_halfpel_thresh += m.i_ref_cost;
        if m.cost < (*a).l0.me16x16.cost {
            ((*h).mc.memcpy_aligned)
                .expect(
                    "non-null function pointer",
                )(
                &mut (*a).l0.me16x16 as *mut x264_me_t as *mut libc::c_void,
                &mut m as *mut x264_me_t as *const libc::c_void,
                ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
            );
        }
        i_ref += 1;
        i_ref;
    }
    x264_macroblock_cache_ref(
        h,
        0 as libc::c_int,
        0 as libc::c_int,
        4 as libc::c_int,
        4 as libc::c_int,
        0 as libc::c_int,
        (*a).l0.me16x16.i_ref as int8_t,
    );
    if (*a).l0.me16x16.mv[1 as libc::c_int as usize] as libc::c_int
        <= (*h).mb.mv_max_spel[1 as libc::c_int as usize]
        || (*h).i_thread_frames == 1 as libc::c_int
    {} else {
        __assert_fail(
            b"a->l0.me16x16.mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                as *const u8 as *const libc::c_char,
            b"encoder/analyse.c\0" as *const u8 as *const libc::c_char,
            1317 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 61],
                &[libc::c_char; 61],
            >(b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0"))
                .as_ptr(),
        );
    }
    'c_104898: {
        if (*a).l0.me16x16.mv[1 as libc::c_int as usize] as libc::c_int
            <= (*h).mb.mv_max_spel[1 as libc::c_int as usize]
            || (*h).i_thread_frames == 1 as libc::c_int
        {} else {
            __assert_fail(
                b"a->l0.me16x16.mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                    as *const u8 as *const libc::c_char,
                b"encoder/analyse.c\0" as *const u8 as *const libc::c_char,
                1317 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 61],
                    &[libc::c_char; 61],
                >(b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0"))
                    .as_ptr(),
            );
        }
    };
    (*h).mb.i_type = P_L0 as libc::c_int;
    if (*a).i_mbrd != 0 {
        mb_init_fenc_cache(
            h,
            ((*a).i_mbrd >= 2 as libc::c_int
                || (*h).param.analyse.inter & 0x20 as libc::c_uint != 0) as libc::c_int,
        );
        if (*a).l0.me16x16.i_ref == 0 as libc::c_int
            && (*(((*a).l0.me16x16.mv).as_mut_ptr() as *mut x264_union32_t)).i
                == (*(((*h).mb.cache.pskip_mv).as_mut_ptr() as *mut x264_union32_t)).i
            && (*a).b_force_intra == 0
        {
            (*h).mb.i_partition = D_16x16 as libc::c_int;
            x264_macroblock_cache_mv(
                h,
                0 as libc::c_int,
                0 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me16x16.mv).as_mut_ptr() as *mut x264_union32_t)).i,
            );
            (*a).l0.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
            if (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma == 0 {
                (*h).mb.i_type = P_SKIP as libc::c_int;
            }
        }
    }
}
unsafe extern "C" fn mb_analyse_inter_p8x8_mixed_ref(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut p_fenc: *mut *mut pixel = ((*h).mb.pic.p_fenc).as_mut_ptr();
    let mut i_maxref: libc::c_int = (*h).mb.pic.i_fref[0 as libc::c_int as usize]
        - 1 as libc::c_int;
    (*h).mb.i_partition = D_8x8 as libc::c_int;
    if (*a).b_early_terminate != 0
        && (i_maxref > 0 as libc::c_int
            && ((*a).l0.me16x16.i_ref == 0 as libc::c_int
                || (*a).l0.me16x16.i_ref == (*h).mb.ref_blind_dupe)
            && (*h).mb.i_mb_type_top > 0 as libc::c_int
            && (*h).mb.i_mb_type_left[0 as libc::c_int as usize] > 0 as libc::c_int)
    {
        i_maxref = 0 as libc::c_int;
        let mut ref_0: libc::c_int = (*h)
            .mb
            .cache
            .ref_0[0 as libc::c_int
            as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
            + -(8 as libc::c_int) - 1 as libc::c_int) as usize] as libc::c_int;
        if ref_0 > i_maxref && ref_0 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_0;
        }
        let mut ref_1: libc::c_int = (*h)
            .mb
            .cache
            .ref_0[0 as libc::c_int
            as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
            + -(8 as libc::c_int) + 0 as libc::c_int) as usize] as libc::c_int;
        if ref_1 > i_maxref && ref_1 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_1;
        }
        let mut ref_2: libc::c_int = (*h)
            .mb
            .cache
            .ref_0[0 as libc::c_int
            as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
            + -(8 as libc::c_int) + 2 as libc::c_int) as usize] as libc::c_int;
        if ref_2 > i_maxref && ref_2 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_2;
        }
        let mut ref_3: libc::c_int = (*h)
            .mb
            .cache
            .ref_0[0 as libc::c_int
            as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
            + -(8 as libc::c_int) + 4 as libc::c_int) as usize] as libc::c_int;
        if ref_3 > i_maxref && ref_3 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_3;
        }
        let mut ref_4: libc::c_int = (*h)
            .mb
            .cache
            .ref_0[0 as libc::c_int
            as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
            + 0 as libc::c_int - 1 as libc::c_int) as usize] as libc::c_int;
        if ref_4 > i_maxref && ref_4 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_4;
        }
        let mut ref_5: libc::c_int = (*h)
            .mb
            .cache
            .ref_0[0 as libc::c_int
            as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
            + 2 as libc::c_int * 8 as libc::c_int - 1 as libc::c_int) as usize]
            as libc::c_int;
        if ref_5 > i_maxref && ref_5 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_5;
        }
    }
    let mut i_ref: libc::c_int = 0 as libc::c_int;
    while i_ref <= i_maxref {
        (*(((*a).l0.mvc[i_ref as usize][0 as libc::c_int as usize]).as_mut_ptr()
            as *mut x264_union32_t))
            .i = (*((*((*h).mb.mvr[0 as libc::c_int as usize][i_ref as usize])
            .offset((*h).mb.i_mb_xy as isize))
            .as_mut_ptr() as *mut x264_union32_t))
            .i;
        i_ref += 1;
        i_ref;
    }
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        let mut l0m: *mut x264_me_t = &mut *((*a).l0.me8x8)
            .as_mut_ptr()
            .offset(i as isize) as *mut x264_me_t;
        let mut x8: libc::c_int = i & 1 as libc::c_int;
        let mut y8: libc::c_int = i >> 1 as libc::c_int;
        m.i_pixel = PIXEL_8x8 as libc::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        m
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        m
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        m
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*p_fenc.offset(0 as libc::c_int as isize))
            .offset(
                (8 as libc::c_int * x8 + 8 as libc::c_int * y8 * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            m
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(1 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            m
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(2 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        (*l0m).cost = 2147483647 as libc::c_int;
        let mut i_ref_0: libc::c_int = 0 as libc::c_int;
        while i_ref_0 <= i_maxref || i_ref_0 == (*h).mb.ref_blind_dupe {
            m
                .i_ref_cost = *((*a).p_cost_ref[0 as libc::c_int as usize])
                .offset(i_ref_0 as isize) as libc::c_int;
            m
                .p_fref[0 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                m
                    .p_fref[1 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[2 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[3 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(3 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as libc::c_int
            {
                m
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[8 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m
                        .p_fref[5 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref_0 as isize))
                        .as_mut_ptr()
                        .offset(5 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[6 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref_0 as isize))
                        .as_mut_ptr()
                        .offset(6 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[7 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref_0 as isize))
                        .as_mut_ptr()
                        .offset(7 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[9 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref_0 as isize))
                        .as_mut_ptr()
                        .offset(9 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[10 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref_0 as isize))
                        .as_mut_ptr()
                        .offset(10 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[11 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref_0 as isize))
                        .as_mut_ptr()
                        .offset(11 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
            } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                m
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                m
                    .integral = &mut *(*(*((*h).mb.pic.p_integral)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut uint16_t;
            }
            m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            m.i_ref = i_ref_0;
            m
                .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m.weight = ((*h).sh.weight[i_ref_0 as usize]).as_mut_ptr();
            x264_macroblock_cache_ref(
                h,
                2 as libc::c_int * x8,
                2 as libc::c_int * y8,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                i_ref_0 as int8_t,
            );
            x264_8_mb_predict_mv(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i,
                2 as libc::c_int,
                (m.mvp).as_mut_ptr(),
            );
            if (*h).mb.ref_blind_dupe == i_ref_0 {
                (*((m.mv).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(((*a)
                    .l0
                    .mvc[0 as libc::c_int as usize][(i + 1 as libc::c_int) as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                x264_8_me_refine_qpel_refdupe(h, &mut m, 0 as *mut libc::c_int);
            } else {
                x264_8_me_search_ref(
                    h,
                    &mut m,
                    ((*a).l0.mvc[i_ref_0 as usize]).as_mut_ptr(),
                    i + 1 as libc::c_int,
                    0 as *mut libc::c_int,
                );
            }
            m.cost += m.i_ref_cost;
            (*(((*a).l0.mvc[i_ref_0 as usize][(i + 1 as libc::c_int) as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i = (*((m.mv).as_mut_ptr() as *mut x264_union32_t)).i;
            if m.cost < (*l0m).cost {
                ((*h).mc.memcpy_aligned)
                    .expect(
                        "non-null function pointer",
                    )(
                    l0m as *mut libc::c_void,
                    &mut m as *mut x264_me_t as *const libc::c_void,
                    ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
                );
            }
            if i_ref_0 == i_maxref && i_maxref < (*h).mb.ref_blind_dupe {
                i_ref_0 = (*h).mb.ref_blind_dupe;
            } else {
                i_ref_0 += 1;
                i_ref_0;
            }
        }
        x264_macroblock_cache_mv(
            h,
            2 as libc::c_int * x8,
            2 as libc::c_int * y8,
            2 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*(((*l0m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
        x264_macroblock_cache_ref(
            h,
            2 as libc::c_int * x8,
            2 as libc::c_int * y8,
            2 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*l0m).i_ref as int8_t,
        );
        (*a)
            .i_satd8x8[0 as libc::c_int
            as usize][i as usize] = (*l0m).cost - ((*l0m).cost_mv + (*l0m).i_ref_cost);
        if (*h).param.b_cabac == 0
            || (*h).param.analyse.inter & 0x20 as libc::c_uint != 0
        {
            (*l0m).cost
                += (*a).i_lambda
                    * i_sub_mb_p_cost_table[D_L0_8x8 as libc::c_int as usize]
                        as libc::c_int;
        }
        i += 1;
        i;
    }
    (*a)
        .l0
        .i_cost8x8 = (*a).l0.me8x8[0 as libc::c_int as usize].cost
        + (*a).l0.me8x8[1 as libc::c_int as usize].cost
        + (*a).l0.me8x8[2 as libc::c_int as usize].cost
        + (*a).l0.me8x8[3 as libc::c_int as usize].cost;
    if (*h).param.b_cabac == 0
        && (*a).l0.me8x8[0 as libc::c_int as usize].i_ref
            | (*a).l0.me8x8[1 as libc::c_int as usize].i_ref
            | (*a).l0.me8x8[2 as libc::c_int as usize].i_ref
            | (*a).l0.me8x8[3 as libc::c_int as usize].i_ref == 0
    {
        (*a).l0.i_cost8x8
            -= *((*a).p_cost_ref[0 as libc::c_int as usize])
                .offset(0 as libc::c_int as isize) as libc::c_int * 4 as libc::c_int;
    }
    (*(((*h).mb.i_sub_partition).as_mut_ptr() as *mut x264_union32_t))
        .i = (D_L0_8x8 as libc::c_int * 0x1010101 as libc::c_int) as uint32_t;
}
unsafe extern "C" fn mb_analyse_inter_p8x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let i_ref: libc::c_int = if (*h).mb.ref_blind_dupe == (*a).l0.me16x16.i_ref {
        0 as libc::c_int
    } else {
        (*a).l0.me16x16.i_ref
    };
    let i_ref_cost: libc::c_int = if (*h).param.b_cabac != 0 || i_ref != 0 {
        *((*a).p_cost_ref[0 as libc::c_int as usize]).offset(i_ref as isize)
            as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut p_fenc: *mut *mut pixel = ((*h).mb.pic.p_fenc).as_mut_ptr();
    let mut i_mvc: libc::c_int = 0;
    let mut mvc: *mut [int16_t; 2] = ((*a).l0.mvc[i_ref as usize]).as_mut_ptr();
    (*h).mb.i_partition = D_8x8 as libc::c_int;
    i_mvc = 1 as libc::c_int;
    (*((*mvc.offset(0 as libc::c_int as isize)).as_mut_ptr() as *mut x264_union32_t))
        .i = (*(((*a).l0.me16x16.mv).as_mut_ptr() as *mut x264_union32_t)).i;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        let mut m: *mut x264_me_t = &mut *((*a).l0.me8x8).as_mut_ptr().offset(i as isize)
            as *mut x264_me_t;
        let mut x8: libc::c_int = i & 1 as libc::c_int;
        let mut y8: libc::c_int = i >> 1 as libc::c_int;
        (*m).i_pixel = PIXEL_8x8 as libc::c_int;
        (*m).i_ref_cost = i_ref_cost;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m)
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        (*m)
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        (*m)
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        (*m)
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*p_fenc.offset(0 as libc::c_int as isize))
            .offset(
                (8 as libc::c_int * x8 + 8 as libc::c_int * y8 * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(1 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            (*m)
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(2 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        (*m)
            .p_fref[0 as libc::c_int
            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .offset(
                (8 as libc::c_int * x8
                    + 8 as libc::c_int * y8
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as libc::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m)
                .p_fref[1 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[2 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[3 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(3 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[8 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m)
                    .p_fref[5 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(5 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[6 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(6 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[7 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(7 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[9 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(9 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[10 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(10 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[11 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(11 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
        } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
            (*m)
                .integral = &mut *(*(*((*h).mb.pic.p_integral)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m)
            .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (8 as libc::c_int * x8
                    + 8 as libc::c_int * y8
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).weight = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
        x264_8_mb_predict_mv(
            h,
            0 as libc::c_int,
            4 as libc::c_int * i,
            2 as libc::c_int,
            ((*m).mvp).as_mut_ptr(),
        );
        x264_8_me_search_ref(h, m, mvc, i_mvc, 0 as *mut libc::c_int);
        x264_macroblock_cache_mv(
            h,
            2 as libc::c_int * x8,
            2 as libc::c_int * y8,
            2 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*(((*m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
        (*((*mvc.offset(i_mvc as isize)).as_mut_ptr() as *mut x264_union32_t))
            .i = (*(((*m).mv).as_mut_ptr() as *mut x264_union32_t)).i;
        i_mvc += 1;
        i_mvc;
        (*a).i_satd8x8[0 as libc::c_int as usize][i as usize] = (*m).cost - (*m).cost_mv;
        (*m).cost += i_ref_cost;
        if (*h).param.b_cabac == 0
            || (*h).param.analyse.inter & 0x20 as libc::c_uint != 0
        {
            (*m).cost
                += (*a).i_lambda
                    * i_sub_mb_p_cost_table[D_L0_8x8 as libc::c_int as usize]
                        as libc::c_int;
        }
        i += 1;
        i;
    }
    (*a)
        .l0
        .i_cost8x8 = (*a).l0.me8x8[0 as libc::c_int as usize].cost
        + (*a).l0.me8x8[1 as libc::c_int as usize].cost
        + (*a).l0.me8x8[2 as libc::c_int as usize].cost
        + (*a).l0.me8x8[3 as libc::c_int as usize].cost;
    if (*h).param.b_cabac != 0 {
        (*a).l0.i_cost8x8 -= i_ref_cost;
    }
    (*(((*h).mb.i_sub_partition).as_mut_ptr() as *mut x264_union32_t))
        .i = (D_L0_8x8 as libc::c_int * 0x1010101 as libc::c_int) as uint32_t;
}
unsafe extern "C" fn mb_analyse_inter_p16x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: libc::c_int,
) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut p_fenc: *mut *mut pixel = ((*h).mb.pic.p_fenc).as_mut_ptr();
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_16x8 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        let mut l0m: *mut x264_me_t = &mut *((*a).l0.me16x8)
            .as_mut_ptr()
            .offset(i as isize) as *mut x264_me_t;
        let minref: libc::c_int = if (*a).l0.me8x8[(2 as libc::c_int * i) as usize].i_ref
            < (*a).l0.me8x8[(2 as libc::c_int * i + 1 as libc::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[(2 as libc::c_int * i) as usize].i_ref
        } else {
            (*a).l0.me8x8[(2 as libc::c_int * i + 1 as libc::c_int) as usize].i_ref
        };
        let maxref: libc::c_int = if (*a).l0.me8x8[(2 as libc::c_int * i) as usize].i_ref
            > (*a).l0.me8x8[(2 as libc::c_int * i + 1 as libc::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[(2 as libc::c_int * i) as usize].i_ref
        } else {
            (*a).l0.me8x8[(2 as libc::c_int * i + 1 as libc::c_int) as usize].i_ref
        };
        let ref8: [libc::c_int; 2] = [minref, maxref];
        let i_ref8s: libc::c_int = if ref8[0 as libc::c_int as usize]
            == ref8[1 as libc::c_int as usize]
        {
            1 as libc::c_int
        } else {
            2 as libc::c_int
        };
        m.i_pixel = PIXEL_16x8 as libc::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        m
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        m
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        m
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*p_fenc.offset(0 as libc::c_int as isize))
            .offset(
                (0 as libc::c_int + 8 as libc::c_int * i * 16 as libc::c_int) as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            m
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(1 as libc::c_int as isize))
                .offset(
                    ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * i >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            m
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(2 as libc::c_int as isize))
                .offset(
                    ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * i >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        (*l0m).cost = 2147483647 as libc::c_int;
        let mut j: libc::c_int = 0 as libc::c_int;
        while j < i_ref8s {
            let i_ref: libc::c_int = ref8[j as usize];
            m
                .i_ref_cost = *((*a).p_cost_ref[0 as libc::c_int as usize])
                .offset(i_ref as isize) as libc::c_int;
            (*((mvc[0 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*a).l0.mvc[i_ref as usize][0 as libc::c_int as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((mvc[1 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*a)
                .l0
                .mvc[i_ref as usize][(2 as libc::c_int * i + 1 as libc::c_int) as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((mvc[2 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*a)
                .l0
                .mvc[i_ref as usize][(2 as libc::c_int * i + 2 as libc::c_int) as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i;
            m
                .p_fref[0 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .offset(
                    (0 as libc::c_int
                        + 8 as libc::c_int * i
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                m
                    .p_fref[1 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 8 as libc::c_int * i
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[2 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 8 as libc::c_int * i
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[3 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(3 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 8 as libc::c_int * i
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as libc::c_int
            {
                m
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 8 as libc::c_int * i
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[8 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 8 as libc::c_int * i
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m
                        .p_fref[5 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(5 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[6 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(6 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[7 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(7 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[9 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(9 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[10 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(10 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[11 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(11 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
            } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                m
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + (8 as libc::c_int * i >> (*h).mb.chroma_v_shift)
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                m
                    .integral = &mut *(*(*((*h).mb.pic.p_integral)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .offset(
                        (0 as libc::c_int
                            + 8 as libc::c_int * i
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut uint16_t;
            }
            m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            m.i_ref = i_ref;
            m
                .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (0 as libc::c_int
                        + 8 as libc::c_int * i
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m.weight = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
            x264_macroblock_cache_ref(
                h,
                0 as libc::c_int,
                2 as libc::c_int * i,
                4 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                i_ref as int8_t,
            );
            x264_8_mb_predict_mv(
                h,
                0 as libc::c_int,
                8 as libc::c_int * i,
                4 as libc::c_int,
                (m.mvp).as_mut_ptr(),
            );
            if (*h).mb.ref_blind_dupe == i_ref && ref8[0 as libc::c_int as usize] == 0 {
                x264_8_me_refine_qpel_refdupe(h, &mut m, 0 as *mut libc::c_int);
            } else {
                x264_8_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr(),
                    3 as libc::c_int,
                    0 as *mut libc::c_int,
                );
            }
            m.cost += m.i_ref_cost;
            if m.cost < (*l0m).cost {
                ((*h).mc.memcpy_aligned)
                    .expect(
                        "non-null function pointer",
                    )(
                    l0m as *mut libc::c_void,
                    &mut m as *mut x264_me_t as *const libc::c_void,
                    ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
                );
            }
            j += 1;
            j;
        }
        if (*a).b_early_terminate != 0
            && (i == 0
                && (*l0m).cost + (*a).i_cost_est16x8[1 as libc::c_int as usize]
                    > i_best_satd
                        * (4 as libc::c_int + ((*a).i_mbrd != 0) as libc::c_int)
                        / 4 as libc::c_int)
        {
            (*a).l0.i_cost16x8 = (1 as libc::c_int) << 28 as libc::c_int;
            return;
        }
        x264_macroblock_cache_mv(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*(((*l0m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
        x264_macroblock_cache_ref(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*l0m).i_ref as int8_t,
        );
        i += 1;
        i;
    }
    (*a)
        .l0
        .i_cost16x8 = (*a).l0.me16x8[0 as libc::c_int as usize].cost
        + (*a).l0.me16x8[1 as libc::c_int as usize].cost;
}
unsafe extern "C" fn mb_analyse_inter_p8x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: libc::c_int,
) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut p_fenc: *mut *mut pixel = ((*h).mb.pic.p_fenc).as_mut_ptr();
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_8x16 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        let mut l0m: *mut x264_me_t = &mut *((*a).l0.me8x16)
            .as_mut_ptr()
            .offset(i as isize) as *mut x264_me_t;
        let minref: libc::c_int = if (*a).l0.me8x8[i as usize].i_ref
            < (*a).l0.me8x8[(i + 2 as libc::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[i as usize].i_ref
        } else {
            (*a).l0.me8x8[(i + 2 as libc::c_int) as usize].i_ref
        };
        let maxref: libc::c_int = if (*a).l0.me8x8[i as usize].i_ref
            > (*a).l0.me8x8[(i + 2 as libc::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[i as usize].i_ref
        } else {
            (*a).l0.me8x8[(i + 2 as libc::c_int) as usize].i_ref
        };
        let ref8: [libc::c_int; 2] = [minref, maxref];
        let i_ref8s: libc::c_int = if ref8[0 as libc::c_int as usize]
            == ref8[1 as libc::c_int as usize]
        {
            1 as libc::c_int
        } else {
            2 as libc::c_int
        };
        m.i_pixel = PIXEL_8x16 as libc::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        m
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        m
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        m
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*p_fenc.offset(0 as libc::c_int as isize))
            .offset(
                (8 as libc::c_int * i + 0 as libc::c_int * 16 as libc::c_int) as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            m
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(1 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * i >> (*h).mb.chroma_h_shift)
                        + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            m
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(2 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * i >> (*h).mb.chroma_h_shift)
                        + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        (*l0m).cost = 2147483647 as libc::c_int;
        let mut j: libc::c_int = 0 as libc::c_int;
        while j < i_ref8s {
            let i_ref: libc::c_int = ref8[j as usize];
            m
                .i_ref_cost = *((*a).p_cost_ref[0 as libc::c_int as usize])
                .offset(i_ref as isize) as libc::c_int;
            (*((mvc[0 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*a).l0.mvc[i_ref as usize][0 as libc::c_int as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((mvc[1 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*a).l0.mvc[i_ref as usize][(i + 1 as libc::c_int) as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((mvc[2 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*a).l0.mvc[i_ref as usize][(i + 3 as libc::c_int) as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i;
            m
                .p_fref[0 as libc::c_int
                as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * i
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                m
                    .p_fref[1 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[2 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[3 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(3 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as libc::c_int
            {
                m
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m
                    .p_fref[8 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m
                        .p_fref[5 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(5 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[6 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(6 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[7 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(7 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[9 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(9 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[10 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(10 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[11 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(11 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
            } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                m
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                m
                    .integral = &mut *(*(*((*h).mb.pic.p_integral)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut uint16_t;
            }
            m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            m.i_ref = i_ref;
            m
                .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (8 as libc::c_int * i
                        + 0 as libc::c_int
                            * *(m.i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            m.weight = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
            x264_macroblock_cache_ref(
                h,
                2 as libc::c_int * i,
                0 as libc::c_int,
                2 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                i_ref as int8_t,
            );
            x264_8_mb_predict_mv(
                h,
                0 as libc::c_int,
                4 as libc::c_int * i,
                2 as libc::c_int,
                (m.mvp).as_mut_ptr(),
            );
            if (*h).mb.ref_blind_dupe == i_ref && ref8[0 as libc::c_int as usize] == 0 {
                x264_8_me_refine_qpel_refdupe(h, &mut m, 0 as *mut libc::c_int);
            } else {
                x264_8_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr(),
                    3 as libc::c_int,
                    0 as *mut libc::c_int,
                );
            }
            m.cost += m.i_ref_cost;
            if m.cost < (*l0m).cost {
                ((*h).mc.memcpy_aligned)
                    .expect(
                        "non-null function pointer",
                    )(
                    l0m as *mut libc::c_void,
                    &mut m as *mut x264_me_t as *const libc::c_void,
                    ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
                );
            }
            j += 1;
            j;
        }
        if (*a).b_early_terminate != 0
            && (i == 0
                && (*l0m).cost + (*a).i_cost_est8x16[1 as libc::c_int as usize]
                    > i_best_satd
                        * (4 as libc::c_int + ((*a).i_mbrd != 0) as libc::c_int)
                        / 4 as libc::c_int)
        {
            (*a).l0.i_cost8x16 = (1 as libc::c_int) << 28 as libc::c_int;
            return;
        }
        x264_macroblock_cache_mv(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            (*(((*l0m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
        x264_macroblock_cache_ref(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            (*l0m).i_ref as int8_t,
        );
        i += 1;
        i;
    }
    (*a)
        .l0
        .i_cost8x16 = (*a).l0.me8x16[0 as libc::c_int as usize].cost
        + (*a).l0.me8x16[1 as libc::c_int as usize].cost;
}
#[inline(always)]
unsafe extern "C" fn mb_analyse_inter_p4x4_chroma_internal(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut p_fref: *mut *mut pixel,
    mut i8x8: libc::c_int,
    mut size: libc::c_int,
    mut chroma: libc::c_int,
) -> libc::c_int {
    let mut pix1: [pixel; 256] = [0; 256];
    let mut pix2: *mut pixel = pix1.as_mut_ptr().offset(8 as libc::c_int as isize);
    let mut i_stride: libc::c_int = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
    let mut chroma_h_shift: libc::c_int = (chroma <= CHROMA_422 as libc::c_int)
        as libc::c_int;
    let mut chroma_v_shift: libc::c_int = (chroma == CHROMA_420 as libc::c_int)
        as libc::c_int;
    let mut or: libc::c_int = 8 as libc::c_int * (i8x8 & 1 as libc::c_int)
        + (4 as libc::c_int >> chroma_v_shift) * (i8x8 & 2 as libc::c_int) * i_stride;
    let mut i_ref: libc::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    let mut mvy_offset: libc::c_int = if chroma_v_shift != 0
        && (*h).mb.b_interlaced & i_ref != 0
    {
        ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut weight: *mut x264_weight_t = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
    if size == PIXEL_4x4 as libc::c_int {
        let mut m: *mut x264_me_t = ((*a).l0.me4x4[i8x8 as usize]).as_mut_ptr();
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx: libc::c_int = (*m.offset(0 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            let mut mvy: libc::c_int = (*m.offset(0 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx,
                mvy,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx,
                mvy,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset: libc::c_int = 0 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 0 as libc::c_int;
            let mut chroma_height: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 2 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset as isize),
                &mut *pix2.offset(offset as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 0 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 0 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m.offset(0 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m.offset(0 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                2 as libc::c_int,
                chroma_height,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height,
                );
            }
        }
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx_0: libc::c_int = (*m.offset(1 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 2 as libc::c_int;
            let mut mvy_0: libc::c_int = (*m.offset(1 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 2 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_0,
                mvy_0,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 2 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_0,
                mvy_0,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset_0: libc::c_int = 2 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 0 as libc::c_int;
            let mut chroma_height_0: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 2 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset_0 as isize),
                &mut *pix2.offset(offset_0 as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 2 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 0 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m.offset(1 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m.offset(1 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                2 as libc::c_int,
                chroma_height_0,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset_0 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_0 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height_0,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset_0 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset_0 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height_0,
                );
            }
        }
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx_1: libc::c_int = (*m.offset(2 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            let mut mvy_1: libc::c_int = (*m.offset(2 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 2 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 2 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_1,
                mvy_1,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 2 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_1,
                mvy_1,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset_1: libc::c_int = 0 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 2 as libc::c_int;
            let mut chroma_height_1: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 2 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset_1 as isize),
                &mut *pix2.offset(offset_1 as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 0 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 2 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m.offset(2 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m.offset(2 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                2 as libc::c_int,
                chroma_height_1,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset_1 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_1 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height_1,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset_1 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset_1 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height_1,
                );
            }
        }
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx_2: libc::c_int = (*m.offset(3 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 2 as libc::c_int;
            let mut mvy_2: libc::c_int = (*m.offset(3 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 2 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 2 as libc::c_int
                            + 2 as libc::c_int * 2 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_2,
                mvy_2,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 2 as libc::c_int
                            + 2 as libc::c_int * 2 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_2,
                mvy_2,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset_2: libc::c_int = 2 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 2 as libc::c_int;
            let mut chroma_height_2: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 2 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset_2 as isize),
                &mut *pix2.offset(offset_2 as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 2 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 2 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m.offset(3 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m.offset(3 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                2 as libc::c_int,
                chroma_height_2,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset_2 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_2 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height_2,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset_2 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset_2 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height_2,
                );
            }
        }
    } else if size == PIXEL_8x4 as libc::c_int {
        let mut m_0: *mut x264_me_t = ((*a).l0.me8x4[i8x8 as usize]).as_mut_ptr();
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx_3: libc::c_int = (*m_0.offset(0 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            let mut mvy_3: libc::c_int = (*m_0.offset(0 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_3,
                mvy_3,
                2 as libc::c_int * 4 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_3,
                mvy_3,
                2 as libc::c_int * 4 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset_3: libc::c_int = 0 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 0 as libc::c_int;
            let mut chroma_height_3: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 2 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset_3 as isize),
                &mut *pix2.offset(offset_3 as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 0 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 0 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m_0.offset(0 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m_0.offset(0 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                4 as libc::c_int,
                chroma_height_3,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((4 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset_3 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_3 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height_3,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((4 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset_3 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset_3 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height_3,
                );
            }
        }
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx_4: libc::c_int = (*m_0.offset(1 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            let mut mvy_4: libc::c_int = (*m_0.offset(1 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 2 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 2 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_4,
                mvy_4,
                2 as libc::c_int * 4 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 2 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_4,
                mvy_4,
                2 as libc::c_int * 4 as libc::c_int,
                2 as libc::c_int * 2 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset_4: libc::c_int = 0 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 2 as libc::c_int;
            let mut chroma_height_4: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 2 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset_4 as isize),
                &mut *pix2.offset(offset_4 as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 0 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 2 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m_0.offset(1 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m_0.offset(1 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                4 as libc::c_int,
                chroma_height_4,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((4 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset_4 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_4 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height_4,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((4 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset_4 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset_4 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height_4,
                );
            }
        }
    } else {
        let mut m_1: *mut x264_me_t = ((*a).l0.me4x8[i8x8 as usize]).as_mut_ptr();
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx_5: libc::c_int = (*m_1.offset(0 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            let mut mvy_5: libc::c_int = (*m_1.offset(0 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_5,
                mvy_5,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 4 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 0 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_5,
                mvy_5,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 4 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset_5: libc::c_int = 0 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 0 as libc::c_int;
            let mut chroma_height_5: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 4 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset_5 as isize),
                &mut *pix2.offset(offset_5 as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 0 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 0 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m_1.offset(0 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m_1.offset(0 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                2 as libc::c_int,
                chroma_height_5,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset_5 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_5 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height_5,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset_5 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset_5 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height_5,
                );
            }
        }
        if chroma == CHROMA_444 as libc::c_int {
            let mut mvx_6: libc::c_int = (*m_1.offset(1 as libc::c_int as isize))
                .mv[0 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 2 as libc::c_int;
            let mut mvy_6: libc::c_int = (*m_1.offset(1 as libc::c_int as isize))
                .mv[1 as libc::c_int as usize] as libc::c_int
                + 4 as libc::c_int * 2 as libc::c_int * 0 as libc::c_int;
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1
                    .as_mut_ptr()
                    .offset(
                        (2 as libc::c_int * 2 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_6,
                mvy_6,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 4 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix2
                    .offset(
                        (2 as libc::c_int * 2 as libc::c_int
                            + 2 as libc::c_int * 0 as libc::c_int * 16 as libc::c_int)
                            as isize,
                    ),
                16 as libc::c_int as intptr_t,
                &mut *(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                i_stride as intptr_t,
                mvx_6,
                mvy_6,
                2 as libc::c_int * 2 as libc::c_int,
                2 as libc::c_int * 4 as libc::c_int,
                &mut *(*((*h).sh.weight).as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize),
            );
        } else {
            let mut offset_6: libc::c_int = 2 as libc::c_int
                + (2 as libc::c_int >> chroma_v_shift) * 16 as libc::c_int
                    * 0 as libc::c_int;
            let mut chroma_height_6: libc::c_int = (2 as libc::c_int >> chroma_v_shift)
                * 4 as libc::c_int;
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                &mut *pix1.as_mut_ptr().offset(offset_6 as isize),
                &mut *pix2.offset(offset_6 as isize),
                16 as libc::c_int as intptr_t,
                &mut *(*p_fref.offset(4 as libc::c_int as isize))
                    .offset(
                        (or + 2 as libc::c_int * 2 as libc::c_int
                            + (2 as libc::c_int >> chroma_v_shift) * 0 as libc::c_int
                                * i_stride) as isize,
                    ),
                i_stride as intptr_t,
                (*m_1.offset(1 as libc::c_int as isize)).mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (2 as libc::c_int >> chroma_v_shift)
                    * ((*m_1.offset(1 as libc::c_int as isize))
                        .mv[1 as libc::c_int as usize] as libc::c_int + mvy_offset),
                2 as libc::c_int,
                chroma_height_6,
            );
            if !((*weight.offset(1 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(1 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix1.as_mut_ptr().offset(offset_6 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_6 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(1 as libc::c_int as isize),
                    chroma_height_6,
                );
            }
            if !((*weight.offset(2 as libc::c_int as isize)).weightfn).is_null() {
                (*((*weight.offset(2 as libc::c_int as isize)).weightfn)
                    .offset((2 as libc::c_int >> 2 as libc::c_int) as isize))
                    .expect(
                        "non-null function pointer",
                    )(
                    &mut *pix2.offset(offset_6 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *pix2.offset(offset_6 as isize),
                    16 as libc::c_int as intptr_t,
                    &mut *weight.offset(2 as libc::c_int as isize),
                    chroma_height_6,
                );
            }
        }
    }
    let mut oe: libc::c_int = (8 as libc::c_int >> chroma_h_shift)
        * (i8x8 & 1 as libc::c_int)
        + (4 as libc::c_int >> chroma_v_shift) * (i8x8 & 2 as libc::c_int)
            * 16 as libc::c_int;
    let mut chromapix: libc::c_int = if chroma == CHROMA_444 as libc::c_int {
        PIXEL_8x8 as libc::c_int
    } else if chroma == CHROMA_422 as libc::c_int {
        PIXEL_4x8 as libc::c_int
    } else {
        PIXEL_4x4 as libc::c_int
    };
    return ((*h).pixf.mbcmp[chromapix as usize])
        .expect(
            "non-null function pointer",
        )(
        &mut *(*((*h).mb.pic.p_fenc).as_mut_ptr().offset(1 as libc::c_int as isize))
            .offset(oe as isize),
        16 as libc::c_int as intptr_t,
        pix1.as_mut_ptr(),
        16 as libc::c_int as intptr_t,
    )
        + ((*h).pixf.mbcmp[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            &mut *(*((*h).mb.pic.p_fenc).as_mut_ptr().offset(2 as libc::c_int as isize))
                .offset(oe as isize),
            16 as libc::c_int as intptr_t,
            pix2,
            16 as libc::c_int as intptr_t,
        );
}
unsafe extern "C" fn mb_analyse_inter_p4x4_chroma(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut p_fref: *mut *mut pixel,
    mut i8x8: libc::c_int,
    mut size: libc::c_int,
) -> libc::c_int {
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
        return mb_analyse_inter_p4x4_chroma_internal(
            h,
            a,
            p_fref,
            i8x8,
            size,
            CHROMA_444 as libc::c_int,
        )
    } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as libc::c_int
    {
        return mb_analyse_inter_p4x4_chroma_internal(
            h,
            a,
            p_fref,
            i8x8,
            size,
            CHROMA_422 as libc::c_int,
        )
    } else {
        return mb_analyse_inter_p4x4_chroma_internal(
            h,
            a,
            p_fref,
            i8x8,
            size,
            CHROMA_420 as libc::c_int,
        )
    };
}
unsafe extern "C" fn mb_analyse_inter_p4x4(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i8x8: libc::c_int,
) {
    let mut p_fref: *mut *mut pixel = ((*h)
        .mb
        .pic
        .p_fref[0 as libc::c_int as usize][(*a).l0.me8x8[i8x8 as usize].i_ref as usize])
        .as_mut_ptr();
    let mut p_fenc: *mut *mut pixel = ((*h).mb.pic.p_fenc).as_mut_ptr();
    let i_ref: libc::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    (*h).mb.i_partition = D_8x8 as libc::c_int;
    let mut i4x4: libc::c_int = 0 as libc::c_int;
    while i4x4 < 4 as libc::c_int {
        let idx: libc::c_int = 4 as libc::c_int * i8x8 + i4x4;
        let x4: libc::c_int = block_idx_x[idx as usize] as libc::c_int;
        let y4: libc::c_int = block_idx_y[idx as usize] as libc::c_int;
        let i_mvc: libc::c_int = (i4x4 == 0 as libc::c_int) as libc::c_int;
        let mut m: *mut x264_me_t = &mut *(*((*a).l0.me4x4)
            .as_mut_ptr()
            .offset(i8x8 as isize))
            .as_mut_ptr()
            .offset(i4x4 as isize) as *mut x264_me_t;
        (*m).i_pixel = PIXEL_4x4 as libc::c_int;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m)
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        (*m)
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        (*m)
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        (*m)
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*p_fenc.offset(0 as libc::c_int as isize))
            .offset(
                (4 as libc::c_int * x4 + 4 as libc::c_int * y4 * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(1 as libc::c_int as isize))
                .offset(
                    ((4 as libc::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            (*m)
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(2 as libc::c_int as isize))
                .offset(
                    ((4 as libc::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        (*m)
            .p_fref[0 as libc::c_int
            as usize] = &mut *(*p_fref.offset(0 as libc::c_int as isize))
            .offset(
                (4 as libc::c_int * x4
                    + 4 as libc::c_int * y4
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as libc::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m)
                .p_fref[1 as libc::c_int
                as usize] = &mut *(*p_fref.offset(1 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[2 as libc::c_int
                as usize] = &mut *(*p_fref.offset(2 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[3 as libc::c_int
                as usize] = &mut *(*p_fref.offset(3 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*p_fref.offset(4 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[8 as libc::c_int
                as usize] = &mut *(*p_fref.offset(8 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m)
                    .p_fref[5 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(5 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[6 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(6 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[7 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(7 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[9 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(9 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[10 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(10 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[11 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(11 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
        } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*p_fref.offset(4 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
            (*m)
                .integral = &mut *(*(*((*h).mb.pic.p_integral)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m)
            .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (4 as libc::c_int * x4
                    + 4 as libc::c_int * y4
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).weight = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
        x264_8_mb_predict_mv(
            h,
            0 as libc::c_int,
            idx,
            1 as libc::c_int,
            ((*m).mvp).as_mut_ptr(),
        );
        x264_8_me_search_ref(
            h,
            m,
            &mut (*((*a).l0.me8x8).as_mut_ptr().offset(i8x8 as isize)).mv,
            i_mvc,
            0 as *mut libc::c_int,
        );
        x264_macroblock_cache_mv(
            h,
            x4,
            y4,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
            (*(((*m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
        i4x4 += 1;
        i4x4;
    }
    (*a)
        .l0
        .i_cost4x4[i8x8
        as usize] = (*a).l0.me4x4[i8x8 as usize][0 as libc::c_int as usize].cost
        + (*a).l0.me4x4[i8x8 as usize][1 as libc::c_int as usize].cost
        + (*a).l0.me4x4[i8x8 as usize][2 as libc::c_int as usize].cost
        + (*a).l0.me4x4[i8x8 as usize][3 as libc::c_int as usize].cost
        + *((*a).p_cost_ref[0 as libc::c_int as usize]).offset(i_ref as isize)
            as libc::c_int
        + (*a).i_lambda
            * i_sub_mb_p_cost_table[D_L0_4x4 as libc::c_int as usize] as libc::c_int;
    if (*h).mb.b_chroma_me != 0
        && !((*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int)
    {
        (*a).l0.i_cost4x4[i8x8 as usize]
            += mb_analyse_inter_p4x4_chroma(
                h,
                a,
                p_fref,
                i8x8,
                PIXEL_4x4 as libc::c_int,
            );
    }
}
unsafe extern "C" fn mb_analyse_inter_p8x4(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i8x8: libc::c_int,
) {
    let mut p_fref: *mut *mut pixel = ((*h)
        .mb
        .pic
        .p_fref[0 as libc::c_int as usize][(*a).l0.me8x8[i8x8 as usize].i_ref as usize])
        .as_mut_ptr();
    let mut p_fenc: *mut *mut pixel = ((*h).mb.pic.p_fenc).as_mut_ptr();
    let i_ref: libc::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    (*h).mb.i_partition = D_8x8 as libc::c_int;
    let mut i8x4: libc::c_int = 0 as libc::c_int;
    while i8x4 < 2 as libc::c_int {
        let idx: libc::c_int = 4 as libc::c_int * i8x8 + 2 as libc::c_int * i8x4;
        let x4: libc::c_int = block_idx_x[idx as usize] as libc::c_int;
        let y4: libc::c_int = block_idx_y[idx as usize] as libc::c_int;
        let i_mvc: libc::c_int = (i8x4 == 0 as libc::c_int) as libc::c_int;
        let mut m: *mut x264_me_t = &mut *(*((*a).l0.me8x4)
            .as_mut_ptr()
            .offset(i8x8 as isize))
            .as_mut_ptr()
            .offset(i8x4 as isize) as *mut x264_me_t;
        (*m).i_pixel = PIXEL_8x4 as libc::c_int;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m)
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        (*m)
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        (*m)
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        (*m)
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*p_fenc.offset(0 as libc::c_int as isize))
            .offset(
                (4 as libc::c_int * x4 + 4 as libc::c_int * y4 * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(1 as libc::c_int as isize))
                .offset(
                    ((4 as libc::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            (*m)
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(2 as libc::c_int as isize))
                .offset(
                    ((4 as libc::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        (*m)
            .p_fref[0 as libc::c_int
            as usize] = &mut *(*p_fref.offset(0 as libc::c_int as isize))
            .offset(
                (4 as libc::c_int * x4
                    + 4 as libc::c_int * y4
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as libc::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m)
                .p_fref[1 as libc::c_int
                as usize] = &mut *(*p_fref.offset(1 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[2 as libc::c_int
                as usize] = &mut *(*p_fref.offset(2 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[3 as libc::c_int
                as usize] = &mut *(*p_fref.offset(3 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*p_fref.offset(4 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[8 as libc::c_int
                as usize] = &mut *(*p_fref.offset(8 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m)
                    .p_fref[5 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(5 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[6 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(6 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[7 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(7 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[9 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(9 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[10 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(10 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[11 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(11 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
        } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*p_fref.offset(4 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
            (*m)
                .integral = &mut *(*(*((*h).mb.pic.p_integral)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m)
            .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (4 as libc::c_int * x4
                    + 4 as libc::c_int * y4
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).weight = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
        x264_8_mb_predict_mv(
            h,
            0 as libc::c_int,
            idx,
            2 as libc::c_int,
            ((*m).mvp).as_mut_ptr(),
        );
        x264_8_me_search_ref(
            h,
            m,
            &mut (*(*((*a).l0.me4x4).as_mut_ptr().offset(i8x8 as isize))
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .mv,
            i_mvc,
            0 as *mut libc::c_int,
        );
        x264_macroblock_cache_mv(
            h,
            x4,
            y4,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
            (*(((*m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
        i8x4 += 1;
        i8x4;
    }
    (*a)
        .l0
        .i_cost8x4[i8x8
        as usize] = (*a).l0.me8x4[i8x8 as usize][0 as libc::c_int as usize].cost
        + (*a).l0.me8x4[i8x8 as usize][1 as libc::c_int as usize].cost
        + *((*a).p_cost_ref[0 as libc::c_int as usize]).offset(i_ref as isize)
            as libc::c_int
        + (*a).i_lambda
            * i_sub_mb_p_cost_table[D_L0_8x4 as libc::c_int as usize] as libc::c_int;
    if (*h).mb.b_chroma_me != 0
        && !((*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int)
    {
        (*a).l0.i_cost8x4[i8x8 as usize]
            += mb_analyse_inter_p4x4_chroma(
                h,
                a,
                p_fref,
                i8x8,
                PIXEL_8x4 as libc::c_int,
            );
    }
}
unsafe extern "C" fn mb_analyse_inter_p4x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i8x8: libc::c_int,
) {
    let mut p_fref: *mut *mut pixel = ((*h)
        .mb
        .pic
        .p_fref[0 as libc::c_int as usize][(*a).l0.me8x8[i8x8 as usize].i_ref as usize])
        .as_mut_ptr();
    let mut p_fenc: *mut *mut pixel = ((*h).mb.pic.p_fenc).as_mut_ptr();
    let i_ref: libc::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    (*h).mb.i_partition = D_8x8 as libc::c_int;
    let mut i4x8: libc::c_int = 0 as libc::c_int;
    while i4x8 < 2 as libc::c_int {
        let idx: libc::c_int = 4 as libc::c_int * i8x8 + i4x8;
        let x4: libc::c_int = block_idx_x[idx as usize] as libc::c_int;
        let y4: libc::c_int = block_idx_y[idx as usize] as libc::c_int;
        let i_mvc: libc::c_int = (i4x8 == 0 as libc::c_int) as libc::c_int;
        let mut m: *mut x264_me_t = &mut *(*((*a).l0.me4x8)
            .as_mut_ptr()
            .offset(i8x8 as isize))
            .as_mut_ptr()
            .offset(i4x8 as isize) as *mut x264_me_t;
        (*m).i_pixel = PIXEL_4x8 as libc::c_int;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m)
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        (*m)
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        (*m)
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        (*m)
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*p_fenc.offset(0 as libc::c_int as isize))
            .offset(
                (4 as libc::c_int * x4 + 4 as libc::c_int * y4 * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(1 as libc::c_int as isize))
                .offset(
                    ((4 as libc::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            (*m)
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*p_fenc.offset(2 as libc::c_int as isize))
                .offset(
                    ((4 as libc::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        (*m)
            .p_fref[0 as libc::c_int
            as usize] = &mut *(*p_fref.offset(0 as libc::c_int as isize))
            .offset(
                (4 as libc::c_int * x4
                    + 4 as libc::c_int * y4
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as libc::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m)
                .p_fref[1 as libc::c_int
                as usize] = &mut *(*p_fref.offset(1 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[2 as libc::c_int
                as usize] = &mut *(*p_fref.offset(2 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[3 as libc::c_int
                as usize] = &mut *(*p_fref.offset(3 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*p_fref.offset(4 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m)
                .p_fref[8 as libc::c_int
                as usize] = &mut *(*p_fref.offset(8 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m)
                    .p_fref[5 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(5 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[6 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(6 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[7 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(7 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[9 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(9 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[10 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(10 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[11 as libc::c_int
                    as usize] = &mut *(*p_fref.offset(11 as libc::c_int as isize))
                    .offset(
                        (4 as libc::c_int * x4
                            + 4 as libc::c_int * y4
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
        } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m)
                .p_fref[4 as libc::c_int
                as usize] = &mut *(*p_fref.offset(4 as libc::c_int as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + (4 as libc::c_int * y4 >> (*h).mb.chroma_v_shift)
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
            (*m)
                .integral = &mut *(*(*((*h).mb.pic.p_integral)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (4 as libc::c_int * x4
                        + 4 as libc::c_int * y4
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m)
            .p_fref_w = &mut *(*((*h).mb.pic.p_fref_w)
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (4 as libc::c_int * x4
                    + 4 as libc::c_int * y4
                        * *((*m).i_stride)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).weight = ((*h).sh.weight[i_ref as usize]).as_mut_ptr();
        x264_8_mb_predict_mv(
            h,
            0 as libc::c_int,
            idx,
            1 as libc::c_int,
            ((*m).mvp).as_mut_ptr(),
        );
        x264_8_me_search_ref(
            h,
            m,
            &mut (*(*((*a).l0.me4x4).as_mut_ptr().offset(i8x8 as isize))
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .mv,
            i_mvc,
            0 as *mut libc::c_int,
        );
        x264_macroblock_cache_mv(
            h,
            x4,
            y4,
            1 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*(((*m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
        i4x8 += 1;
        i4x8;
    }
    (*a)
        .l0
        .i_cost4x8[i8x8
        as usize] = (*a).l0.me4x8[i8x8 as usize][0 as libc::c_int as usize].cost
        + (*a).l0.me4x8[i8x8 as usize][1 as libc::c_int as usize].cost
        + *((*a).p_cost_ref[0 as libc::c_int as usize]).offset(i_ref as isize)
            as libc::c_int
        + (*a).i_lambda
            * i_sub_mb_p_cost_table[D_L0_4x8 as libc::c_int as usize] as libc::c_int;
    if (*h).mb.b_chroma_me != 0
        && !((*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int)
    {
        (*a).l0.i_cost4x8[i8x8 as usize]
            += mb_analyse_inter_p4x4_chroma(
                h,
                a,
                p_fref,
                i8x8,
                PIXEL_4x8 as libc::c_int,
            );
    }
}
#[inline(always)]
unsafe extern "C" fn analyse_bi_chroma(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut idx: libc::c_int,
    mut i_pixel: libc::c_int,
) -> libc::c_int {
    let mut pix: [[pixel; 256]; 4] = [[0; 256]; 4];
    let mut bi: [[pixel; 256]; 2] = [[0; 256]; 2];
    let mut i_chroma_cost: libc::c_int = 0 as libc::c_int;
    let mut chromapix: libc::c_int = (*h).luma2chroma_pixel[i_pixel as usize]
        as libc::c_int;
    if i_pixel == PIXEL_16x16 as libc::c_int {
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*a).l0.bi16x16.p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l0.bi16x16.i_stride[1 as libc::c_int as usize] as intptr_t,
                (*a).l0.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l0.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int,
                16 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*a).l0.bi16x16.p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l0.bi16x16.i_stride[2 as libc::c_int as usize] as intptr_t,
                (*a).l0.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l0.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int,
                16 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*a).l1.bi16x16.p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l1.bi16x16.i_stride[1 as libc::c_int as usize] as intptr_t,
                (*a).l1.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l1.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int,
                16 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*a).l1.bi16x16.p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l1.bi16x16.i_stride[2 as libc::c_int as usize] as intptr_t,
                (*a).l1.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l1.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int,
                16 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift: libc::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset: libc::c_int = if v_shift & (*h).mb.b_interlaced
                & (*a).l0.bi16x16.i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            let mut l1_mvy_offset: libc::c_int = if v_shift & (*h).mb.b_interlaced
                & (*a).l1.bi16x16.i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l0.bi16x16.p_fref[4 as libc::c_int as usize],
                (*a).l0.bi16x16.i_stride[1 as libc::c_int as usize] as intptr_t,
                (*a).l0.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
                2 as libc::c_int
                    * ((*a).l0.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int
                        + l0_mvy_offset) >> v_shift,
                16 as libc::c_int >> 1 as libc::c_int,
                16 as libc::c_int >> v_shift,
            );
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l1.bi16x16.p_fref[4 as libc::c_int as usize],
                (*a).l1.bi16x16.i_stride[1 as libc::c_int as usize] as intptr_t,
                (*a).l1.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
                2 as libc::c_int
                    * ((*a).l1.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int
                        + l1_mvy_offset) >> v_shift,
                16 as libc::c_int >> 1 as libc::c_int,
                16 as libc::c_int >> v_shift,
            );
        }
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[2 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset((*a).l0.bi16x16.i_ref as isize))[(*a).l1.bi16x16.i_ref as usize]
                as libc::c_int,
        );
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[3 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset((*a).l0.bi16x16.i_ref as isize))[(*a).l1.bi16x16.i_ref as usize]
                as libc::c_int,
        );
        i_chroma_cost = ((*h).pixf.mbcmp[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.bi16x16.p_fenc[1 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
        )
            + ((*h).pixf.mbcmp[chromapix as usize])
                .expect(
                    "non-null function pointer",
                )(
                (*a).l0.bi16x16.p_fenc[2 as libc::c_int as usize],
                16 as libc::c_int as intptr_t,
                (bi[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
            );
    } else if i_pixel == PIXEL_16x8 as libc::c_int {
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l0.me16x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l0.me16x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me16x8[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l0.me16x8[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                16 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l0.me16x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l0.me16x8[idx as usize].i_stride[2 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me16x8[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l0.me16x8[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                16 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l1.me16x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l1.me16x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me16x8[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l1.me16x8[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                16 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l1.me16x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l1.me16x8[idx as usize].i_stride[2 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me16x8[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l1.me16x8[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                16 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift_0: libc::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset_0: libc::c_int = if v_shift_0 & (*h).mb.b_interlaced
                & (*a).l0.me16x8[idx as usize].i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            let mut l1_mvy_offset_0: libc::c_int = if v_shift_0 & (*h).mb.b_interlaced
                & (*a).l1.me16x8[idx as usize].i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l0.me16x8[idx as usize].p_fref[4 as libc::c_int as usize],
                (*a).l0.me16x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me16x8[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                2 as libc::c_int
                    * ((*a).l0.me16x8[idx as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int + l0_mvy_offset_0) >> v_shift_0,
                16 as libc::c_int >> 1 as libc::c_int,
                8 as libc::c_int >> v_shift_0,
            );
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l1.me16x8[idx as usize].p_fref[4 as libc::c_int as usize],
                (*a).l1.me16x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me16x8[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                2 as libc::c_int
                    * ((*a).l1.me16x8[idx as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int + l1_mvy_offset_0) >> v_shift_0,
                16 as libc::c_int >> 1 as libc::c_int,
                8 as libc::c_int >> v_shift_0,
            );
        }
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[2 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me16x8[idx as usize].i_ref as isize,
                ))[(*a).l1.me16x8[idx as usize].i_ref as usize] as libc::c_int,
        );
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[3 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me16x8[idx as usize].i_ref as isize,
                ))[(*a).l1.me16x8[idx as usize].i_ref as usize] as libc::c_int,
        );
        i_chroma_cost = ((*h).pixf.mbcmp[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.me16x8[idx as usize].p_fenc[1 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
        )
            + ((*h).pixf.mbcmp[chromapix as usize])
                .expect(
                    "non-null function pointer",
                )(
                (*a).l0.me16x8[idx as usize].p_fenc[2 as libc::c_int as usize],
                16 as libc::c_int as intptr_t,
                (bi[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
            );
    } else if i_pixel == PIXEL_8x16 as libc::c_int {
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l0.me8x16).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l0.me8x16[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me8x16[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l0.me8x16[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                8 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l0.me8x16).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l0.me8x16[idx as usize].i_stride[2 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me8x16[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l0.me8x16[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                8 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l1.me8x16).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l1.me8x16[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me8x16[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l1.me8x16[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                8 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l1.me8x16).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l1.me8x16[idx as usize].i_stride[2 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me8x16[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                (*a).l1.me8x16[idx as usize].mv[1 as libc::c_int as usize]
                    as libc::c_int,
                8 as libc::c_int,
                16 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift_1: libc::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset_1: libc::c_int = if v_shift_1 & (*h).mb.b_interlaced
                & (*a).l0.me8x16[idx as usize].i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            let mut l1_mvy_offset_1: libc::c_int = if v_shift_1 & (*h).mb.b_interlaced
                & (*a).l1.me8x16[idx as usize].i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l0.me8x16[idx as usize].p_fref[4 as libc::c_int as usize],
                (*a).l0.me8x16[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me8x16[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                2 as libc::c_int
                    * ((*a).l0.me8x16[idx as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int + l0_mvy_offset_1) >> v_shift_1,
                8 as libc::c_int >> 1 as libc::c_int,
                16 as libc::c_int >> v_shift_1,
            );
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l1.me8x16[idx as usize].p_fref[4 as libc::c_int as usize],
                (*a).l1.me8x16[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me8x16[idx as usize].mv[0 as libc::c_int as usize]
                    as libc::c_int,
                2 as libc::c_int
                    * ((*a).l1.me8x16[idx as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int + l1_mvy_offset_1) >> v_shift_1,
                8 as libc::c_int >> 1 as libc::c_int,
                16 as libc::c_int >> v_shift_1,
            );
        }
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[2 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me8x16[idx as usize].i_ref as isize,
                ))[(*a).l1.me8x16[idx as usize].i_ref as usize] as libc::c_int,
        );
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[3 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me8x16[idx as usize].i_ref as isize,
                ))[(*a).l1.me8x16[idx as usize].i_ref as usize] as libc::c_int,
        );
        i_chroma_cost = ((*h).pixf.mbcmp[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.me8x16[idx as usize].p_fenc[1 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
        )
            + ((*h).pixf.mbcmp[chromapix as usize])
                .expect(
                    "non-null function pointer",
                )(
                (*a).l0.me8x16[idx as usize].p_fenc[2 as libc::c_int as usize],
                16 as libc::c_int as intptr_t,
                (bi[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
            );
    } else {
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as libc::c_int {
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l0.me8x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l0.me8x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me8x8[idx as usize].mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l0.me8x8[idx as usize].mv[1 as libc::c_int as usize] as libc::c_int,
                8 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l0.me8x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l0.me8x8[idx as usize].i_stride[2 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me8x8[idx as usize].mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l0.me8x8[idx as usize].mv[1 as libc::c_int as usize] as libc::c_int,
                8 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l1.me8x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(4 as libc::c_int as isize),
                (*a).l1.me8x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me8x8[idx as usize].mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l1.me8x8[idx as usize].mv[1 as libc::c_int as usize] as libc::c_int,
                8 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            ((*h).mc.mc_luma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                &mut *((*((*a).l1.me8x8).as_mut_ptr().offset(idx as isize)).p_fref)
                    .as_mut_ptr()
                    .offset(8 as libc::c_int as isize),
                (*a).l1.me8x8[idx as usize].i_stride[2 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me8x8[idx as usize].mv[0 as libc::c_int as usize] as libc::c_int,
                (*a).l1.me8x8[idx as usize].mv[1 as libc::c_int as usize] as libc::c_int,
                8 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift_2: libc::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset_2: libc::c_int = if v_shift_2 & (*h).mb.b_interlaced
                & (*a).l0.me8x8[idx as usize].i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            let mut l1_mvy_offset_2: libc::c_int = if v_shift_2 & (*h).mb.b_interlaced
                & (*a).l1.me8x8[idx as usize].i_ref != 0
            {
                ((*h).mb.i_mb_y & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int
            } else {
                0 as libc::c_int
            };
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[0 as libc::c_int as usize]).as_mut_ptr(),
                (pix[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l0.me8x8[idx as usize].p_fref[4 as libc::c_int as usize],
                (*a).l0.me8x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l0.me8x8[idx as usize].mv[0 as libc::c_int as usize] as libc::c_int,
                2 as libc::c_int
                    * ((*a).l0.me8x8[idx as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int + l0_mvy_offset_2) >> v_shift_2,
                8 as libc::c_int >> 1 as libc::c_int,
                8 as libc::c_int >> v_shift_2,
            );
            ((*h).mc.mc_chroma)
                .expect(
                    "non-null function pointer",
                )(
                (pix[2 as libc::c_int as usize]).as_mut_ptr(),
                (pix[3 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
                (*a).l1.me8x8[idx as usize].p_fref[4 as libc::c_int as usize],
                (*a).l1.me8x8[idx as usize].i_stride[1 as libc::c_int as usize]
                    as intptr_t,
                (*a).l1.me8x8[idx as usize].mv[0 as libc::c_int as usize] as libc::c_int,
                2 as libc::c_int
                    * ((*a).l1.me8x8[idx as usize].mv[1 as libc::c_int as usize]
                        as libc::c_int + l1_mvy_offset_2) >> v_shift_2,
                8 as libc::c_int >> 1 as libc::c_int,
                8 as libc::c_int >> v_shift_2,
            );
        }
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[2 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me8x8[idx as usize].i_ref as isize,
                ))[(*a).l1.me8x8[idx as usize].i_ref as usize] as libc::c_int,
        );
        ((*h).mc.avg[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (bi[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[1 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (pix[3 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me8x8[idx as usize].i_ref as isize,
                ))[(*a).l1.me8x8[idx as usize].i_ref as usize] as libc::c_int,
        );
        i_chroma_cost = ((*h).pixf.mbcmp[chromapix as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.me8x8[idx as usize].p_fenc[1 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (bi[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
        )
            + ((*h).pixf.mbcmp[chromapix as usize])
                .expect(
                    "non-null function pointer",
                )(
                (*a).l0.me8x8[idx as usize].p_fenc[2 as libc::c_int as usize],
                16 as libc::c_int as intptr_t,
                (bi[1 as libc::c_int as usize]).as_mut_ptr(),
                16 as libc::c_int as intptr_t,
            );
    }
    return i_chroma_cost;
}
unsafe extern "C" fn mb_analyse_inter_direct(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut p_fenc: *mut pixel = (*h).mb.pic.p_fenc[0 as libc::c_int as usize];
    let mut p_fdec: *mut pixel = (*h).mb.pic.p_fdec[0 as libc::c_int as usize];
    (*a)
        .i_cost16x16direct = (*a).i_lambda
        * i_mb_b_cost_table[B_DIRECT as libc::c_int as usize] as libc::c_int;
    if (*h).param.analyse.inter & 0x100 as libc::c_uint != 0 {
        let mut chromapix: libc::c_int = (*h)
            .luma2chroma_pixel[PIXEL_8x8 as libc::c_int as usize] as libc::c_int;
        let mut i: libc::c_int = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            let x: libc::c_int = (i & 1 as libc::c_int) * 8 as libc::c_int;
            let y: libc::c_int = (i >> 1 as libc::c_int) * 8 as libc::c_int;
            (*a)
                .i_cost8x8direct[i
                as usize] = ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
                .expect(
                    "non-null function pointer",
                )(
                &mut *p_fenc.offset((x + y * 16 as libc::c_int) as isize),
                16 as libc::c_int as intptr_t,
                &mut *p_fdec.offset((x + y * 32 as libc::c_int) as isize),
                32 as libc::c_int as intptr_t,
            );
            if (*h).mb.b_chroma_me != 0 {
                let mut fenc_offset: libc::c_int = (x >> (*h).mb.chroma_h_shift)
                    + (y >> (*h).mb.chroma_v_shift) * 16 as libc::c_int;
                let mut fdec_offset: libc::c_int = (x >> (*h).mb.chroma_h_shift)
                    + (y >> (*h).mb.chroma_v_shift) * 32 as libc::c_int;
                (*a).i_cost8x8direct[i as usize]
                    += ((*h).pixf.mbcmp[chromapix as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        &mut *(*((*h).mb.pic.p_fenc)
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize))
                            .offset(fenc_offset as isize),
                        16 as libc::c_int as intptr_t,
                        &mut *(*((*h).mb.pic.p_fdec)
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize))
                            .offset(fdec_offset as isize),
                        32 as libc::c_int as intptr_t,
                    )
                        + ((*h).pixf.mbcmp[chromapix as usize])
                            .expect(
                                "non-null function pointer",
                            )(
                            &mut *(*((*h).mb.pic.p_fenc)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .offset(fenc_offset as isize),
                            16 as libc::c_int as intptr_t,
                            &mut *(*((*h).mb.pic.p_fdec)
                                .as_mut_ptr()
                                .offset(2 as libc::c_int as isize))
                                .offset(fdec_offset as isize),
                            32 as libc::c_int as intptr_t,
                        );
            }
            (*a).i_cost16x16direct += (*a).i_cost8x8direct[i as usize];
            (*a).i_cost8x8direct[i as usize]
                += (*a).i_lambda
                    * i_sub_mb_b_cost_table[D_DIRECT_8x8 as libc::c_int as usize]
                        as libc::c_int;
            i += 1;
            i;
        }
    } else {
        (*a).i_cost16x16direct
            += ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                .expect(
                    "non-null function pointer",
                )(
                p_fenc,
                16 as libc::c_int as intptr_t,
                p_fdec,
                32 as libc::c_int as intptr_t,
            );
        if (*h).mb.b_chroma_me != 0 {
            let mut chromapix_0: libc::c_int = (*h)
                .luma2chroma_pixel[PIXEL_16x16 as libc::c_int as usize] as libc::c_int;
            (*a).i_cost16x16direct
                += ((*h).pixf.mbcmp[chromapix_0 as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
                    16 as libc::c_int as intptr_t,
                    (*h).mb.pic.p_fdec[1 as libc::c_int as usize],
                    32 as libc::c_int as intptr_t,
                )
                    + ((*h).pixf.mbcmp[chromapix_0 as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
                        16 as libc::c_int as intptr_t,
                        (*h).mb.pic.p_fdec[2 as libc::c_int as usize],
                        32 as libc::c_int as intptr_t,
                    );
        }
    };
}
unsafe extern "C" fn mb_analyse_inter_b16x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut pix0: [pixel; 256] = [0; 256];
    let mut pix1: [pixel; 256] = [0; 256];
    let mut src0: *mut pixel = 0 as *mut pixel;
    let mut src1: *mut pixel = 0 as *mut pixel;
    let mut stride0: intptr_t = 16 as libc::c_int as intptr_t;
    let mut stride1: intptr_t = 16 as libc::c_int as intptr_t;
    let mut i_ref: libc::c_int = 0;
    let mut i_mvc: libc::c_int = 0;
    let mut mvc: [[int16_t; 2]; 9] = [[0; 2]; 9];
    let mut try_skip: libc::c_int = (*a).b_try_skip;
    let mut list1_skipped: libc::c_int = 0 as libc::c_int;
    let mut i_halfpel_thresh: [libc::c_int; 2] = [
        2147483647 as libc::c_int,
        2147483647 as libc::c_int,
    ];
    let mut p_halfpel_thresh: [*mut libc::c_int; 2] = [
        if (*a).b_early_terminate != 0
            && (*h).mb.pic.i_fref[0 as libc::c_int as usize] > 1 as libc::c_int
        {
            &mut *i_halfpel_thresh.as_mut_ptr().offset(0 as libc::c_int as isize)
                as *mut libc::c_int
        } else {
            0 as *mut libc::c_int
        },
        if (*a).b_early_terminate != 0
            && (*h).mb.pic.i_fref[1 as libc::c_int as usize] > 1 as libc::c_int
        {
            &mut *i_halfpel_thresh.as_mut_ptr().offset(1 as libc::c_int as isize)
                as *mut libc::c_int
        } else {
            0 as *mut libc::c_int
        },
    ];
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    m.i_pixel = PIXEL_16x16 as libc::c_int;
    m.p_cost_mv = (*a).p_cost_mv;
    m
        .i_stride[0 as libc::c_int
        as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
    m
        .i_stride[1 as libc::c_int
        as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
    m
        .i_stride[2 as libc::c_int
        as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
    m
        .p_fenc[0 as libc::c_int
        as usize] = &mut *(*((*h).mb.pic.p_fenc)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize))
        .offset((0 as libc::c_int + 0 as libc::c_int * 16 as libc::c_int) as isize)
        as *mut pixel;
    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
        m
            .p_fenc[1 as libc::c_int
            as usize] = &mut *(*((*h).mb.pic.p_fenc)
            .as_mut_ptr()
            .offset(1 as libc::c_int as isize))
            .offset(
                ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                    + (0 as libc::c_int >> (*h).mb.chroma_v_shift) * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        m
            .p_fenc[2 as libc::c_int
            as usize] = &mut *(*((*h).mb.pic.p_fenc)
            .as_mut_ptr()
            .offset(2 as libc::c_int as isize))
            .offset(
                ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                    + (0 as libc::c_int >> (*h).mb.chroma_v_shift) * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
    }
    (*a).l0.me16x16.cost = 2147483647 as libc::c_int;
    (*a).l1.me16x16.cost = 2147483647 as libc::c_int;
    let mut l: libc::c_int = 1 as libc::c_int;
    while l >= 0 as libc::c_int {
        let mut lX: *mut x264_mb_analysis_list_t = if l != 0 {
            &mut (*a).l1
        } else {
            &mut (*a).l0
        };
        i_ref = if list1_skipped != 0 && l == 1 as libc::c_int {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        };
        while i_ref < (*h).mb.pic.i_fref[l as usize] {
            if try_skip != 0 && l == 1 as libc::c_int && i_ref > 0 as libc::c_int {
                list1_skipped = 1 as libc::c_int;
                break;
            } else {
                m
                    .i_ref_cost = *((*a).p_cost_ref[l as usize]).offset(i_ref as isize)
                    as libc::c_int;
                m
                    .p_fref[0 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(l as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m
                        .p_fref[1 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[2 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[3 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_444 as libc::c_int
                {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[8 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m
                            .p_fref[5 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[6 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[7 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[9 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[10 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[11 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                    }
                } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                    m
                        .integral = &mut *(*(*((*h).mb.pic.p_integral)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .offset(
                            (0 as libc::c_int
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                x264_8_mb_predict_mv_16x16(h, l, i_ref, (m.mvp).as_mut_ptr());
                x264_8_mb_predict_mv_ref16x16(h, l, i_ref, mvc.as_mut_ptr(), &mut i_mvc);
                x264_8_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr(),
                    i_mvc,
                    p_halfpel_thresh[l as usize],
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX).me16x16.cost {
                    ((*h).mc.memcpy_aligned)
                        .expect(
                            "non-null function pointer",
                        )(
                        &mut (*lX).me16x16 as *mut x264_me_t as *mut libc::c_void,
                        &mut m as *mut x264_me_t as *const libc::c_void,
                        ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
                    );
                }
                (*(((*lX).mvc[i_ref as usize][0 as libc::c_int as usize]).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((m.mv).as_mut_ptr() as *mut x264_union32_t)).i;
                (*((*((*h).mb.mvr[l as usize][i_ref as usize])
                    .offset((*h).mb.i_mb_xy as isize))
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*((m.mv).as_mut_ptr() as *mut x264_union32_t)).i;
                if i_ref == 0 as libc::c_int && try_skip != 0 {
                    if abs(
                        (*lX).me16x16.mv[0 as libc::c_int as usize] as libc::c_int
                            - (*h)
                                .mb
                                .cache
                                .direct_mv[l
                                as usize][0 as libc::c_int
                                as usize][0 as libc::c_int as usize] as libc::c_int,
                    )
                        + abs(
                            (*lX).me16x16.mv[1 as libc::c_int as usize] as libc::c_int
                                - (*h)
                                    .mb
                                    .cache
                                    .direct_mv[l
                                    as usize][0 as libc::c_int
                                    as usize][1 as libc::c_int as usize] as libc::c_int,
                        ) > 1 as libc::c_int
                    {
                        try_skip = 0 as libc::c_int;
                    } else if l == 0 {
                        (*h).mb.i_type = B_SKIP as libc::c_int;
                        analyse_update_cache(h, a);
                        return;
                    }
                }
                i_ref += 1;
                i_ref;
            }
        }
        if list1_skipped != 0 && l == 1 as libc::c_int
            && i_ref == (*h).mb.pic.i_fref[1 as libc::c_int as usize]
        {
            break;
        }
        if list1_skipped != 0 && l == 0 as libc::c_int {
            l = 1 as libc::c_int;
        } else {
            l -= 1;
            l;
        }
    }
    ((*h).mc.memcpy_aligned)
        .expect(
            "non-null function pointer",
        )(
        &mut (*a).l0.bi16x16 as *mut x264_me_t as *mut libc::c_void,
        &mut (*a).l0.me16x16 as *mut x264_me_t as *const libc::c_void,
        ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
    );
    ((*h).mc.memcpy_aligned)
        .expect(
            "non-null function pointer",
        )(
        &mut (*a).l1.bi16x16 as *mut x264_me_t as *mut libc::c_void,
        &mut (*a).l1.me16x16 as *mut x264_me_t as *const libc::c_void,
        ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
    );
    let mut ref_costs: libc::c_int = *((*a).p_cost_ref[0 as libc::c_int as usize])
        .offset((*a).l0.bi16x16.i_ref as isize) as libc::c_int
        + *((*a).p_cost_ref[1 as libc::c_int as usize])
            .offset((*a).l1.bi16x16.i_ref as isize) as libc::c_int;
    src0 = ((*h).mc.get_ref)
        .expect(
            "non-null function pointer",
        )(
        pix0.as_mut_ptr(),
        &mut stride0,
        ((*h).mb.pic.p_fref[0 as libc::c_int as usize][(*a).l0.bi16x16.i_ref as usize])
            .as_mut_ptr(),
        (*h).mb.pic.i_stride[0 as libc::c_int as usize] as intptr_t,
        (*a).l0.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
        (*a).l0.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int,
        16 as libc::c_int,
        16 as libc::c_int,
        x264_zero.as_mut_ptr() as *const x264_weight_t,
    );
    src1 = ((*h).mc.get_ref)
        .expect(
            "non-null function pointer",
        )(
        pix1.as_mut_ptr(),
        &mut stride1,
        ((*h).mb.pic.p_fref[1 as libc::c_int as usize][(*a).l1.bi16x16.i_ref as usize])
            .as_mut_ptr(),
        (*h).mb.pic.i_stride[0 as libc::c_int as usize] as intptr_t,
        (*a).l1.bi16x16.mv[0 as libc::c_int as usize] as libc::c_int,
        (*a).l1.bi16x16.mv[1 as libc::c_int as usize] as libc::c_int,
        16 as libc::c_int,
        16 as libc::c_int,
        x264_zero.as_mut_ptr() as *const x264_weight_t,
    );
    ((*h).mc.avg[PIXEL_16x16 as libc::c_int as usize])
        .expect(
            "non-null function pointer",
        )(
        pix0.as_mut_ptr(),
        16 as libc::c_int as intptr_t,
        src0,
        stride0,
        src1,
        stride1,
        (*((*h).mb.bipred_weight)
            .offset((*a).l0.bi16x16.i_ref as isize))[(*a).l1.bi16x16.i_ref as usize]
            as libc::c_int,
    );
    (*a)
        .i_cost16x16bi = ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
        .expect(
            "non-null function pointer",
        )(
        (*h).mb.pic.p_fenc[0 as libc::c_int as usize],
        16 as libc::c_int as intptr_t,
        pix0.as_mut_ptr(),
        16 as libc::c_int as intptr_t,
    ) + ref_costs + (*a).l0.bi16x16.cost_mv + (*a).l1.bi16x16.cost_mv;
    if (*h).mb.b_chroma_me != 0 {
        (*a).i_cost16x16bi
            += analyse_bi_chroma(h, a, 0 as libc::c_int, PIXEL_16x16 as libc::c_int);
    }
    if (*(((*a).l0.bi16x16.mv).as_mut_ptr() as *mut x264_union32_t)).i
        | (*(((*a).l1.bi16x16.mv).as_mut_ptr() as *mut x264_union32_t)).i != 0
    {
        let mut l0_mv_cost: libc::c_int = *((*a).l0.bi16x16.p_cost_mv)
            .offset(
                -((*a).l0.bi16x16.mvp[0 as libc::c_int as usize] as libc::c_int) as isize,
            ) as libc::c_int
            + *((*a).l0.bi16x16.p_cost_mv)
                .offset(
                    -((*a).l0.bi16x16.mvp[1 as libc::c_int as usize] as libc::c_int)
                        as isize,
                ) as libc::c_int;
        let mut l1_mv_cost: libc::c_int = *((*a).l1.bi16x16.p_cost_mv)
            .offset(
                -((*a).l1.bi16x16.mvp[0 as libc::c_int as usize] as libc::c_int) as isize,
            ) as libc::c_int
            + *((*a).l1.bi16x16.p_cost_mv)
                .offset(
                    -((*a).l1.bi16x16.mvp[1 as libc::c_int as usize] as libc::c_int)
                        as isize,
                ) as libc::c_int;
        ((*h).mc.avg[PIXEL_16x16 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            pix0.as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            (*h)
                .mb
                .pic
                .p_fref[0 as libc::c_int
                as usize][(*a).l0.bi16x16.i_ref as usize][0 as libc::c_int as usize],
            (*h).mb.pic.i_stride[0 as libc::c_int as usize] as intptr_t,
            (*h)
                .mb
                .pic
                .p_fref[1 as libc::c_int
                as usize][(*a).l1.bi16x16.i_ref as usize][0 as libc::c_int as usize],
            (*h).mb.pic.i_stride[0 as libc::c_int as usize] as intptr_t,
            (*((*h).mb.bipred_weight)
                .offset((*a).l0.bi16x16.i_ref as isize))[(*a).l1.bi16x16.i_ref as usize]
                as libc::c_int,
        );
        let mut cost00: libc::c_int = ((*h)
            .pixf
            .mbcmp[PIXEL_16x16 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (*h).mb.pic.p_fenc[0 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            pix0.as_mut_ptr(),
            16 as libc::c_int as intptr_t,
        ) + ref_costs + l0_mv_cost + l1_mv_cost;
        if (*h).mb.b_chroma_me != 0 && cost00 < (*a).i_cost16x16bi {
            let mut bi: [pixel; 256] = [0; 256];
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as libc::c_int
            {
                ((*h).mc.avg[PIXEL_16x16 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    bi.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    (*h)
                        .mb
                        .pic
                        .p_fref[0 as libc::c_int
                        as usize][(*a).l0.bi16x16.i_ref
                        as usize][4 as libc::c_int as usize],
                    (*h).mb.pic.i_stride[1 as libc::c_int as usize] as intptr_t,
                    (*h)
                        .mb
                        .pic
                        .p_fref[1 as libc::c_int
                        as usize][(*a).l1.bi16x16.i_ref
                        as usize][4 as libc::c_int as usize],
                    (*h).mb.pic.i_stride[1 as libc::c_int as usize] as intptr_t,
                    (*((*h).mb.bipred_weight)
                        .offset(
                            (*a).l0.bi16x16.i_ref as isize,
                        ))[(*a).l1.bi16x16.i_ref as usize] as libc::c_int,
                );
                cost00
                    += ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
                        16 as libc::c_int as intptr_t,
                        bi.as_mut_ptr(),
                        16 as libc::c_int as intptr_t,
                    );
                ((*h).mc.avg[PIXEL_16x16 as libc::c_int as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    bi.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    (*h)
                        .mb
                        .pic
                        .p_fref[0 as libc::c_int
                        as usize][(*a).l0.bi16x16.i_ref
                        as usize][8 as libc::c_int as usize],
                    (*h).mb.pic.i_stride[2 as libc::c_int as usize] as intptr_t,
                    (*h)
                        .mb
                        .pic
                        .p_fref[1 as libc::c_int
                        as usize][(*a).l1.bi16x16.i_ref
                        as usize][8 as libc::c_int as usize],
                    (*h).mb.pic.i_stride[2 as libc::c_int as usize] as intptr_t,
                    (*((*h).mb.bipred_weight)
                        .offset(
                            (*a).l0.bi16x16.i_ref as isize,
                        ))[(*a).l1.bi16x16.i_ref as usize] as libc::c_int,
                );
                cost00
                    += ((*h).pixf.mbcmp[PIXEL_16x16 as libc::c_int as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
                        16 as libc::c_int as intptr_t,
                        bi.as_mut_ptr(),
                        16 as libc::c_int as intptr_t,
                    );
            } else {
                let mut pixuv: [[pixel; 256]; 2] = [[0; 256]; 2];
                let mut chromapix: libc::c_int = (*h)
                    .luma2chroma_pixel[PIXEL_16x16 as libc::c_int as usize]
                    as libc::c_int;
                let mut v_shift: libc::c_int = (*h).mb.chroma_v_shift;
                if v_shift & (*h).mb.b_interlaced & (*a).l0.bi16x16.i_ref != 0 {
                    let mut l0_mvy_offset: libc::c_int = ((*h).mb.i_mb_y
                        & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int;
                    ((*h).mc.mc_chroma)
                        .expect(
                            "non-null function pointer",
                        )(
                        (pixuv[0 as libc::c_int as usize]).as_mut_ptr(),
                        (pixuv[0 as libc::c_int as usize])
                            .as_mut_ptr()
                            .offset(8 as libc::c_int as isize),
                        16 as libc::c_int as intptr_t,
                        (*h)
                            .mb
                            .pic
                            .p_fref[0 as libc::c_int
                            as usize][(*a).l0.bi16x16.i_ref
                            as usize][4 as libc::c_int as usize],
                        (*h).mb.pic.i_stride[1 as libc::c_int as usize] as intptr_t,
                        0 as libc::c_int,
                        0 as libc::c_int + l0_mvy_offset,
                        8 as libc::c_int,
                        8 as libc::c_int,
                    );
                } else {
                    ((*h).mc.load_deinterleave_chroma_fenc)
                        .expect(
                            "non-null function pointer",
                        )(
                        (pixuv[0 as libc::c_int as usize]).as_mut_ptr(),
                        (*h)
                            .mb
                            .pic
                            .p_fref[0 as libc::c_int
                            as usize][(*a).l0.bi16x16.i_ref
                            as usize][4 as libc::c_int as usize],
                        (*h).mb.pic.i_stride[1 as libc::c_int as usize] as intptr_t,
                        16 as libc::c_int >> v_shift,
                    );
                }
                if v_shift & (*h).mb.b_interlaced & (*a).l1.bi16x16.i_ref != 0 {
                    let mut l1_mvy_offset: libc::c_int = ((*h).mb.i_mb_y
                        & 1 as libc::c_int) * 4 as libc::c_int - 2 as libc::c_int;
                    ((*h).mc.mc_chroma)
                        .expect(
                            "non-null function pointer",
                        )(
                        (pixuv[1 as libc::c_int as usize]).as_mut_ptr(),
                        (pixuv[1 as libc::c_int as usize])
                            .as_mut_ptr()
                            .offset(8 as libc::c_int as isize),
                        16 as libc::c_int as intptr_t,
                        (*h)
                            .mb
                            .pic
                            .p_fref[1 as libc::c_int
                            as usize][(*a).l1.bi16x16.i_ref
                            as usize][4 as libc::c_int as usize],
                        (*h).mb.pic.i_stride[1 as libc::c_int as usize] as intptr_t,
                        0 as libc::c_int,
                        0 as libc::c_int + l1_mvy_offset,
                        8 as libc::c_int,
                        8 as libc::c_int,
                    );
                } else {
                    ((*h).mc.load_deinterleave_chroma_fenc)
                        .expect(
                            "non-null function pointer",
                        )(
                        (pixuv[1 as libc::c_int as usize]).as_mut_ptr(),
                        (*h)
                            .mb
                            .pic
                            .p_fref[1 as libc::c_int
                            as usize][(*a).l1.bi16x16.i_ref
                            as usize][4 as libc::c_int as usize],
                        (*h).mb.pic.i_stride[1 as libc::c_int as usize] as intptr_t,
                        16 as libc::c_int >> v_shift,
                    );
                }
                ((*h).mc.avg[chromapix as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    bi.as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    (pixuv[0 as libc::c_int as usize]).as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    (pixuv[1 as libc::c_int as usize]).as_mut_ptr(),
                    16 as libc::c_int as intptr_t,
                    (*((*h).mb.bipred_weight)
                        .offset(
                            (*a).l0.bi16x16.i_ref as isize,
                        ))[(*a).l1.bi16x16.i_ref as usize] as libc::c_int,
                );
                ((*h).mc.avg[chromapix as usize])
                    .expect(
                        "non-null function pointer",
                    )(
                    bi.as_mut_ptr().offset(8 as libc::c_int as isize),
                    16 as libc::c_int as intptr_t,
                    (pixuv[0 as libc::c_int as usize])
                        .as_mut_ptr()
                        .offset(8 as libc::c_int as isize),
                    16 as libc::c_int as intptr_t,
                    (pixuv[1 as libc::c_int as usize])
                        .as_mut_ptr()
                        .offset(8 as libc::c_int as isize),
                    16 as libc::c_int as intptr_t,
                    (*((*h).mb.bipred_weight)
                        .offset(
                            (*a).l0.bi16x16.i_ref as isize,
                        ))[(*a).l1.bi16x16.i_ref as usize] as libc::c_int,
                );
                cost00
                    += ((*h).pixf.mbcmp[chromapix as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
                        16 as libc::c_int as intptr_t,
                        bi.as_mut_ptr(),
                        16 as libc::c_int as intptr_t,
                    )
                        + ((*h).pixf.mbcmp[chromapix as usize])
                            .expect(
                                "non-null function pointer",
                            )(
                            (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
                            16 as libc::c_int as intptr_t,
                            bi.as_mut_ptr().offset(8 as libc::c_int as isize),
                            16 as libc::c_int as intptr_t,
                        );
            }
        }
        if cost00 < (*a).i_cost16x16bi {
            (*(((*a).l0.bi16x16.mv).as_mut_ptr() as *mut x264_union32_t))
                .i = 0 as libc::c_int as uint32_t;
            (*(((*a).l1.bi16x16.mv).as_mut_ptr() as *mut x264_union32_t))
                .i = 0 as libc::c_int as uint32_t;
            (*a).l0.bi16x16.cost_mv = l0_mv_cost;
            (*a).l1.bi16x16.cost_mv = l1_mv_cost;
            (*a).i_cost16x16bi = cost00;
        }
    }
    (*a).i_cost16x16bi
        += (*a).i_lambda
            * i_mb_b_cost_table[B_BI_BI as libc::c_int as usize] as libc::c_int;
    (*a).l0.me16x16.cost
        += (*a).i_lambda
            * i_mb_b_cost_table[B_L0_L0 as libc::c_int as usize] as libc::c_int;
    (*a).l1.me16x16.cost
        += (*a).i_lambda
            * i_mb_b_cost_table[B_L1_L1 as libc::c_int as usize] as libc::c_int;
}
#[inline]
unsafe extern "C" fn mb_cache_mv_p8x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: libc::c_int,
) {
    let mut x: libc::c_int = 2 as libc::c_int * (i & 1 as libc::c_int);
    let mut y: libc::c_int = i & 2 as libc::c_int;
    match (*h).mb.i_sub_partition[i as usize] as libc::c_int {
        3 => {
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me8x8[i as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i,
            );
        }
        1 => {
            x264_macroblock_cache_mv(
                h,
                x,
                y + 0 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me8x4[i as usize][0 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y + 1 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me8x4[i as usize][1 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
        }
        2 => {
            x264_macroblock_cache_mv(
                h,
                x + 0 as libc::c_int,
                y,
                1 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me4x8[i as usize][0 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 1 as libc::c_int,
                y,
                1 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me4x8[i as usize][1 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
        }
        0 => {
            x264_macroblock_cache_mv(
                h,
                x + 0 as libc::c_int,
                y + 0 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me4x4[i as usize][0 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 1 as libc::c_int,
                y + 0 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me4x4[i as usize][1 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 0 as libc::c_int,
                y + 1 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me4x4[i as usize][2 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 1 as libc::c_int,
                y + 1 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me4x4[i as usize][3 as libc::c_int as usize].mv).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i,
            );
        }
        _ => {
            x264_8_log(
                h,
                0 as libc::c_int,
                b"internal error\n\0" as *const u8 as *const libc::c_char,
            );
        }
    };
}
unsafe extern "C" fn mb_load_mv_direct8x8(mut h: *mut x264_t, mut idx: libc::c_int) {
    let mut x: libc::c_int = 2 as libc::c_int * (idx & 1 as libc::c_int);
    let mut y: libc::c_int = idx & 2 as libc::c_int;
    x264_macroblock_cache_ref(
        h,
        x,
        y,
        2 as libc::c_int,
        2 as libc::c_int,
        0 as libc::c_int,
        (*h).mb.cache.direct_ref[0 as libc::c_int as usize][idx as usize],
    );
    x264_macroblock_cache_ref(
        h,
        x,
        y,
        2 as libc::c_int,
        2 as libc::c_int,
        1 as libc::c_int,
        (*h).mb.cache.direct_ref[1 as libc::c_int as usize][idx as usize],
    );
    x264_macroblock_cache_mv(
        h,
        x,
        y,
        2 as libc::c_int,
        2 as libc::c_int,
        0 as libc::c_int,
        (*(((*h).mb.cache.direct_mv[0 as libc::c_int as usize][idx as usize])
            .as_mut_ptr() as *mut x264_union32_t))
            .i,
    );
    x264_macroblock_cache_mv(
        h,
        x,
        y,
        2 as libc::c_int,
        2 as libc::c_int,
        1 as libc::c_int,
        (*(((*h).mb.cache.direct_mv[1 as libc::c_int as usize][idx as usize])
            .as_mut_ptr() as *mut x264_union32_t))
            .i,
    );
}
#[inline]
unsafe extern "C" fn mb_cache_mv_b8x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: libc::c_int,
    mut b_mvd: libc::c_int,
) {
    let mut x: libc::c_int = 2 as libc::c_int * (i & 1 as libc::c_int);
    let mut y: libc::c_int = i & 2 as libc::c_int;
    if (*h).mb.i_sub_partition[i as usize] as libc::c_int == D_DIRECT_8x8 as libc::c_int
    {
        mb_load_mv_direct8x8(h, i);
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int as uint16_t,
            );
            x264_macroblock_cache_mvd(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int as uint16_t,
            );
            x264_macroblock_cache_skip(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
            );
        }
    } else {
        if x264_mb_partition_listX_table[0 as libc::c_int
            as usize][(*h).mb.i_sub_partition[i as usize] as usize] != 0
        {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[i as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*(((*a).l0.me8x8[i as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i,
            );
        } else {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                -(1 as libc::c_int) as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int as uint32_t,
            );
            if b_mvd != 0 {
                x264_macroblock_cache_mvd(
                    h,
                    x,
                    y,
                    2 as libc::c_int,
                    2 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int as uint16_t,
                );
            }
        }
        if x264_mb_partition_listX_table[1 as libc::c_int
            as usize][(*h).mb.i_sub_partition[i as usize] as usize] != 0
        {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                (*a).l1.me8x8[i as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                (*(((*a).l1.me8x8[i as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i,
            );
        } else {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                -(1 as libc::c_int) as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int as uint32_t,
            );
            if b_mvd != 0 {
                x264_macroblock_cache_mvd(
                    h,
                    x,
                    y,
                    2 as libc::c_int,
                    2 as libc::c_int,
                    1 as libc::c_int,
                    0 as libc::c_int as uint16_t,
                );
            }
        }
    };
}
#[inline]
unsafe extern "C" fn mb_cache_mv_b16x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: libc::c_int,
    mut b_mvd: libc::c_int,
) {
    if x264_mb_partition_listX_table[0 as libc::c_int
        as usize][(*a).i_mb_partition16x8[i as usize] as usize] != 0
    {
        x264_macroblock_cache_ref(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*a).l0.me16x8[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            (*(((*a).l0.me16x8[i as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            -(1 as libc::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                0 as libc::c_int,
                2 as libc::c_int * i,
                4 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int as uint16_t,
            );
        }
    }
    if x264_mb_partition_listX_table[1 as libc::c_int
        as usize][(*a).i_mb_partition16x8[i as usize] as usize] != 0
    {
        x264_macroblock_cache_ref(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            1 as libc::c_int,
            (*a).l1.me16x8[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            1 as libc::c_int,
            (*(((*a).l1.me16x8[i as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            1 as libc::c_int,
            -(1 as libc::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as libc::c_int,
            2 as libc::c_int * i,
            4 as libc::c_int,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                0 as libc::c_int,
                2 as libc::c_int * i,
                4 as libc::c_int,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int as uint16_t,
            );
        }
    };
}
#[inline]
unsafe extern "C" fn mb_cache_mv_b8x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: libc::c_int,
    mut b_mvd: libc::c_int,
) {
    if x264_mb_partition_listX_table[0 as libc::c_int
        as usize][(*a).i_mb_partition8x16[i as usize] as usize] != 0
    {
        x264_macroblock_cache_ref(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            (*a).l0.me8x16[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            (*(((*a).l0.me8x16[i as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            -(1 as libc::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                2 as libc::c_int * i,
                0 as libc::c_int,
                2 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int as uint16_t,
            );
        }
    }
    if x264_mb_partition_listX_table[1 as libc::c_int
        as usize][(*a).i_mb_partition8x16[i as usize] as usize] != 0
    {
        x264_macroblock_cache_ref(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            1 as libc::c_int,
            (*a).l1.me8x16[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            1 as libc::c_int,
            (*(((*a).l1.me8x16[i as usize].mv).as_mut_ptr() as *mut x264_union32_t)).i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            1 as libc::c_int,
            -(1 as libc::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as libc::c_int * i,
            0 as libc::c_int,
            2 as libc::c_int,
            4 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                2 as libc::c_int * i,
                0 as libc::c_int,
                2 as libc::c_int,
                4 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int as uint16_t,
            );
        }
    };
}
unsafe extern "C" fn mb_analyse_inter_b8x8_mixed_ref(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut pix: [[pixel; 64]; 2] = [[0; 64]; 2];
    let mut i_maxref: [libc::c_int; 2] = [
        (*h).mb.pic.i_fref[0 as libc::c_int as usize] - 1 as libc::c_int,
        (*h).mb.pic.i_fref[1 as libc::c_int as usize] - 1 as libc::c_int,
    ];
    let mut l: libc::c_int = 0 as libc::c_int;
    while l < 2 as libc::c_int {
        let mut lX: *mut x264_mb_analysis_list_t = if l != 0 {
            &mut (*a).l1
        } else {
            &mut (*a).l0
        };
        if i_maxref[l as usize] > 0 as libc::c_int
            && (*lX).me16x16.i_ref == 0 as libc::c_int
            && (*h).mb.i_mb_type_top > 0 as libc::c_int
            && (*h).mb.i_mb_type_left[0 as libc::c_int as usize] > 0 as libc::c_int
        {
            i_maxref[l as usize] = 0 as libc::c_int;
            let mut ref_0: libc::c_int = (*h)
                .mb
                .cache
                .ref_0[l
                as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
                + -(8 as libc::c_int) - 1 as libc::c_int) as usize] as libc::c_int;
            if ref_0 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_0;
            }
            let mut ref_1: libc::c_int = (*h)
                .mb
                .cache
                .ref_0[l
                as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
                + -(8 as libc::c_int) + 0 as libc::c_int) as usize] as libc::c_int;
            if ref_1 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_1;
            }
            let mut ref_2: libc::c_int = (*h)
                .mb
                .cache
                .ref_0[l
                as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
                + -(8 as libc::c_int) + 2 as libc::c_int) as usize] as libc::c_int;
            if ref_2 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_2;
            }
            let mut ref_3: libc::c_int = (*h)
                .mb
                .cache
                .ref_0[l
                as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
                + -(8 as libc::c_int) + 4 as libc::c_int) as usize] as libc::c_int;
            if ref_3 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_3;
            }
            let mut ref_4: libc::c_int = (*h)
                .mb
                .cache
                .ref_0[l
                as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
                + 0 as libc::c_int - 1 as libc::c_int) as usize] as libc::c_int;
            if ref_4 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_4;
            }
            let mut ref_5: libc::c_int = (*h)
                .mb
                .cache
                .ref_0[l
                as usize][(4 as libc::c_int + 1 as libc::c_int * 8 as libc::c_int
                + 2 as libc::c_int * 8 as libc::c_int - 1 as libc::c_int) as usize]
                as libc::c_int;
            if ref_5 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_5;
            }
        }
        l += 1;
        l;
    }
    (*h).mb.i_partition = D_8x8 as libc::c_int;
    (*a).i_cost8x8bi = 0 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        let mut x8: libc::c_int = i & 1 as libc::c_int;
        let mut y8: libc::c_int = i >> 1 as libc::c_int;
        let mut i_part_cost: libc::c_int = 0;
        let mut i_part_cost_bi: libc::c_int = 0;
        let mut stride: [intptr_t; 2] = [
            8 as libc::c_int as intptr_t,
            8 as libc::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut m: x264_me_t = x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        };
        m.i_pixel = PIXEL_8x8 as libc::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        m
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        m
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        m
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*((*h).mb.pic.p_fenc)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .offset(
                (8 as libc::c_int * x8 + 8 as libc::c_int * y8 * 16 as libc::c_int)
                    as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            m
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*((*h).mb.pic.p_fenc)
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            m
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*((*h).mb.pic.p_fenc)
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        let mut l_0: libc::c_int = 0 as libc::c_int;
        while l_0 < 2 as libc::c_int {
            let mut lX_0: *mut x264_mb_analysis_list_t = if l_0 != 0 {
                &mut (*a).l1
            } else {
                &mut (*a).l0
            };
            (*lX_0).me8x8[i as usize].cost = 2147483647 as libc::c_int;
            let mut i_ref: libc::c_int = 0 as libc::c_int;
            while i_ref <= i_maxref[l_0 as usize] {
                m
                    .i_ref_cost = *((*a).p_cost_ref[l_0 as usize]).offset(i_ref as isize)
                    as libc::c_int;
                m
                    .p_fref[0 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(l_0 as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m
                        .p_fref[1 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[2 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[3 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_444 as libc::c_int
                {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[8 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m
                            .p_fref[5 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * x8
                                    + 8 as libc::c_int * y8
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[6 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * x8
                                    + 8 as libc::c_int * y8
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[7 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * x8
                                    + 8 as libc::c_int * y8
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[9 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * x8
                                    + 8 as libc::c_int * y8
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[10 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * x8
                                    + 8 as libc::c_int * y8
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[11 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * x8
                                    + 8 as libc::c_int * y8
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                    }
                } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                    m
                        .integral = &mut *(*(*((*h).mb.pic.p_integral)
                        .as_mut_ptr()
                        .offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                x264_macroblock_cache_ref(
                    h,
                    x8 * 2 as libc::c_int,
                    y8 * 2 as libc::c_int,
                    2 as libc::c_int,
                    2 as libc::c_int,
                    l_0,
                    i_ref as int8_t,
                );
                x264_8_mb_predict_mv(
                    h,
                    l_0,
                    4 as libc::c_int * i,
                    2 as libc::c_int,
                    (m.mvp).as_mut_ptr(),
                );
                x264_8_me_search_ref(
                    h,
                    &mut m,
                    ((*lX_0).mvc[i_ref as usize]).as_mut_ptr(),
                    i + 1 as libc::c_int,
                    0 as *mut libc::c_int,
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX_0).me8x8[i as usize].cost {
                    ((*h).mc.memcpy_aligned)
                        .expect(
                            "non-null function pointer",
                        )(
                        &mut *((*lX_0).me8x8).as_mut_ptr().offset(i as isize)
                            as *mut x264_me_t as *mut libc::c_void,
                        &mut m as *mut x264_me_t as *const libc::c_void,
                        ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
                    );
                    (*a)
                        .i_satd8x8[l_0
                        as usize][i as usize] = m.cost - (m.cost_mv + m.i_ref_cost);
                }
                (*(((*lX_0).mvc[i_ref as usize][(i + 1 as libc::c_int) as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*((m.mv).as_mut_ptr() as *mut x264_union32_t)).i;
                i_ref += 1;
                i_ref;
            }
            l_0 += 1;
            l_0;
        }
        src[0 as libc::c_int
            as usize] = ((*h).mc.get_ref)
            .expect(
                "non-null function pointer",
            )(
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(0 as libc::c_int as isize),
            ((*a).l0.me8x8[i as usize].p_fref).as_mut_ptr(),
            (*a).l0.me8x8[i as usize].i_stride[0 as libc::c_int as usize] as intptr_t,
            (*a).l0.me8x8[i as usize].mv[0 as libc::c_int as usize] as libc::c_int,
            (*a).l0.me8x8[i as usize].mv[1 as libc::c_int as usize] as libc::c_int,
            8 as libc::c_int,
            8 as libc::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        src[1 as libc::c_int
            as usize] = ((*h).mc.get_ref)
            .expect(
                "non-null function pointer",
            )(
            (pix[1 as libc::c_int as usize]).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(1 as libc::c_int as isize),
            ((*a).l1.me8x8[i as usize].p_fref).as_mut_ptr(),
            (*a).l1.me8x8[i as usize].i_stride[0 as libc::c_int as usize] as intptr_t,
            (*a).l1.me8x8[i as usize].mv[0 as libc::c_int as usize] as libc::c_int,
            (*a).l1.me8x8[i as usize].mv[1 as libc::c_int as usize] as libc::c_int,
            8 as libc::c_int,
            8 as libc::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        ((*h).mc.avg[PIXEL_8x8 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            8 as libc::c_int as intptr_t,
            src[0 as libc::c_int as usize],
            stride[0 as libc::c_int as usize],
            src[1 as libc::c_int as usize],
            stride[1 as libc::c_int as usize],
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me8x8[i as usize].i_ref as isize,
                ))[(*a).l1.me8x8[i as usize].i_ref as usize] as libc::c_int,
        );
        (*a)
            .i_satd8x8[2 as libc::c_int
            as usize][i
            as usize] = ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.me8x8[i as usize].p_fenc[0 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            8 as libc::c_int as intptr_t,
        );
        i_part_cost_bi = (*a).i_satd8x8[2 as libc::c_int as usize][i as usize]
            + (*a).l0.me8x8[i as usize].cost_mv + (*a).l1.me8x8[i as usize].cost_mv
            + (*a).l0.me8x8[i as usize].i_ref_cost + (*a).l1.me8x8[i as usize].i_ref_cost
            + (*a).i_lambda
                * i_sub_mb_b_cost_table[D_BI_8x8 as libc::c_int as usize] as libc::c_int;
        if (*h).mb.b_chroma_me != 0 {
            let mut i_chroma_cost: libc::c_int = analyse_bi_chroma(
                h,
                a,
                i,
                PIXEL_8x8 as libc::c_int,
            );
            i_part_cost_bi += i_chroma_cost;
            (*a).i_satd8x8[2 as libc::c_int as usize][i as usize] += i_chroma_cost;
        }
        (*a).l0.me8x8[i as usize].cost
            += (*a).i_lambda
                * i_sub_mb_b_cost_table[D_L0_8x8 as libc::c_int as usize] as libc::c_int;
        (*a).l1.me8x8[i as usize].cost
            += (*a).i_lambda
                * i_sub_mb_b_cost_table[D_L1_8x8 as libc::c_int as usize] as libc::c_int;
        i_part_cost = (*a).l0.me8x8[i as usize].cost;
        (*h).mb.i_sub_partition[i as usize] = D_L0_8x8 as libc::c_int as uint8_t;
        if (*a).l1.me8x8[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me8x8[i as usize].cost;
            (*h).mb.i_sub_partition[i as usize] = D_L1_8x8 as libc::c_int as uint8_t;
        }
        if i_part_cost_bi < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*h).mb.i_sub_partition[i as usize] = D_BI_8x8 as libc::c_int as uint8_t;
        }
        if (*a).i_cost8x8direct[i as usize] < i_part_cost {
            i_part_cost = (*a).i_cost8x8direct[i as usize];
            (*h).mb.i_sub_partition[i as usize] = D_DIRECT_8x8 as libc::c_int as uint8_t;
        }
        (*a).i_cost8x8bi += i_part_cost;
        mb_cache_mv_b8x8(h, a, i, 0 as libc::c_int);
        i += 1;
        i;
    }
    (*a).i_cost8x8bi
        += (*a).i_lambda
            * i_mb_b_cost_table[B_8x8 as libc::c_int as usize] as libc::c_int;
}
unsafe extern "C" fn mb_analyse_inter_b8x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut p_fref: [*mut *mut pixel; 2] = [
        ((*h).mb.pic.p_fref[0 as libc::c_int as usize][(*a).l0.me16x16.i_ref as usize])
            .as_mut_ptr(),
        ((*h).mb.pic.p_fref[1 as libc::c_int as usize][(*a).l1.me16x16.i_ref as usize])
            .as_mut_ptr(),
    ];
    let mut pix: [[pixel; 64]; 2] = [[0; 64]; 2];
    (*h).mb.i_partition = D_8x8 as libc::c_int;
    (*a).i_cost8x8bi = 0 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        let mut x8: libc::c_int = i & 1 as libc::c_int;
        let mut y8: libc::c_int = i >> 1 as libc::c_int;
        let mut i_part_cost: libc::c_int = 0;
        let mut i_part_cost_bi: libc::c_int = 0 as libc::c_int;
        let mut stride: [intptr_t; 2] = [
            8 as libc::c_int as intptr_t,
            8 as libc::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut l: libc::c_int = 0 as libc::c_int;
        while l < 2 as libc::c_int {
            let mut lX: *mut x264_mb_analysis_list_t = if l != 0 {
                &mut (*a).l1
            } else {
                &mut (*a).l0
            };
            let mut m: *mut x264_me_t = &mut *((*lX).me8x8)
                .as_mut_ptr()
                .offset(i as isize) as *mut x264_me_t;
            (*m).i_pixel = PIXEL_8x8 as libc::c_int;
            (*m).p_cost_mv = (*a).p_cost_mv;
            (*m)
                .i_stride[0 as libc::c_int
                as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
            (*m)
                .i_stride[1 as libc::c_int
                as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
            (*m)
                .i_stride[2 as libc::c_int
                as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
            (*m)
                .p_fenc[0 as libc::c_int
                as usize] = &mut *(*((*h).mb.pic.p_fenc)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8 + 8 as libc::c_int * y8 * 16 as libc::c_int)
                        as isize,
                ) as *mut pixel;
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                (*m)
                    .p_fenc[1 as libc::c_int
                    as usize] = &mut *(*((*h).mb.pic.p_fenc)
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .offset(
                        ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                            + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                                * 16 as libc::c_int) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fenc[2 as libc::c_int
                    as usize] = &mut *(*((*h).mb.pic.p_fenc)
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize))
                    .offset(
                        ((8 as libc::c_int * x8 >> (*h).mb.chroma_h_shift)
                            + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                                * 16 as libc::c_int) as isize,
                    ) as *mut pixel;
            }
            (*m)
                .i_ref_cost = *((*a).p_cost_ref[l as usize])
                .offset((*lX).me16x16.i_ref as isize) as libc::c_int;
            (*m).i_ref = (*lX).me16x16.i_ref;
            (*m)
                .p_fref[0 as libc::c_int
                as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                .offset(0 as libc::c_int as isize))
                .offset(
                    (8 as libc::c_int * x8
                        + 8 as libc::c_int * y8
                            * *((*m).i_stride)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize)) as isize,
                ) as *mut pixel;
            (*m).p_fref_w = (*m).p_fref[0 as libc::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m)
                    .p_fref[1 as libc::c_int
                    as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                    .offset(1 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[2 as libc::c_int
                    as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                    .offset(2 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[3 as libc::c_int
                    as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                    .offset(3 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as libc::c_int
            {
                (*m)
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                (*m)
                    .p_fref[8 as libc::c_int
                    as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                    .offset(8 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(2 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    (*m)
                        .p_fref[5 as libc::c_int
                        as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(5 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *((*m).i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    (*m)
                        .p_fref[6 as libc::c_int
                        as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(6 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *((*m).i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    (*m)
                        .p_fref[7 as libc::c_int
                        as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(7 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *((*m).i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    (*m)
                        .p_fref[9 as libc::c_int
                        as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(9 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *((*m).i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    (*m)
                        .p_fref[10 as libc::c_int
                        as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(10 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *((*m).i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    (*m)
                        .p_fref[11 as libc::c_int
                        as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(11 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * x8
                                + 8 as libc::c_int * y8
                                    * *((*m).i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
            } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                (*m)
                    .p_fref[4 as libc::c_int
                    as usize] = &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                    .offset(4 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + (8 as libc::c_int * y8 >> (*h).mb.chroma_v_shift)
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                (*m)
                    .integral = &mut *(*(*((*h).mb.pic.p_integral)
                    .as_mut_ptr()
                    .offset(l as isize))
                    .as_mut_ptr()
                    .offset((*lX).me16x16.i_ref as isize))
                    .offset(
                        (8 as libc::c_int * x8
                            + 8 as libc::c_int * y8
                                * *((*m).i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut uint16_t;
            }
            (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            (*m).i_ref = (*lX).me16x16.i_ref;
            x264_macroblock_cache_ref(
                h,
                x8 * 2 as libc::c_int,
                y8 * 2 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                l,
                (*lX).me16x16.i_ref as int8_t,
            );
            x264_8_mb_predict_mv(
                h,
                l,
                4 as libc::c_int * i,
                2 as libc::c_int,
                ((*m).mvp).as_mut_ptr(),
            );
            x264_8_me_search_ref(
                h,
                m,
                &mut (*lX).me16x16.mv,
                1 as libc::c_int,
                0 as *mut libc::c_int,
            );
            (*a).i_satd8x8[l as usize][i as usize] = (*m).cost - (*m).cost_mv;
            (*m).cost += (*m).i_ref_cost;
            x264_macroblock_cache_mv(
                h,
                2 as libc::c_int * x8,
                2 as libc::c_int * y8,
                2 as libc::c_int,
                2 as libc::c_int,
                l,
                (*(((*m).mv).as_mut_ptr() as *mut x264_union32_t)).i,
            );
            (*(((*lX).mvc[(*lX).me16x16.i_ref as usize][(i + 1 as libc::c_int) as usize])
                .as_mut_ptr() as *mut x264_union32_t))
                .i = (*(((*m).mv).as_mut_ptr() as *mut x264_union32_t)).i;
            src[l
                as usize] = ((*h).mc.get_ref)
                .expect(
                    "non-null function pointer",
                )(
                (pix[l as usize]).as_mut_ptr(),
                &mut *stride.as_mut_ptr().offset(l as isize),
                ((*m).p_fref).as_mut_ptr(),
                (*m).i_stride[0 as libc::c_int as usize] as intptr_t,
                (*m).mv[0 as libc::c_int as usize] as libc::c_int,
                (*m).mv[1 as libc::c_int as usize] as libc::c_int,
                8 as libc::c_int,
                8 as libc::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            i_part_cost_bi += (*m).cost_mv + (*m).i_ref_cost;
            l += 1;
            l;
        }
        ((*h).mc.avg[PIXEL_8x8 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            8 as libc::c_int as intptr_t,
            src[0 as libc::c_int as usize],
            stride[0 as libc::c_int as usize],
            src[1 as libc::c_int as usize],
            stride[1 as libc::c_int as usize],
            (*((*h).mb.bipred_weight)
                .offset((*a).l0.me16x16.i_ref as isize))[(*a).l1.me16x16.i_ref as usize]
                as libc::c_int,
        );
        (*a)
            .i_satd8x8[2 as libc::c_int
            as usize][i
            as usize] = ((*h).pixf.mbcmp[PIXEL_8x8 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.me8x8[i as usize].p_fenc[0 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            8 as libc::c_int as intptr_t,
        );
        i_part_cost_bi
            += (*a).i_satd8x8[2 as libc::c_int as usize][i as usize]
                + (*a).i_lambda
                    * i_sub_mb_b_cost_table[D_BI_8x8 as libc::c_int as usize]
                        as libc::c_int;
        (*a).l0.me8x8[i as usize].cost
            += (*a).i_lambda
                * i_sub_mb_b_cost_table[D_L0_8x8 as libc::c_int as usize] as libc::c_int;
        (*a).l1.me8x8[i as usize].cost
            += (*a).i_lambda
                * i_sub_mb_b_cost_table[D_L1_8x8 as libc::c_int as usize] as libc::c_int;
        if (*h).mb.b_chroma_me != 0 {
            let mut i_chroma_cost: libc::c_int = analyse_bi_chroma(
                h,
                a,
                i,
                PIXEL_8x8 as libc::c_int,
            );
            i_part_cost_bi += i_chroma_cost;
            (*a).i_satd8x8[2 as libc::c_int as usize][i as usize] += i_chroma_cost;
        }
        i_part_cost = (*a).l0.me8x8[i as usize].cost;
        (*h).mb.i_sub_partition[i as usize] = D_L0_8x8 as libc::c_int as uint8_t;
        if (*a).l1.me8x8[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me8x8[i as usize].cost;
            (*h).mb.i_sub_partition[i as usize] = D_L1_8x8 as libc::c_int as uint8_t;
        }
        if i_part_cost_bi < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*h).mb.i_sub_partition[i as usize] = D_BI_8x8 as libc::c_int as uint8_t;
        }
        if (*a).i_cost8x8direct[i as usize] < i_part_cost {
            i_part_cost = (*a).i_cost8x8direct[i as usize];
            (*h).mb.i_sub_partition[i as usize] = D_DIRECT_8x8 as libc::c_int as uint8_t;
        }
        (*a).i_cost8x8bi += i_part_cost;
        mb_cache_mv_b8x8(h, a, i, 0 as libc::c_int);
        i += 1;
        i;
    }
    (*a).i_cost8x8bi
        += (*a).i_lambda
            * i_mb_b_cost_table[B_8x8 as libc::c_int as usize] as libc::c_int;
}
unsafe extern "C" fn mb_analyse_inter_b16x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: libc::c_int,
) {
    let mut pix: [[pixel; 128]; 2] = [[0; 128]; 2];
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_16x8 as libc::c_int;
    (*a).i_cost16x8bi = 0 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        let mut i_part_cost: libc::c_int = 0;
        let mut i_part_cost_bi: libc::c_int = 0 as libc::c_int;
        let mut stride: [intptr_t; 2] = [
            16 as libc::c_int as intptr_t,
            16 as libc::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut m: x264_me_t = x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        };
        m.i_pixel = PIXEL_16x8 as libc::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        m
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        m
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        m
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*((*h).mb.pic.p_fenc)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .offset(
                (0 as libc::c_int + 8 as libc::c_int * i * 16 as libc::c_int) as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            m
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*((*h).mb.pic.p_fenc)
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .offset(
                    ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * i >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            m
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*((*h).mb.pic.p_fenc)
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize))
                .offset(
                    ((0 as libc::c_int >> (*h).mb.chroma_h_shift)
                        + (8 as libc::c_int * i >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        let mut l: libc::c_int = 0 as libc::c_int;
        while l < 2 as libc::c_int {
            let mut lX: *mut x264_mb_analysis_list_t = if l != 0 {
                &mut (*a).l1
            } else {
                &mut (*a).l0
            };
            let mut ref8: [libc::c_int; 2] = [
                (*lX).me8x8[(2 as libc::c_int * i) as usize].i_ref,
                (*lX).me8x8[(2 as libc::c_int * i + 1 as libc::c_int) as usize].i_ref,
            ];
            let mut i_ref8s: libc::c_int = if ref8[0 as libc::c_int as usize]
                == ref8[1 as libc::c_int as usize]
            {
                1 as libc::c_int
            } else {
                2 as libc::c_int
            };
            (*lX).me16x8[i as usize].cost = 2147483647 as libc::c_int;
            let mut j: libc::c_int = 0 as libc::c_int;
            while j < i_ref8s {
                let mut i_ref: libc::c_int = ref8[j as usize];
                m
                    .i_ref_cost = *((*a).p_cost_ref[l as usize]).offset(i_ref as isize)
                    as libc::c_int;
                m
                    .p_fref[0 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(l as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .offset(
                        (0 as libc::c_int
                            + 8 as libc::c_int * i
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m
                        .p_fref[1 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[2 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[3 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_444 as libc::c_int
                {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[8 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m
                            .p_fref[5 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 8 as libc::c_int * i
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[6 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 8 as libc::c_int * i
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[7 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 8 as libc::c_int * i
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[9 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 8 as libc::c_int * i
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[10 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 8 as libc::c_int * i
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[11 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as libc::c_int as isize))
                            .offset(
                                (0 as libc::c_int
                                    + 8 as libc::c_int * i
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                    }
                } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (0 as libc::c_int
                                + (8 as libc::c_int * i >> (*h).mb.chroma_v_shift)
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                    m
                        .integral = &mut *(*(*((*h).mb.pic.p_integral)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .offset(
                            (0 as libc::c_int
                                + 8 as libc::c_int * i
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                (*((mvc[0 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(((*lX).mvc[i_ref as usize][0 as libc::c_int as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((mvc[1 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(((*lX)
                    .mvc[i_ref
                    as usize][(2 as libc::c_int * i + 1 as libc::c_int) as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((mvc[2 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(((*lX)
                    .mvc[i_ref
                    as usize][(2 as libc::c_int * i + 2 as libc::c_int) as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                x264_macroblock_cache_ref(
                    h,
                    0 as libc::c_int,
                    2 as libc::c_int * i,
                    4 as libc::c_int,
                    2 as libc::c_int,
                    l,
                    i_ref as int8_t,
                );
                x264_8_mb_predict_mv(
                    h,
                    l,
                    8 as libc::c_int * i,
                    4 as libc::c_int,
                    (m.mvp).as_mut_ptr(),
                );
                x264_8_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr(),
                    3 as libc::c_int,
                    0 as *mut libc::c_int,
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX).me16x8[i as usize].cost {
                    ((*h).mc.memcpy_aligned)
                        .expect(
                            "non-null function pointer",
                        )(
                        &mut *((*lX).me16x8).as_mut_ptr().offset(i as isize)
                            as *mut x264_me_t as *mut libc::c_void,
                        &mut m as *mut x264_me_t as *const libc::c_void,
                        ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
                    );
                }
                j += 1;
                j;
            }
            l += 1;
            l;
        }
        src[0 as libc::c_int
            as usize] = ((*h).mc.get_ref)
            .expect(
                "non-null function pointer",
            )(
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(0 as libc::c_int as isize),
            ((*a).l0.me16x8[i as usize].p_fref).as_mut_ptr(),
            (*a).l0.me16x8[i as usize].i_stride[0 as libc::c_int as usize] as intptr_t,
            (*a).l0.me16x8[i as usize].mv[0 as libc::c_int as usize] as libc::c_int,
            (*a).l0.me16x8[i as usize].mv[1 as libc::c_int as usize] as libc::c_int,
            16 as libc::c_int,
            8 as libc::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        src[1 as libc::c_int
            as usize] = ((*h).mc.get_ref)
            .expect(
                "non-null function pointer",
            )(
            (pix[1 as libc::c_int as usize]).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(1 as libc::c_int as isize),
            ((*a).l1.me16x8[i as usize].p_fref).as_mut_ptr(),
            (*a).l1.me16x8[i as usize].i_stride[0 as libc::c_int as usize] as intptr_t,
            (*a).l1.me16x8[i as usize].mv[0 as libc::c_int as usize] as libc::c_int,
            (*a).l1.me16x8[i as usize].mv[1 as libc::c_int as usize] as libc::c_int,
            16 as libc::c_int,
            8 as libc::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        ((*h).mc.avg[PIXEL_16x8 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
            src[0 as libc::c_int as usize],
            stride[0 as libc::c_int as usize],
            src[1 as libc::c_int as usize],
            stride[1 as libc::c_int as usize],
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me16x8[i as usize].i_ref as isize,
                ))[(*a).l1.me16x8[i as usize].i_ref as usize] as libc::c_int,
        );
        i_part_cost_bi = ((*h).pixf.mbcmp[PIXEL_16x8 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.me16x8[i as usize].p_fenc[0 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            16 as libc::c_int as intptr_t,
        ) + (*a).l0.me16x8[i as usize].cost_mv + (*a).l1.me16x8[i as usize].cost_mv
            + (*a).l0.me16x8[i as usize].i_ref_cost
            + (*a).l1.me16x8[i as usize].i_ref_cost;
        if (*h).mb.b_chroma_me != 0 {
            i_part_cost_bi += analyse_bi_chroma(h, a, i, PIXEL_16x8 as libc::c_int);
        }
        i_part_cost = (*a).l0.me16x8[i as usize].cost;
        (*a).i_mb_partition16x8[i as usize] = D_L0_8x8 as libc::c_int;
        if (*a).l1.me16x8[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me16x8[i as usize].cost;
            (*a).i_mb_partition16x8[i as usize] = D_L1_8x8 as libc::c_int;
        }
        if (i_part_cost_bi + (*a).i_lambda * 1 as libc::c_int) < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*a).i_mb_partition16x8[i as usize] = D_BI_8x8 as libc::c_int;
        }
        (*a).i_cost16x8bi += i_part_cost;
        if (*a).b_early_terminate != 0
            && (i == 0
                && i_part_cost + (*a).i_cost_est16x8[1 as libc::c_int as usize]
                    > i_best_satd
                        * (16 as libc::c_int
                            + (((*a).i_mbrd != 0) as libc::c_int
                                + ((*h).mb.i_psy_rd != 0) as libc::c_int))
                        / 16 as libc::c_int)
        {
            (*a).i_cost16x8bi = (1 as libc::c_int) << 28 as libc::c_int;
            return;
        }
        mb_cache_mv_b16x8(h, a, i, 0 as libc::c_int);
        i += 1;
        i;
    }
    (*a)
        .i_mb_type16x8 = B_L0_L0 as libc::c_int
        + ((*a).i_mb_partition16x8[0 as libc::c_int as usize] >> 2 as libc::c_int)
            * 3 as libc::c_int
        + ((*a).i_mb_partition16x8[1 as libc::c_int as usize] >> 2 as libc::c_int);
    (*a).i_cost16x8bi
        += (*a).i_lambda
            * i_mb_b16x8_cost_table[(*a).i_mb_type16x8 as usize] as libc::c_int;
}
unsafe extern "C" fn mb_analyse_inter_b8x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: libc::c_int,
) {
    let mut pix: [[pixel; 128]; 2] = [[0; 128]; 2];
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_8x16 as libc::c_int;
    (*a).i_cost8x16bi = 0 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        let mut i_part_cost: libc::c_int = 0;
        let mut i_part_cost_bi: libc::c_int = 0 as libc::c_int;
        let mut stride: [intptr_t; 2] = [
            8 as libc::c_int as intptr_t,
            8 as libc::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut m: x264_me_t = x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        };
        m.i_pixel = PIXEL_8x16 as libc::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m
            .i_stride[0 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[0 as libc::c_int as usize];
        m
            .i_stride[1 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[1 as libc::c_int as usize];
        m
            .i_stride[2 as libc::c_int
            as usize] = (*h).mb.pic.i_stride[2 as libc::c_int as usize];
        m
            .p_fenc[0 as libc::c_int
            as usize] = &mut *(*((*h).mb.pic.p_fenc)
            .as_mut_ptr()
            .offset(0 as libc::c_int as isize))
            .offset(
                (8 as libc::c_int * i + 0 as libc::c_int * 16 as libc::c_int) as isize,
            ) as *mut pixel;
        if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
            m
                .p_fenc[1 as libc::c_int
                as usize] = &mut *(*((*h).mb.pic.p_fenc)
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * i >> (*h).mb.chroma_h_shift)
                        + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
            m
                .p_fenc[2 as libc::c_int
                as usize] = &mut *(*((*h).mb.pic.p_fenc)
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize))
                .offset(
                    ((8 as libc::c_int * i >> (*h).mb.chroma_h_shift)
                        + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                            * 16 as libc::c_int) as isize,
                ) as *mut pixel;
        }
        let mut l: libc::c_int = 0 as libc::c_int;
        while l < 2 as libc::c_int {
            let mut lX: *mut x264_mb_analysis_list_t = if l != 0 {
                &mut (*a).l1
            } else {
                &mut (*a).l0
            };
            let mut ref8: [libc::c_int; 2] = [
                (*lX).me8x8[i as usize].i_ref,
                (*lX).me8x8[(i + 2 as libc::c_int) as usize].i_ref,
            ];
            let mut i_ref8s: libc::c_int = if ref8[0 as libc::c_int as usize]
                == ref8[1 as libc::c_int as usize]
            {
                1 as libc::c_int
            } else {
                2 as libc::c_int
            };
            (*lX).me8x16[i as usize].cost = 2147483647 as libc::c_int;
            let mut j: libc::c_int = 0 as libc::c_int;
            while j < i_ref8s {
                let mut i_ref: libc::c_int = ref8[j as usize];
                m
                    .i_ref_cost = *((*a).p_cost_ref[l as usize]).offset(i_ref as isize)
                    as libc::c_int;
                m
                    .p_fref[0 as libc::c_int
                    as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                    .as_mut_ptr()
                    .offset(l as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .offset(
                        (8 as libc::c_int * i
                            + 0 as libc::c_int
                                * *(m.i_stride)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize)) as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as libc::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m
                        .p_fref[1 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[2 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[3 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_444 as libc::c_int
                {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    m
                        .p_fref[8 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(2 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m
                            .p_fref[5 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * i
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[6 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * i
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[7 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * i
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[9 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * i
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[10 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * i
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                        m
                            .p_fref[11 as libc::c_int
                            as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                            .as_mut_ptr()
                            .offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as libc::c_int as isize))
                            .offset(
                                (8 as libc::c_int * i
                                    + 0 as libc::c_int
                                        * *(m.i_stride)
                                            .as_mut_ptr()
                                            .offset(2 as libc::c_int as isize)) as isize,
                            ) as *mut pixel;
                    }
                } else if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc != 0 {
                    m
                        .p_fref[4 as libc::c_int
                        as usize] = &mut *(*(*(*((*h).mb.pic.p_fref)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as libc::c_int as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + (0 as libc::c_int >> (*h).mb.chroma_v_shift)
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(1 as libc::c_int as isize)) as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= 3 as libc::c_int {
                    m
                        .integral = &mut *(*(*((*h).mb.pic.p_integral)
                        .as_mut_ptr()
                        .offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                        .offset(
                            (8 as libc::c_int * i
                                + 0 as libc::c_int
                                    * *(m.i_stride)
                                        .as_mut_ptr()
                                        .offset(0 as libc::c_int as isize)) as isize,
                        ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                (*((mvc[0 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(((*lX).mvc[i_ref as usize][0 as libc::c_int as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((mvc[1 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(((*lX).mvc[i_ref as usize][(i + 1 as libc::c_int) as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((mvc[2 as libc::c_int as usize]).as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(((*lX).mvc[i_ref as usize][(i + 3 as libc::c_int) as usize])
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                x264_macroblock_cache_ref(
                    h,
                    2 as libc::c_int * i,
                    0 as libc::c_int,
                    2 as libc::c_int,
                    4 as libc::c_int,
                    l,
                    i_ref as int8_t,
                );
                x264_8_mb_predict_mv(
                    h,
                    l,
                    4 as libc::c_int * i,
                    2 as libc::c_int,
                    (m.mvp).as_mut_ptr(),
                );
                x264_8_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr(),
                    3 as libc::c_int,
                    0 as *mut libc::c_int,
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX).me8x16[i as usize].cost {
                    ((*h).mc.memcpy_aligned)
                        .expect(
                            "non-null function pointer",
                        )(
                        &mut *((*lX).me8x16).as_mut_ptr().offset(i as isize)
                            as *mut x264_me_t as *mut libc::c_void,
                        &mut m as *mut x264_me_t as *const libc::c_void,
                        ::core::mem::size_of::<x264_me_t>() as libc::c_ulong,
                    );
                }
                j += 1;
                j;
            }
            l += 1;
            l;
        }
        src[0 as libc::c_int
            as usize] = ((*h).mc.get_ref)
            .expect(
                "non-null function pointer",
            )(
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(0 as libc::c_int as isize),
            ((*a).l0.me8x16[i as usize].p_fref).as_mut_ptr(),
            (*a).l0.me8x16[i as usize].i_stride[0 as libc::c_int as usize] as intptr_t,
            (*a).l0.me8x16[i as usize].mv[0 as libc::c_int as usize] as libc::c_int,
            (*a).l0.me8x16[i as usize].mv[1 as libc::c_int as usize] as libc::c_int,
            8 as libc::c_int,
            16 as libc::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        src[1 as libc::c_int
            as usize] = ((*h).mc.get_ref)
            .expect(
                "non-null function pointer",
            )(
            (pix[1 as libc::c_int as usize]).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(1 as libc::c_int as isize),
            ((*a).l1.me8x16[i as usize].p_fref).as_mut_ptr(),
            (*a).l1.me8x16[i as usize].i_stride[0 as libc::c_int as usize] as intptr_t,
            (*a).l1.me8x16[i as usize].mv[0 as libc::c_int as usize] as libc::c_int,
            (*a).l1.me8x16[i as usize].mv[1 as libc::c_int as usize] as libc::c_int,
            8 as libc::c_int,
            16 as libc::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        ((*h).mc.avg[PIXEL_8x16 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            8 as libc::c_int as intptr_t,
            src[0 as libc::c_int as usize],
            stride[0 as libc::c_int as usize],
            src[1 as libc::c_int as usize],
            stride[1 as libc::c_int as usize],
            (*((*h).mb.bipred_weight)
                .offset(
                    (*a).l0.me8x16[i as usize].i_ref as isize,
                ))[(*a).l1.me8x16[i as usize].i_ref as usize] as libc::c_int,
        );
        i_part_cost_bi = ((*h).pixf.mbcmp[PIXEL_8x16 as libc::c_int as usize])
            .expect(
                "non-null function pointer",
            )(
            (*a).l0.me8x16[i as usize].p_fenc[0 as libc::c_int as usize],
            16 as libc::c_int as intptr_t,
            (pix[0 as libc::c_int as usize]).as_mut_ptr(),
            8 as libc::c_int as intptr_t,
        ) + (*a).l0.me8x16[i as usize].cost_mv + (*a).l1.me8x16[i as usize].cost_mv
            + (*a).l0.me8x16[i as usize].i_ref_cost
            + (*a).l1.me8x16[i as usize].i_ref_cost;
        if (*h).mb.b_chroma_me != 0 {
            i_part_cost_bi += analyse_bi_chroma(h, a, i, PIXEL_8x16 as libc::c_int);
        }
        i_part_cost = (*a).l0.me8x16[i as usize].cost;
        (*a).i_mb_partition8x16[i as usize] = D_L0_8x8 as libc::c_int;
        if (*a).l1.me8x16[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me8x16[i as usize].cost;
            (*a).i_mb_partition8x16[i as usize] = D_L1_8x8 as libc::c_int;
        }
        if (i_part_cost_bi + (*a).i_lambda * 1 as libc::c_int) < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*a).i_mb_partition8x16[i as usize] = D_BI_8x8 as libc::c_int;
        }
        (*a).i_cost8x16bi += i_part_cost;
        if (*a).b_early_terminate != 0
            && (i == 0
                && i_part_cost + (*a).i_cost_est8x16[1 as libc::c_int as usize]
                    > i_best_satd
                        * (16 as libc::c_int
                            + (((*a).i_mbrd != 0) as libc::c_int
                                + ((*h).mb.i_psy_rd != 0) as libc::c_int))
                        / 16 as libc::c_int)
        {
            (*a).i_cost8x16bi = (1 as libc::c_int) << 28 as libc::c_int;
            return;
        }
        mb_cache_mv_b8x16(h, a, i, 0 as libc::c_int);
        i += 1;
        i;
    }
    (*a)
        .i_mb_type8x16 = B_L0_L0 as libc::c_int
        + ((*a).i_mb_partition8x16[0 as libc::c_int as usize] >> 2 as libc::c_int)
            * 3 as libc::c_int
        + ((*a).i_mb_partition8x16[1 as libc::c_int as usize] >> 2 as libc::c_int);
    (*a).i_cost8x16bi
        += (*a).i_lambda
            * i_mb_b16x8_cost_table[(*a).i_mb_type8x16 as usize] as libc::c_int;
}
unsafe extern "C" fn mb_analyse_p_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd: libc::c_int,
) {
    let mut thresh: libc::c_int = if (*a).b_early_terminate != 0 {
        i_satd * 5 as libc::c_int / 4 as libc::c_int + 1 as libc::c_int
    } else {
        (1 as libc::c_int) << 28 as libc::c_int
    };
    (*h).mb.i_type = P_L0 as libc::c_int;
    if (*a).l0.i_rd16x16 == (1 as libc::c_int) << 28 as libc::c_int
        && ((*a).b_early_terminate == 0
            || (*a).l0.me16x16.cost <= i_satd * 3 as libc::c_int / 2 as libc::c_int)
    {
        (*h).mb.i_partition = D_16x16 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).l0.i_cost16x8 < thresh {
        (*h).mb.i_partition = D_16x8 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_cost16x8 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).l0.i_cost16x8 = (1 as libc::c_int) << 28 as libc::c_int;
    }
    if (*a).l0.i_cost8x16 < thresh {
        (*h).mb.i_partition = D_8x16 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_cost8x16 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).l0.i_cost8x16 = (1 as libc::c_int) << 28 as libc::c_int;
    }
    if (*a).l0.i_cost8x8 < thresh {
        (*h).mb.i_type = P_8x8 as libc::c_int;
        (*h).mb.i_partition = D_8x8 as libc::c_int;
        if (*h).param.analyse.inter & 0x20 as libc::c_uint != 0 {
            x264_macroblock_cache_ref(
                h,
                0 as libc::c_int,
                0 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[0 as libc::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as libc::c_int,
                0 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[1 as libc::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                0 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[2 as libc::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[3 as libc::c_int as usize].i_ref as int8_t,
            );
            let mut i: libc::c_int = 0 as libc::c_int;
            while i < 4 as libc::c_int {
                let mut costs: [libc::c_int; 4] = [
                    (*a).l0.i_cost4x4[i as usize],
                    (*a).l0.i_cost8x4[i as usize],
                    (*a).l0.i_cost4x8[i as usize],
                    (*a).l0.me8x8[i as usize].cost,
                ];
                let mut sub8x8_thresh: libc::c_int = if (*a).b_early_terminate != 0 {
                    (if costs[0 as libc::c_int as usize]
                        < (if costs[1 as libc::c_int as usize]
                            < (if costs[2 as libc::c_int as usize]
                                < costs[3 as libc::c_int as usize]
                            {
                                costs[2 as libc::c_int as usize]
                            } else {
                                costs[3 as libc::c_int as usize]
                            })
                        {
                            costs[1 as libc::c_int as usize]
                        } else {
                            (if costs[2 as libc::c_int as usize]
                                < costs[3 as libc::c_int as usize]
                            {
                                costs[2 as libc::c_int as usize]
                            } else {
                                costs[3 as libc::c_int as usize]
                            })
                        })
                    {
                        costs[0 as libc::c_int as usize]
                    } else {
                        (if costs[1 as libc::c_int as usize]
                            < (if costs[2 as libc::c_int as usize]
                                < costs[3 as libc::c_int as usize]
                            {
                                costs[2 as libc::c_int as usize]
                            } else {
                                costs[3 as libc::c_int as usize]
                            })
                        {
                            costs[1 as libc::c_int as usize]
                        } else {
                            (if costs[2 as libc::c_int as usize]
                                < costs[3 as libc::c_int as usize]
                            {
                                costs[2 as libc::c_int as usize]
                            } else {
                                costs[3 as libc::c_int as usize]
                            })
                        })
                    }) * 5 as libc::c_int / 4 as libc::c_int
                } else {
                    (1 as libc::c_int) << 28 as libc::c_int
                };
                let mut subtype: libc::c_int = 0;
                let mut btype: libc::c_int = D_L0_8x8 as libc::c_int;
                let mut bcost: uint64_t = ((1 as libc::c_ulonglong) << 60 as libc::c_int)
                    as uint64_t;
                subtype = D_L0_4x4 as libc::c_int;
                while subtype <= D_L0_8x8 as libc::c_int {
                    let mut cost: uint64_t = 0;
                    if !(costs[subtype as usize] > sub8x8_thresh) {
                        (*h).mb.i_sub_partition[i as usize] = subtype as uint8_t;
                        mb_cache_mv_p8x8(h, a, i);
                        if !(subtype == btype) {
                            cost = x264_8_rd_cost_part(
                                h,
                                (*a).i_lambda2,
                                i << 2 as libc::c_int,
                                PIXEL_8x8 as libc::c_int,
                            );
                            if cost < bcost {
                                bcost = cost;
                                btype = subtype;
                            }
                        }
                    }
                    subtype += 1;
                    subtype;
                }
                if (*h).mb.i_sub_partition[i as usize] as libc::c_int != btype {
                    (*h).mb.i_sub_partition[i as usize] = btype as uint8_t;
                    mb_cache_mv_p8x8(h, a, i);
                }
                i += 1;
                i;
            }
        } else {
            analyse_update_cache(h, a);
        }
        (*a).l0.i_cost8x8 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).l0.i_cost8x8 = (1 as libc::c_int) << 28 as libc::c_int;
    };
}
unsafe extern "C" fn mb_analyse_b_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd_inter: libc::c_int,
) {
    let mut thresh: libc::c_int = if (*a).b_early_terminate != 0 {
        i_satd_inter * (17 as libc::c_int + ((*h).mb.i_psy_rd != 0) as libc::c_int)
            / 16 as libc::c_int + 1 as libc::c_int
    } else {
        (1 as libc::c_int) << 28 as libc::c_int
    };
    if (*a).b_direct_available != 0
        && (*a).i_rd16x16direct == (1 as libc::c_int) << 28 as libc::c_int
    {
        (*h).mb.i_type = B_DIRECT as libc::c_int;
        (*h).mb.b_skip_mc = 1 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd16x16direct = rd_cost_mb(h, (*a).i_lambda2);
        (*h).mb.b_skip_mc = 0 as libc::c_int;
    }
    (*h).mb.i_partition = D_16x16 as libc::c_int;
    if (*a).l0.me16x16.cost < thresh
        && (*a).l0.i_rd16x16 == (1 as libc::c_int) << 28 as libc::c_int
    {
        (*h).mb.i_type = B_L0_L0 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).l1.me16x16.cost < thresh
        && (*a).l1.i_rd16x16 == (1 as libc::c_int) << 28 as libc::c_int
    {
        (*h).mb.i_type = B_L1_L1 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).l1.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).i_cost16x16bi < thresh
        && (*a).i_rd16x16bi == (1 as libc::c_int) << 28 as libc::c_int
    {
        (*h).mb.i_type = B_BI_BI as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd16x16bi = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).i_cost8x8bi < thresh
        && (*a).i_rd8x8bi == (1 as libc::c_int) << 28 as libc::c_int
    {
        (*h).mb.i_type = B_8x8 as libc::c_int;
        (*h).mb.i_partition = D_8x8 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd8x8bi = rd_cost_mb(h, (*a).i_lambda2);
        x264_macroblock_cache_skip(
            h,
            0 as libc::c_int,
            0 as libc::c_int,
            4 as libc::c_int,
            4 as libc::c_int,
            0 as libc::c_int,
        );
    }
    if (*a).i_cost16x8bi < thresh
        && (*a).i_rd16x8bi == (1 as libc::c_int) << 28 as libc::c_int
    {
        (*h).mb.i_type = (*a).i_mb_type16x8;
        (*h).mb.i_partition = D_16x8 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd16x8bi = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).i_cost8x16bi < thresh
        && (*a).i_rd8x16bi == (1 as libc::c_int) << 28 as libc::c_int
    {
        (*h).mb.i_type = (*a).i_mb_type8x16;
        (*h).mb.i_partition = D_8x16 as libc::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd8x16bi = rd_cost_mb(h, (*a).i_lambda2);
    }
}
unsafe extern "C" fn refine_bidir(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut i_biweight: libc::c_int = 0;
    if (*h).mb.i_type == I_4x4 as libc::c_int || (*h).mb.i_type == I_8x8 as libc::c_int
        || (*h).mb.i_type == I_16x16 as libc::c_int
        || (*h).mb.i_type == I_PCM as libc::c_int
    {
        return;
    }
    match (*h).mb.i_partition {
        16 => {
            if (*h).mb.i_type == B_BI_BI as libc::c_int {
                i_biweight = (*((*h).mb.bipred_weight)
                    .offset(
                        (*a).l0.bi16x16.i_ref as isize,
                    ))[(*a).l1.bi16x16.i_ref as usize] as libc::c_int;
                x264_8_me_refine_bidir_satd(
                    h,
                    &mut (*a).l0.bi16x16,
                    &mut (*a).l1.bi16x16,
                    i_biweight,
                );
            }
        }
        14 => {
            let mut i: libc::c_int = 0 as libc::c_int;
            while i < 2 as libc::c_int {
                if (*a).i_mb_partition16x8[i as usize] == D_BI_8x8 as libc::c_int {
                    i_biweight = (*((*h).mb.bipred_weight)
                        .offset(
                            (*a).l0.me16x8[i as usize].i_ref as isize,
                        ))[(*a).l1.me16x8[i as usize].i_ref as usize] as libc::c_int;
                    x264_8_me_refine_bidir_satd(
                        h,
                        &mut *((*a).l0.me16x8).as_mut_ptr().offset(i as isize),
                        &mut *((*a).l1.me16x8).as_mut_ptr().offset(i as isize),
                        i_biweight,
                    );
                }
                i += 1;
                i;
            }
        }
        15 => {
            let mut i_0: libc::c_int = 0 as libc::c_int;
            while i_0 < 2 as libc::c_int {
                if (*a).i_mb_partition8x16[i_0 as usize] == D_BI_8x8 as libc::c_int {
                    i_biweight = (*((*h).mb.bipred_weight)
                        .offset(
                            (*a).l0.me8x16[i_0 as usize].i_ref as isize,
                        ))[(*a).l1.me8x16[i_0 as usize].i_ref as usize] as libc::c_int;
                    x264_8_me_refine_bidir_satd(
                        h,
                        &mut *((*a).l0.me8x16).as_mut_ptr().offset(i_0 as isize),
                        &mut *((*a).l1.me8x16).as_mut_ptr().offset(i_0 as isize),
                        i_biweight,
                    );
                }
                i_0 += 1;
                i_0;
            }
        }
        13 => {
            let mut i_1: libc::c_int = 0 as libc::c_int;
            while i_1 < 4 as libc::c_int {
                if (*h).mb.i_sub_partition[i_1 as usize] as libc::c_int
                    == D_BI_8x8 as libc::c_int
                {
                    i_biweight = (*((*h).mb.bipred_weight)
                        .offset(
                            (*a).l0.me8x8[i_1 as usize].i_ref as isize,
                        ))[(*a).l1.me8x8[i_1 as usize].i_ref as usize] as libc::c_int;
                    x264_8_me_refine_bidir_satd(
                        h,
                        &mut *((*a).l0.me8x8).as_mut_ptr().offset(i_1 as isize),
                        &mut *((*a).l1.me8x8).as_mut_ptr().offset(i_1 as isize),
                        i_biweight,
                    );
                }
                i_1 += 1;
                i_1;
            }
        }
        _ => {}
    };
}
#[inline]
unsafe extern "C" fn mb_analyse_transform(mut h: *mut x264_t) {
    if x264_mb_transform_8x8_allowed(h) != 0 && (*h).param.analyse.b_transform_8x8 != 0
        && (*h).mb.b_lossless == 0
    {
        x264_8_mb_mc(h);
        let mut plane_count: libc::c_int = if (*((*h).sps).as_mut_ptr())
            .i_chroma_format_idc == CHROMA_444 as libc::c_int && (*h).mb.b_chroma_me != 0
        {
            3 as libc::c_int
        } else {
            1 as libc::c_int
        };
        let mut i_cost8: libc::c_int = 0 as libc::c_int;
        let mut i_cost4: libc::c_int = 0 as libc::c_int;
        if ((*h).pixf.sa8d_satd[PIXEL_16x16 as libc::c_int as usize]).is_some() {
            let mut cost: uint64_t = 0 as libc::c_int as uint64_t;
            let mut p: libc::c_int = 0 as libc::c_int;
            while p < plane_count {
                cost = cost
                    .wrapping_add(
                        ((*h).pixf.sa8d_satd[PIXEL_16x16 as libc::c_int as usize])
                            .expect(
                                "non-null function pointer",
                            )(
                            (*h).mb.pic.p_fenc[p as usize],
                            16 as libc::c_int as intptr_t,
                            (*h).mb.pic.p_fdec[p as usize],
                            32 as libc::c_int as intptr_t,
                        ),
                    );
                p += 1;
                p;
            }
            i_cost8 = cost as uint32_t as libc::c_int;
            i_cost4 = (cost >> 32 as libc::c_int) as uint32_t as libc::c_int;
        } else {
            let mut p_0: libc::c_int = 0 as libc::c_int;
            while p_0 < plane_count {
                i_cost8
                    += ((*h).pixf.sa8d[PIXEL_16x16 as libc::c_int as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        (*h).mb.pic.p_fenc[p_0 as usize],
                        16 as libc::c_int as intptr_t,
                        (*h).mb.pic.p_fdec[p_0 as usize],
                        32 as libc::c_int as intptr_t,
                    );
                i_cost4
                    += ((*h).pixf.satd[PIXEL_16x16 as libc::c_int as usize])
                        .expect(
                            "non-null function pointer",
                        )(
                        (*h).mb.pic.p_fenc[p_0 as usize],
                        16 as libc::c_int as intptr_t,
                        (*h).mb.pic.p_fdec[p_0 as usize],
                        32 as libc::c_int as intptr_t,
                    );
                p_0 += 1;
                p_0;
            }
        }
        (*h).mb.b_transform_8x8 = (i_cost8 < i_cost4) as libc::c_int;
        (*h).mb.b_skip_mc = 1 as libc::c_int;
    }
}
#[inline]
unsafe extern "C" fn mb_analyse_transform_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd: *mut libc::c_int,
    mut i_rd: *mut libc::c_int,
) {
    if (*h).param.analyse.b_transform_8x8 != 0
        && (*((*h).pps).as_mut_ptr()).b_transform_8x8_mode != 0
    {
        let mut subpart_bak: uint32_t = (*(((*h).mb.i_sub_partition).as_mut_ptr()
            as *mut x264_union32_t))
            .i;
        if (*h).mb.i_type == P_8x8 as libc::c_int {
            (*(((*h).mb.i_sub_partition).as_mut_ptr() as *mut x264_union32_t))
                .i = (D_L0_8x8 as libc::c_int * 0x1010101 as libc::c_int) as uint32_t;
        } else if x264_transform_allowed[(*h).mb.i_type as usize] == 0 {
            return
        }
        analyse_update_cache(h, a);
        (*h).mb.b_transform_8x8 ^= 1 as libc::c_int;
        let mut i_rd8: libc::c_int = rd_cost_mb(h, (*a).i_lambda2);
        if *i_rd >= i_rd8 {
            if *i_rd > 0 as libc::c_int {
                *i_satd = (*i_satd as int64_t * i_rd8 as int64_t / *i_rd as int64_t)
                    as libc::c_int;
            }
            *i_rd = i_rd8;
        } else {
            (*h).mb.b_transform_8x8 ^= 1 as libc::c_int;
            (*(((*h).mb.i_sub_partition).as_mut_ptr() as *mut x264_union32_t))
                .i = subpart_bak;
        }
    }
}
#[inline]
unsafe extern "C" fn mb_analyse_qp_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut bcost: libc::c_int = 0;
    let mut cost: libc::c_int = 0;
    let mut failures: libc::c_int = 0;
    let mut prevcost: libc::c_int = 0;
    let mut origcost: libc::c_int = 0;
    let mut orig_qp: libc::c_int = (*h).mb.i_qp;
    let mut bqp: libc::c_int = (*h).mb.i_qp;
    let mut last_qp_tried: libc::c_int = 0 as libc::c_int;
    bcost = rd_cost_mb(h, (*a).i_lambda2);
    origcost = bcost;
    let mut origcbp: libc::c_int = *((*h).mb.cbp).offset((*h).mb.i_mb_xy as isize)
        as libc::c_int;
    let mut direction: libc::c_int = if origcbp != 0 {
        1 as libc::c_int
    } else {
        -(1 as libc::c_int)
    };
    while direction >= -(1 as libc::c_int) {
        let mut threshold: libc::c_int = ((*h).mb.i_psy_rd != 0) as libc::c_int;
        if (*h).mb.i_last_qp < orig_qp && direction == -(1 as libc::c_int)
            || (*h).mb.i_last_qp > orig_qp && direction == 1 as libc::c_int
        {
            threshold += 1;
            threshold;
        }
        (*h).mb.i_qp = orig_qp;
        failures = 0 as libc::c_int;
        prevcost = origcost;
        let mut already_checked_qp: libc::c_int = -(1 as libc::c_int);
        let mut already_checked_cost: libc::c_int = (1 as libc::c_int)
            << 28 as libc::c_int;
        if direction == -(1 as libc::c_int) {
            if origcbp == 0 {
                (*h)
                    .mb
                    .i_qp = if (*h).mb.i_qp - threshold - 1 as libc::c_int
                    > (if (*h).param.rc.i_qp_min
                        < 51 as libc::c_int
                            + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                    {
                        (*h).param.rc.i_qp_min
                    } else {
                        51 as libc::c_int
                            + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                    })
                {
                    (*h).mb.i_qp - threshold - 1 as libc::c_int
                } else if (*h).param.rc.i_qp_min
                    < 51 as libc::c_int
                        + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                {
                    (*h).param.rc.i_qp_min
                } else {
                    51 as libc::c_int
                        + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                };
                (*h)
                    .mb
                    .i_chroma_qp = *((*h).chroma_qp_table).offset((*h).mb.i_qp as isize)
                    as libc::c_int;
                already_checked_cost = rd_cost_mb(h, (*a).i_lambda2);
                if *((*h).mb.cbp).offset((*h).mb.i_mb_xy as isize) == 0 {
                    if (*h).mb.i_last_qp > (*h).mb.i_qp {
                        last_qp_tried = 1 as libc::c_int;
                    }
                    break;
                } else {
                    already_checked_qp = (*h).mb.i_qp;
                    (*h).mb.i_qp = orig_qp;
                }
            }
        }
        (*h).mb.i_qp += direction;
        while (*h).mb.i_qp >= (*h).param.rc.i_qp_min
            && (*h).mb.i_qp
                <= (if (*h).param.rc.i_qp_max
                    < 51 as libc::c_int
                        + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                {
                    (*h).param.rc.i_qp_max
                } else {
                    51 as libc::c_int
                        + 6 as libc::c_int * (8 as libc::c_int - 8 as libc::c_int)
                })
        {
            if (*h).mb.i_last_qp == (*h).mb.i_qp {
                last_qp_tried = 1 as libc::c_int;
            }
            if (*h).mb.i_qp == already_checked_qp {
                cost = already_checked_cost;
            } else {
                (*h)
                    .mb
                    .i_chroma_qp = *((*h).chroma_qp_table).offset((*h).mb.i_qp as isize)
                    as libc::c_int;
                cost = rd_cost_mb(h, (*a).i_lambda2);
                if cost < bcost {
                    bcost = cost;
                    bqp = (*h).mb.i_qp;
                }
            }
            if cost < prevcost {
                failures = 0 as libc::c_int;
            } else {
                failures += 1;
                failures;
            }
            prevcost = cost;
            if failures > threshold {
                break;
            }
            if direction == 1 as libc::c_int
                && *((*h).mb.cbp).offset((*h).mb.i_mb_xy as isize) == 0
            {
                break;
            }
            (*h).mb.i_qp += direction;
        }
        direction -= 2 as libc::c_int;
    }
    if last_qp_tried == 0 {
        (*h).mb.i_qp = (*h).mb.i_last_qp;
        (*h)
            .mb
            .i_chroma_qp = *((*h).chroma_qp_table).offset((*h).mb.i_qp as isize)
            as libc::c_int;
        cost = rd_cost_mb(h, (*a).i_lambda2);
        if cost < bcost {
            bcost = cost;
            bqp = (*h).mb.i_qp;
        }
    }
    (*h).mb.i_qp = bqp;
    (*h)
        .mb
        .i_chroma_qp = *((*h).chroma_qp_table).offset((*h).mb.i_qp as isize)
        as libc::c_int;
    if (*h).mb.i_qp != orig_qp && (*h).param.analyse.b_transform_8x8 != 0
        && x264_mb_transform_8x8_allowed(h) != 0
    {
        (*h).mb.b_transform_8x8 ^= 1 as libc::c_int;
        cost = rd_cost_mb(h, (*a).i_lambda2);
        if cost > bcost {
            (*h).mb.b_transform_8x8 ^= 1 as libc::c_int;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn x264_8_macroblock_analyse(mut h: *mut x264_t) {
    let mut current_block: u64;
    let mut analysis: x264_mb_analysis_t = x264_mb_analysis_t {
        i_lambda: 0,
        i_lambda2: 0,
        i_qp: 0,
        p_cost_mv: 0 as *mut uint16_t,
        p_cost_ref: [0 as *mut uint16_t; 2],
        i_mbrd: 0,
        b_fast_intra: 0,
        b_force_intra: 0,
        b_avoid_topright: 0,
        b_try_skip: 0,
        i_satd_i16x16: 0,
        i_satd_i16x16_dir: [0; 7],
        i_predict16x16: 0,
        i_satd_i8x8: 0,
        i_cbp_i8x8_luma: 0,
        i_satd_i8x8_dir: [[0; 16]; 4],
        i_predict8x8: [0; 4],
        i_satd_i4x4: 0,
        i_predict4x4: [0; 16],
        i_satd_pcm: 0,
        i_satd_chroma: 0,
        i_satd_chroma_dir: [0; 7],
        i_predict8x8chroma: 0,
        l0: x264_mb_analysis_list_t {
            me16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            bi16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            me8x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4],
            me4x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4]; 4],
            me8x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me4x8: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me16x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            me8x16: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            i_rd16x16: 0,
            i_cost8x8: 0,
            i_cost4x4: [0; 4],
            i_cost8x4: [0; 4],
            i_cost4x8: [0; 4],
            i_cost16x8: 0,
            i_cost8x16: 0,
            mvc: [[[0; 2]; 6]; 32],
        },
        l1: x264_mb_analysis_list_t {
            me16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            bi16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            me8x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4],
            me4x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4]; 4],
            me8x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me4x8: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me16x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            me8x16: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            i_rd16x16: 0,
            i_cost8x8: 0,
            i_cost4x4: [0; 4],
            i_cost8x4: [0; 4],
            i_cost4x8: [0; 4],
            i_cost16x8: 0,
            i_cost8x16: 0,
            mvc: [[[0; 2]; 6]; 32],
        },
        i_cost16x16bi: 0,
        i_cost16x16direct: 0,
        i_cost8x8bi: 0,
        i_cost8x8direct: [0; 4],
        i_satd8x8: [[0; 4]; 3],
        i_cost_est16x8: [0; 2],
        i_cost_est8x16: [0; 2],
        i_cost16x8bi: 0,
        i_cost8x16bi: 0,
        i_rd16x16bi: 0,
        i_rd16x16direct: 0,
        i_rd16x8bi: 0,
        i_rd8x16bi: 0,
        i_rd8x8bi: 0,
        i_mb_partition16x8: [0; 2],
        i_mb_partition8x16: [0; 2],
        i_mb_type16x8: 0,
        i_mb_type8x16: 0,
        b_direct_available: 0,
        b_early_terminate: 0,
    };
    let mut i_cost: libc::c_int = (1 as libc::c_int) << 28 as libc::c_int;
    (*h).mb.i_qp = x264_8_ratecontrol_mb_qp(h);
    if (*h).param.rc.i_aq_mode != 0
        && (*h).param.analyse.i_subpel_refine < 10 as libc::c_int
    {
        (*h)
            .mb
            .i_qp = if abs((*h).mb.i_qp - (*h).mb.i_last_qp) == 1 as libc::c_int {
            (*h).mb.i_last_qp
        } else {
            (*h).mb.i_qp
        };
    }
    if (*h).param.analyse.b_mb_info != 0 {
        *((*(*h).fdec).effective_qp)
            .offset((*h).mb.i_mb_xy as isize) = (*h).mb.i_qp as uint8_t;
    }
    mb_analyse_init(h, &mut analysis, (*h).mb.i_qp);
    if (*h).sh.i_type == SLICE_TYPE_I as libc::c_int {
        current_block = 10193120697285822987;
    } else if (*h).sh.i_type == SLICE_TYPE_P as libc::c_int {
        let mut b_skip: libc::c_int = 0 as libc::c_int;
        ((*h).mc.prefetch_ref)
            .expect(
                "non-null function pointer",
            )(
            (*h)
                .mb
                .pic
                .p_fref[0 as libc::c_int
                as usize][0 as libc::c_int
                as usize][((*h).mb.i_mb_x & 3 as libc::c_int) as usize],
            (*h).mb.pic.i_stride[0 as libc::c_int as usize] as intptr_t,
            0 as libc::c_int,
        );
        analysis.b_try_skip = 0 as libc::c_int;
        if analysis.b_force_intra != 0 {
            if (*h).param.analyse.b_psy == 0 {
                mb_analyse_init_qp(
                    h,
                    &mut analysis,
                    if (*h).mb.i_qp - (*h).mb.ip_offset > (*h).param.rc.i_qp_min {
                        (*h).mb.i_qp - (*h).mb.ip_offset
                    } else {
                        (*h).param.rc.i_qp_min
                    },
                );
                current_block = 10193120697285822987;
            } else {
                current_block = 13460095289871124136;
            }
        } else {
            if !((*(*h).fdec).mb_info).is_null()
                && *((*(*h).fdec).mb_info).offset((*h).mb.i_mb_xy as isize)
                    as libc::c_uint & (1 as libc::c_uint) << 0 as libc::c_int != 0
            {
                if (*h).sh.b_mbaff == 0
                    && (*(*h).fdec).i_frame
                        - (*(*h)
                            .fref[0 as libc::c_int as usize][0 as libc::c_int as usize])
                            .i_frame == 1 as libc::c_int && (*h).sh.b_weighted_pred == 0
                    && *((*(*h)
                        .fref[0 as libc::c_int as usize][0 as libc::c_int as usize])
                        .effective_qp)
                        .offset((*h).mb.i_mb_xy as isize) as libc::c_int <= (*h).mb.i_qp
                {
                    (*h).mb.i_partition = D_16x16 as libc::c_int;
                    if (*(((*h).mb.cache.pskip_mv).as_mut_ptr() as *mut x264_union32_t))
                        .i == 0
                    {
                        b_skip = 1 as libc::c_int;
                        (*h).mb.i_type = P_SKIP as libc::c_int;
                    } else {
                        (*h).mb.i_type = P_L0 as libc::c_int;
                        analysis.l0.me16x16.i_ref = 0 as libc::c_int;
                        (*((analysis.l0.me16x16.mv).as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as libc::c_int as uint32_t;
                    }
                    current_block = 2256356447621023004;
                } else {
                    if (*h).param.analyse.b_mb_info_update != 0 {
                        let ref mut fresh25 = *((*(*h).fdec).mb_info)
                            .offset((*h).mb.i_mb_xy as isize);
                        *fresh25 = (*fresh25 as libc::c_uint
                            & !((1 as libc::c_uint) << 0 as libc::c_int)) as uint8_t;
                    }
                    current_block = 14072441030219150333;
                }
            } else {
                current_block = 14072441030219150333;
            }
            match current_block {
                2256356447621023004 => {}
                _ => {
                    let mut skip_invalid: libc::c_int = ((*h).i_thread_frames
                        > 1 as libc::c_int
                        && (*h).mb.cache.pskip_mv[1 as libc::c_int as usize]
                            as libc::c_int
                            > (*h).mb.mv_max_spel[1 as libc::c_int as usize])
                        as libc::c_int;
                    if 1 as libc::c_int != 0 && (*h).mb.b_interlaced == 0
                        && (*h).mb.i_mb_y * 16 as libc::c_int >= (*h).param.i_height
                        && skip_invalid == 0
                    {
                        b_skip = 1 as libc::c_int;
                    } else if (*h).param.analyse.b_fast_pskip != 0 {
                        if !(skip_invalid != 0) {
                            if (*h).param.analyse.i_subpel_refine >= 3 as libc::c_int {
                                analysis.b_try_skip = 1 as libc::c_int;
                            } else if (*h).mb.i_mb_type_left[0 as libc::c_int as usize]
                                == P_SKIP as libc::c_int
                                || (*h).mb.i_mb_type_top == P_SKIP as libc::c_int
                                || (*h).mb.i_mb_type_topleft == P_SKIP as libc::c_int
                                || (*h).mb.i_mb_type_topright == P_SKIP as libc::c_int
                            {
                                b_skip = x264_8_macroblock_probe_skip(h, 0 as libc::c_int);
                            }
                        }
                    }
                    current_block = 13460095289871124136;
                }
            }
        }
        match current_block {
            10193120697285822987 => {}
            _ => {
                match current_block {
                    13460095289871124136 => {
                        ((*h).mc.prefetch_ref)
                            .expect(
                                "non-null function pointer",
                            )(
                            (*h)
                                .mb
                                .pic
                                .p_fref[0 as libc::c_int
                                as usize][0 as libc::c_int
                                as usize][((*h).mb.i_mb_x & 3 as libc::c_int) as usize],
                            (*h).mb.pic.i_stride[0 as libc::c_int as usize] as intptr_t,
                            1 as libc::c_int,
                        );
                        if b_skip != 0 {
                            (*h).mb.i_type = P_SKIP as libc::c_int;
                            (*h).mb.i_partition = D_16x16 as libc::c_int;
                            if (*h).mb.cache.pskip_mv[1 as libc::c_int as usize]
                                as libc::c_int
                                <= (*h).mb.mv_max_spel[1 as libc::c_int as usize]
                                || (*h).i_thread_frames == 1 as libc::c_int
                            {} else {
                                __assert_fail(
                                    b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                                        as *const u8 as *const libc::c_char,
                                    b"encoder/analyse.c\0" as *const u8 as *const libc::c_char,
                                    3023 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 41],
                                        &[libc::c_char; 41],
                                    >(b"void x264_8_macroblock_analyse(x264_t *)\0"))
                                        .as_ptr(),
                                );
                            }
                            'c_106395: {
                                if (*h).mb.cache.pskip_mv[1 as libc::c_int as usize]
                                    as libc::c_int
                                    <= (*h).mb.mv_max_spel[1 as libc::c_int as usize]
                                    || (*h).i_thread_frames == 1 as libc::c_int
                                {} else {
                                    __assert_fail(
                                        b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                                            as *const u8 as *const libc::c_char,
                                        b"encoder/analyse.c\0" as *const u8 as *const libc::c_char,
                                        3023 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 41],
                                            &[libc::c_char; 41],
                                        >(b"void x264_8_macroblock_analyse(x264_t *)\0"))
                                            .as_ptr(),
                                    );
                                }
                            };
                            current_block = 2256356447621023004;
                        } else {
                            let flags: libc::c_uint = (*h).param.analyse.inter;
                            let mut i_type: libc::c_int = 0;
                            let mut i_partition: libc::c_int = 0;
                            let mut i_satd_inter: libc::c_int = 0;
                            let mut i_satd_intra: libc::c_int = 0;
                            mb_analyse_load_costs(h, &mut analysis);
                            mb_analyse_inter_p16x16(h, &mut analysis);
                            if (*h).mb.i_type == P_SKIP as libc::c_int {
                                let mut i_0: libc::c_int = 1 as libc::c_int;
                                while i_0 < (*h).mb.pic.i_fref[0 as libc::c_int as usize] {
                                    (*((*((*h).mb.mvr[0 as libc::c_int as usize][i_0 as usize])
                                        .offset((*h).mb.i_mb_xy as isize))
                                        .as_mut_ptr() as *mut x264_union32_t))
                                        .i = 0 as libc::c_int as uint32_t;
                                    i_0 += 1;
                                    i_0;
                                }
                                return;
                            }
                            if flags & 0x10 as libc::c_uint != 0 {
                                if (*h).param.analyse.b_mixed_references != 0 {
                                    mb_analyse_inter_p8x8_mixed_ref(h, &mut analysis);
                                } else {
                                    mb_analyse_inter_p8x8(h, &mut analysis);
                                }
                            }
                            i_type = P_L0 as libc::c_int;
                            i_partition = D_16x16 as libc::c_int;
                            i_cost = analysis.l0.me16x16.cost;
                            if flags & 0x10 as libc::c_uint != 0
                                && (analysis.b_early_terminate == 0
                                    || analysis.l0.i_cost8x8 < analysis.l0.me16x16.cost)
                            {
                                i_type = P_8x8 as libc::c_int;
                                i_partition = D_8x8 as libc::c_int;
                                i_cost = analysis.l0.i_cost8x8;
                                if flags & 0x20 as libc::c_uint != 0 {
                                    let mut i_1: libc::c_int = 0 as libc::c_int;
                                    while i_1 < 4 as libc::c_int {
                                        mb_analyse_inter_p4x4(h, &mut analysis, i_1);
                                        let mut i_thresh8x4: libc::c_int = analysis
                                            .l0
                                            .me4x4[i_1 as usize][1 as libc::c_int as usize]
                                            .cost_mv
                                            + analysis
                                                .l0
                                                .me4x4[i_1 as usize][2 as libc::c_int as usize]
                                                .cost_mv;
                                        if analysis.b_early_terminate == 0
                                            || analysis.l0.i_cost4x4[i_1 as usize]
                                                < analysis.l0.me8x8[i_1 as usize].cost + i_thresh8x4
                                        {
                                            let mut i_cost8x8: libc::c_int = analysis
                                                .l0
                                                .i_cost4x4[i_1 as usize];
                                            (*h)
                                                .mb
                                                .i_sub_partition[i_1
                                                as usize] = D_L0_4x4 as libc::c_int as uint8_t;
                                            mb_analyse_inter_p8x4(h, &mut analysis, i_1);
                                            if analysis.l0.i_cost8x4[i_1 as usize] < i_cost8x8 {
                                                i_cost8x8 = analysis.l0.i_cost8x4[i_1 as usize];
                                                (*h)
                                                    .mb
                                                    .i_sub_partition[i_1
                                                    as usize] = D_L0_8x4 as libc::c_int as uint8_t;
                                            }
                                            mb_analyse_inter_p4x8(h, &mut analysis, i_1);
                                            if analysis.l0.i_cost4x8[i_1 as usize] < i_cost8x8 {
                                                i_cost8x8 = analysis.l0.i_cost4x8[i_1 as usize];
                                                (*h)
                                                    .mb
                                                    .i_sub_partition[i_1
                                                    as usize] = D_L0_4x8 as libc::c_int as uint8_t;
                                            }
                                            i_cost += i_cost8x8 - analysis.l0.me8x8[i_1 as usize].cost;
                                        }
                                        mb_cache_mv_p8x8(h, &mut analysis, i_1);
                                        i_1 += 1;
                                        i_1;
                                    }
                                    analysis.l0.i_cost8x8 = i_cost;
                                }
                            }
                            let mut i_thresh16x8: libc::c_int = analysis
                                .l0
                                .me8x8[1 as libc::c_int as usize]
                                .cost_mv
                                + analysis.l0.me8x8[2 as libc::c_int as usize].cost_mv;
                            if flags & 0x10 as libc::c_uint != 0
                                && (analysis.b_early_terminate == 0
                                    || analysis.l0.i_cost8x8
                                        < analysis.l0.me16x16.cost + i_thresh16x8)
                            {
                                let mut i_avg_mv_ref_cost: libc::c_int = analysis
                                    .l0
                                    .me8x8[2 as libc::c_int as usize]
                                    .cost_mv
                                    + analysis.l0.me8x8[2 as libc::c_int as usize].i_ref_cost
                                    + analysis.l0.me8x8[3 as libc::c_int as usize].cost_mv
                                    + analysis.l0.me8x8[3 as libc::c_int as usize].i_ref_cost
                                    + 1 as libc::c_int >> 1 as libc::c_int;
                                analysis
                                    .i_cost_est16x8[1 as libc::c_int
                                    as usize] = analysis
                                    .i_satd8x8[0 as libc::c_int
                                    as usize][2 as libc::c_int as usize]
                                    + analysis
                                        .i_satd8x8[0 as libc::c_int
                                        as usize][3 as libc::c_int as usize] + i_avg_mv_ref_cost;
                                mb_analyse_inter_p16x8(h, &mut analysis, i_cost);
                                if analysis.l0.i_cost16x8 < i_cost {
                                    i_cost = analysis.l0.i_cost16x8;
                                    i_type = P_L0 as libc::c_int;
                                    i_partition = D_16x8 as libc::c_int;
                                }
                                i_avg_mv_ref_cost = analysis
                                    .l0
                                    .me8x8[1 as libc::c_int as usize]
                                    .cost_mv
                                    + analysis.l0.me8x8[1 as libc::c_int as usize].i_ref_cost
                                    + analysis.l0.me8x8[3 as libc::c_int as usize].cost_mv
                                    + analysis.l0.me8x8[3 as libc::c_int as usize].i_ref_cost
                                    + 1 as libc::c_int >> 1 as libc::c_int;
                                analysis
                                    .i_cost_est8x16[1 as libc::c_int
                                    as usize] = analysis
                                    .i_satd8x8[0 as libc::c_int
                                    as usize][1 as libc::c_int as usize]
                                    + analysis
                                        .i_satd8x8[0 as libc::c_int
                                        as usize][3 as libc::c_int as usize] + i_avg_mv_ref_cost;
                                mb_analyse_inter_p8x16(h, &mut analysis, i_cost);
                                if analysis.l0.i_cost8x16 < i_cost {
                                    i_cost = analysis.l0.i_cost8x16;
                                    i_type = P_L0 as libc::c_int;
                                    i_partition = D_8x16 as libc::c_int;
                                }
                            }
                            (*h).mb.i_partition = i_partition;
                            if !(analysis.i_mbrd != 0 || (*h).mb.i_subpel_refine == 0) {
                                if i_partition == D_16x16 as libc::c_int {
                                    x264_8_me_refine_qpel(h, &mut analysis.l0.me16x16);
                                    i_cost = analysis.l0.me16x16.cost;
                                } else if i_partition == D_16x8 as libc::c_int {
                                    x264_8_me_refine_qpel(
                                        h,
                                        &mut *(analysis.l0.me16x8)
                                            .as_mut_ptr()
                                            .offset(0 as libc::c_int as isize),
                                    );
                                    x264_8_me_refine_qpel(
                                        h,
                                        &mut *(analysis.l0.me16x8)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize),
                                    );
                                    i_cost = analysis.l0.me16x8[0 as libc::c_int as usize].cost
                                        + analysis.l0.me16x8[1 as libc::c_int as usize].cost;
                                } else if i_partition == D_8x16 as libc::c_int {
                                    x264_8_me_refine_qpel(
                                        h,
                                        &mut *(analysis.l0.me8x16)
                                            .as_mut_ptr()
                                            .offset(0 as libc::c_int as isize),
                                    );
                                    x264_8_me_refine_qpel(
                                        h,
                                        &mut *(analysis.l0.me8x16)
                                            .as_mut_ptr()
                                            .offset(1 as libc::c_int as isize),
                                    );
                                    i_cost = analysis.l0.me8x16[0 as libc::c_int as usize].cost
                                        + analysis.l0.me8x16[1 as libc::c_int as usize].cost;
                                } else if i_partition == D_8x8 as libc::c_int {
                                    i_cost = 0 as libc::c_int;
                                    let mut i8x8: libc::c_int = 0 as libc::c_int;
                                    while i8x8 < 4 as libc::c_int {
                                        match (*h).mb.i_sub_partition[i8x8 as usize] as libc::c_int
                                        {
                                            3 => {
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(analysis.l0.me8x8).as_mut_ptr().offset(i8x8 as isize),
                                                );
                                                i_cost += analysis.l0.me8x8[i8x8 as usize].cost;
                                            }
                                            1 => {
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me8x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(0 as libc::c_int as isize),
                                                );
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me8x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize),
                                                );
                                                i_cost
                                                    += analysis
                                                        .l0
                                                        .me8x4[i8x8 as usize][0 as libc::c_int as usize]
                                                        .cost
                                                        + analysis
                                                            .l0
                                                            .me8x4[i8x8 as usize][1 as libc::c_int as usize]
                                                            .cost;
                                            }
                                            2 => {
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x8)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(0 as libc::c_int as isize),
                                                );
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x8)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize),
                                                );
                                                i_cost
                                                    += analysis
                                                        .l0
                                                        .me4x8[i8x8 as usize][0 as libc::c_int as usize]
                                                        .cost
                                                        + analysis
                                                            .l0
                                                            .me4x8[i8x8 as usize][1 as libc::c_int as usize]
                                                            .cost;
                                            }
                                            0 => {
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(0 as libc::c_int as isize),
                                                );
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize),
                                                );
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(2 as libc::c_int as isize),
                                                );
                                                x264_8_me_refine_qpel(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                        .as_mut_ptr()
                                                        .offset(3 as libc::c_int as isize),
                                                );
                                                i_cost
                                                    += analysis
                                                        .l0
                                                        .me4x4[i8x8 as usize][0 as libc::c_int as usize]
                                                        .cost
                                                        + analysis
                                                            .l0
                                                            .me4x4[i8x8 as usize][1 as libc::c_int as usize]
                                                            .cost
                                                        + analysis
                                                            .l0
                                                            .me4x4[i8x8 as usize][2 as libc::c_int as usize]
                                                            .cost
                                                        + analysis
                                                            .l0
                                                            .me4x4[i8x8 as usize][3 as libc::c_int as usize]
                                                            .cost;
                                            }
                                            _ => {
                                                x264_8_log(
                                                    h,
                                                    0 as libc::c_int,
                                                    b"internal error (!8x8 && !4x4)\n\0" as *const u8
                                                        as *const libc::c_char,
                                                );
                                            }
                                        }
                                        i8x8 += 1;
                                        i8x8;
                                    }
                                }
                            }
                            if (*h).mb.b_chroma_me != 0 {
                                if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                                    == CHROMA_444 as libc::c_int
                                {
                                    mb_analyse_intra(h, &mut analysis, i_cost);
                                    mb_analyse_intra_chroma(h, &mut analysis);
                                } else {
                                    mb_analyse_intra_chroma(h, &mut analysis);
                                    mb_analyse_intra(
                                        h,
                                        &mut analysis,
                                        i_cost - analysis.i_satd_chroma,
                                    );
                                }
                                analysis.i_satd_i16x16 += analysis.i_satd_chroma;
                                analysis.i_satd_i8x8 += analysis.i_satd_chroma;
                                analysis.i_satd_i4x4 += analysis.i_satd_chroma;
                            } else {
                                mb_analyse_intra(h, &mut analysis, i_cost);
                            }
                            i_satd_inter = i_cost;
                            i_satd_intra = if analysis.i_satd_i16x16
                                < (if analysis.i_satd_i8x8 < analysis.i_satd_i4x4 {
                                    analysis.i_satd_i8x8
                                } else {
                                    analysis.i_satd_i4x4
                                })
                            {
                                analysis.i_satd_i16x16
                            } else if analysis.i_satd_i8x8 < analysis.i_satd_i4x4 {
                                analysis.i_satd_i8x8
                            } else {
                                analysis.i_satd_i4x4
                            };
                            if analysis.i_mbrd != 0 {
                                mb_analyse_p_rd(
                                    h,
                                    &mut analysis,
                                    if i_satd_inter < i_satd_intra {
                                        i_satd_inter
                                    } else {
                                        i_satd_intra
                                    },
                                );
                                i_type = P_L0 as libc::c_int;
                                i_partition = D_16x16 as libc::c_int;
                                i_cost = analysis.l0.i_rd16x16;
                                if analysis.l0.i_cost16x8 < i_cost {
                                    i_cost = analysis.l0.i_cost16x8;
                                    i_partition = D_16x8 as libc::c_int;
                                }
                                if analysis.l0.i_cost8x16 < i_cost {
                                    i_cost = analysis.l0.i_cost8x16;
                                    i_partition = D_8x16 as libc::c_int;
                                }
                                if analysis.l0.i_cost8x8 < i_cost {
                                    i_cost = analysis.l0.i_cost8x8;
                                    i_partition = D_8x8 as libc::c_int;
                                    i_type = P_8x8 as libc::c_int;
                                }
                                (*h).mb.i_type = i_type;
                                (*h).mb.i_partition = i_partition;
                                if i_cost < (1 as libc::c_int) << 28 as libc::c_int {
                                    mb_analyse_transform_rd(
                                        h,
                                        &mut analysis,
                                        &mut i_satd_inter,
                                        &mut i_cost,
                                    );
                                }
                                intra_rd(
                                    h,
                                    &mut analysis,
                                    i_satd_inter * 5 as libc::c_int / 4 as libc::c_int
                                        + 1 as libc::c_int,
                                );
                            }
                            if analysis.i_satd_i16x16 < i_cost {
                                i_cost = analysis.i_satd_i16x16;
                                i_type = I_16x16 as libc::c_int;
                            }
                            if analysis.i_satd_i8x8 < i_cost {
                                i_cost = analysis.i_satd_i8x8;
                                i_type = I_8x8 as libc::c_int;
                            }
                            if analysis.i_satd_i4x4 < i_cost {
                                i_cost = analysis.i_satd_i4x4;
                                i_type = I_4x4 as libc::c_int;
                            }
                            if analysis.i_satd_pcm < i_cost {
                                i_cost = analysis.i_satd_pcm;
                                i_type = I_PCM as libc::c_int;
                            }
                            (*h).mb.i_type = i_type;
                            if analysis.b_force_intra != 0
                                && !(i_type == I_4x4 as libc::c_int
                                    || i_type == I_8x8 as libc::c_int
                                    || i_type == I_16x16 as libc::c_int
                                    || i_type == I_PCM as libc::c_int)
                            {
                                analyse_update_cache(h, &mut analysis);
                                x264_8_macroblock_encode(h);
                                let mut p: libc::c_int = 0 as libc::c_int;
                                while p
                                    < (if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                                        == CHROMA_444 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        1 as libc::c_int
                                    })
                                {
                                    ((*h).mc.copy[PIXEL_16x16 as libc::c_int as usize])
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        (*h).mb.pic.p_fenc[p as usize],
                                        16 as libc::c_int as intptr_t,
                                        (*h).mb.pic.p_fdec[p as usize],
                                        32 as libc::c_int as intptr_t,
                                        16 as libc::c_int,
                                    );
                                    p += 1;
                                    p;
                                }
                                if !((*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                                    == CHROMA_444 as libc::c_int)
                                {
                                    let mut height: libc::c_int = 16 as libc::c_int
                                        >> (*h).mb.chroma_v_shift;
                                    ((*h).mc.copy[PIXEL_8x8 as libc::c_int as usize])
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        (*h).mb.pic.p_fenc[1 as libc::c_int as usize],
                                        16 as libc::c_int as intptr_t,
                                        (*h).mb.pic.p_fdec[1 as libc::c_int as usize],
                                        32 as libc::c_int as intptr_t,
                                        height,
                                    );
                                    ((*h).mc.copy[PIXEL_8x8 as libc::c_int as usize])
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        (*h).mb.pic.p_fenc[2 as libc::c_int as usize],
                                        16 as libc::c_int as intptr_t,
                                        (*h).mb.pic.p_fdec[2 as libc::c_int as usize],
                                        32 as libc::c_int as intptr_t,
                                        height,
                                    );
                                }
                                mb_analyse_init_qp(
                                    h,
                                    &mut analysis,
                                    if (*h).mb.i_qp - (*h).mb.ip_offset > (*h).param.rc.i_qp_min
                                    {
                                        (*h).mb.i_qp - (*h).mb.ip_offset
                                    } else {
                                        (*h).param.rc.i_qp_min
                                    },
                                );
                                current_block = 10193120697285822987;
                            } else {
                                if analysis.i_mbrd >= 2 as libc::c_int
                                    && (*h).mb.i_type != I_PCM as libc::c_int
                                {
                                    if (*h).mb.i_type == I_4x4 as libc::c_int
                                        || (*h).mb.i_type == I_8x8 as libc::c_int
                                        || (*h).mb.i_type == I_16x16 as libc::c_int
                                        || (*h).mb.i_type == I_PCM as libc::c_int
                                    {
                                        intra_rd_refine(h, &mut analysis);
                                    } else if i_partition == D_16x16 as libc::c_int {
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as libc::c_int,
                                            0 as libc::c_int,
                                            4 as libc::c_int,
                                            4 as libc::c_int,
                                            0 as libc::c_int,
                                            analysis.l0.me16x16.i_ref as int8_t,
                                        );
                                        analysis.l0.me16x16.cost = i_cost;
                                        x264_8_me_refine_qpel_rd(
                                            h,
                                            &mut analysis.l0.me16x16,
                                            analysis.i_lambda2,
                                            0 as libc::c_int,
                                            0 as libc::c_int,
                                        );
                                    } else if i_partition == D_16x8 as libc::c_int {
                                        (*(((*h).mb.i_sub_partition).as_mut_ptr()
                                            as *mut x264_union32_t))
                                            .i = (D_L0_8x8 as libc::c_int * 0x1010101 as libc::c_int)
                                            as uint32_t;
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as libc::c_int,
                                            0 as libc::c_int,
                                            4 as libc::c_int,
                                            2 as libc::c_int,
                                            0 as libc::c_int,
                                            analysis.l0.me16x8[0 as libc::c_int as usize].i_ref
                                                as int8_t,
                                        );
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as libc::c_int,
                                            2 as libc::c_int,
                                            4 as libc::c_int,
                                            2 as libc::c_int,
                                            0 as libc::c_int,
                                            analysis.l0.me16x8[1 as libc::c_int as usize].i_ref
                                                as int8_t,
                                        );
                                        x264_8_me_refine_qpel_rd(
                                            h,
                                            &mut *(analysis.l0.me16x8)
                                                .as_mut_ptr()
                                                .offset(0 as libc::c_int as isize),
                                            analysis.i_lambda2,
                                            0 as libc::c_int,
                                            0 as libc::c_int,
                                        );
                                        x264_8_me_refine_qpel_rd(
                                            h,
                                            &mut *(analysis.l0.me16x8)
                                                .as_mut_ptr()
                                                .offset(1 as libc::c_int as isize),
                                            analysis.i_lambda2,
                                            8 as libc::c_int,
                                            0 as libc::c_int,
                                        );
                                    } else if i_partition == D_8x16 as libc::c_int {
                                        (*(((*h).mb.i_sub_partition).as_mut_ptr()
                                            as *mut x264_union32_t))
                                            .i = (D_L0_8x8 as libc::c_int * 0x1010101 as libc::c_int)
                                            as uint32_t;
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as libc::c_int,
                                            0 as libc::c_int,
                                            2 as libc::c_int,
                                            4 as libc::c_int,
                                            0 as libc::c_int,
                                            analysis.l0.me8x16[0 as libc::c_int as usize].i_ref
                                                as int8_t,
                                        );
                                        x264_macroblock_cache_ref(
                                            h,
                                            2 as libc::c_int,
                                            0 as libc::c_int,
                                            2 as libc::c_int,
                                            4 as libc::c_int,
                                            0 as libc::c_int,
                                            analysis.l0.me8x16[1 as libc::c_int as usize].i_ref
                                                as int8_t,
                                        );
                                        x264_8_me_refine_qpel_rd(
                                            h,
                                            &mut *(analysis.l0.me8x16)
                                                .as_mut_ptr()
                                                .offset(0 as libc::c_int as isize),
                                            analysis.i_lambda2,
                                            0 as libc::c_int,
                                            0 as libc::c_int,
                                        );
                                        x264_8_me_refine_qpel_rd(
                                            h,
                                            &mut *(analysis.l0.me8x16)
                                                .as_mut_ptr()
                                                .offset(1 as libc::c_int as isize),
                                            analysis.i_lambda2,
                                            4 as libc::c_int,
                                            0 as libc::c_int,
                                        );
                                    } else if i_partition == D_8x8 as libc::c_int {
                                        analyse_update_cache(h, &mut analysis);
                                        let mut i8x8_0: libc::c_int = 0 as libc::c_int;
                                        while i8x8_0 < 4 as libc::c_int {
                                            if (*h).mb.i_sub_partition[i8x8_0 as usize] as libc::c_int
                                                == D_L0_8x8 as libc::c_int
                                            {
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(analysis.l0.me8x8)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                            } else if (*h).mb.i_sub_partition[i8x8_0 as usize]
                                                as libc::c_int == D_L0_8x4 as libc::c_int
                                            {
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me8x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(0 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 0 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me8x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 2 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                            } else if (*h).mb.i_sub_partition[i8x8_0 as usize]
                                                as libc::c_int == D_L0_4x8 as libc::c_int
                                            {
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x8)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(0 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 0 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x8)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 1 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                            } else if (*h).mb.i_sub_partition[i8x8_0 as usize]
                                                as libc::c_int == D_L0_4x4 as libc::c_int
                                            {
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(0 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 0 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(1 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 1 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(2 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 2 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                                x264_8_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*(analysis.l0.me4x4)
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                        .as_mut_ptr()
                                                        .offset(3 as libc::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as libc::c_int + 3 as libc::c_int,
                                                    0 as libc::c_int,
                                                );
                                            }
                                            i8x8_0 += 1;
                                            i8x8_0;
                                        }
                                    }
                                }
                                current_block = 17193116482801528934;
                            }
                        }
                    }
                    _ => {}
                }
                match current_block {
                    17193116482801528934 => {}
                    10193120697285822987 => {}
                    _ => {
                        let mut i: libc::c_int = 0 as libc::c_int;
                        while i < (*h).mb.pic.i_fref[0 as libc::c_int as usize] {
                            (*((*((*h).mb.mvr[0 as libc::c_int as usize][i as usize])
                                .offset((*h).mb.i_mb_xy as isize))
                                .as_mut_ptr() as *mut x264_union32_t))
                                .i = 0 as libc::c_int as uint32_t;
                            i += 1;
                            i;
                        }
                        current_block = 17193116482801528934;
                    }
                }
            }
        }
    } else {
        if (*h).sh.i_type == SLICE_TYPE_B as libc::c_int {
            let mut i_bskip_cost: libc::c_int = (1 as libc::c_int) << 28 as libc::c_int;
            let mut b_skip_0: libc::c_int = 0 as libc::c_int;
            if analysis.i_mbrd != 0 {
                mb_init_fenc_cache(
                    h,
                    (analysis.i_mbrd >= 2 as libc::c_int) as libc::c_int,
                );
            }
            (*h).mb.i_type = B_SKIP as libc::c_int;
            if (*h).mb.b_direct_auto_write != 0 {
                let mut i_2: libc::c_int = 0 as libc::c_int;
                while i_2 < 2 as libc::c_int {
                    let mut b_changed: libc::c_int = 1 as libc::c_int;
                    (*h).sh.b_direct_spatial_mv_pred ^= 1 as libc::c_int;
                    analysis
                        .b_direct_available = x264_8_mb_predict_mv_direct16x16(
                        h,
                        if i_2 != 0 && analysis.b_direct_available != 0 {
                            &mut b_changed
                        } else {
                            0 as *mut libc::c_int
                        },
                    );
                    if analysis.b_direct_available != 0 {
                        if b_changed != 0 {
                            x264_8_mb_mc(h);
                            b_skip_0 = x264_8_macroblock_probe_skip(h, 1 as libc::c_int);
                        }
                        (*h)
                            .stat
                            .frame
                            .i_direct_score[(*h).sh.b_direct_spatial_mv_pred as usize]
                            += b_skip_0;
                    } else {
                        b_skip_0 = 0 as libc::c_int;
                    }
                    i_2 += 1;
                    i_2;
                }
            } else {
                analysis
                    .b_direct_available = x264_8_mb_predict_mv_direct16x16(
                    h,
                    0 as *mut libc::c_int,
                );
            }
            analysis.b_try_skip = 0 as libc::c_int;
            if analysis.b_direct_available != 0 {
                if (*h).mb.b_direct_auto_write == 0 {
                    x264_8_mb_mc(h);
                }
                if 1 as libc::c_int != 0 && (*h).mb.b_interlaced == 0
                    && (*h).mb.i_mb_y * 16 as libc::c_int >= (*h).param.i_height
                {
                    b_skip_0 = 1 as libc::c_int;
                } else if analysis.i_mbrd != 0 {
                    i_bskip_cost = ssd_mb(h);
                    (*h)
                        .mb
                        .b_skip_mc = (i_bskip_cost
                        <= 6 as libc::c_int * analysis.i_lambda2 + 128 as libc::c_int
                            >> 8 as libc::c_int) as libc::c_int;
                    b_skip_0 = (*h).mb.b_skip_mc;
                } else if (*h).mb.b_direct_auto_write == 0 {
                    analysis
                        .b_try_skip = x264_8_macroblock_probe_skip(h, 1 as libc::c_int);
                    if (*h).param.analyse.i_subpel_refine < 3 as libc::c_int {
                        b_skip_0 = analysis.b_try_skip;
                    }
                }
                if b_skip_0 != 0 {
                    let mut i_3: libc::c_int = 0 as libc::c_int;
                    while i_3 < (*h).mb.pic.i_fref[0 as libc::c_int as usize] {
                        (*((*((*h).mb.mvr[0 as libc::c_int as usize][i_3 as usize])
                            .offset((*h).mb.i_mb_xy as isize))
                            .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as libc::c_int as uint32_t;
                        i_3 += 1;
                        i_3;
                    }
                    let mut i_4: libc::c_int = 0 as libc::c_int;
                    while i_4 < (*h).mb.pic.i_fref[1 as libc::c_int as usize] {
                        (*((*((*h).mb.mvr[1 as libc::c_int as usize][i_4 as usize])
                            .offset((*h).mb.i_mb_xy as isize))
                            .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as libc::c_int as uint32_t;
                        i_4 += 1;
                        i_4;
                    }
                }
            }
            if b_skip_0 == 0 {
                let flags_0: libc::c_uint = (*h).param.analyse.inter;
                let mut i_type_0: libc::c_int = 0;
                let mut i_partition_0: libc::c_int = 0;
                let mut i_satd_inter_0: libc::c_int = 0;
                (*h).mb.b_skip_mc = 0 as libc::c_int;
                (*h).mb.i_type = B_DIRECT as libc::c_int;
                mb_analyse_load_costs(h, &mut analysis);
                if analysis.b_direct_available != 0 {
                    mb_analyse_inter_direct(h, &mut analysis);
                }
                mb_analyse_inter_b16x16(h, &mut analysis);
                if (*h).mb.i_type == B_SKIP as libc::c_int {
                    let mut i_5: libc::c_int = 1 as libc::c_int;
                    while i_5 < (*h).mb.pic.i_fref[0 as libc::c_int as usize] {
                        (*((*((*h).mb.mvr[0 as libc::c_int as usize][i_5 as usize])
                            .offset((*h).mb.i_mb_xy as isize))
                            .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as libc::c_int as uint32_t;
                        i_5 += 1;
                        i_5;
                    }
                    let mut i_6: libc::c_int = 1 as libc::c_int;
                    while i_6 < (*h).mb.pic.i_fref[1 as libc::c_int as usize] {
                        (*((*((*h).mb.mvr[1 as libc::c_int as usize][i_6 as usize])
                            .offset((*h).mb.i_mb_xy as isize))
                            .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as libc::c_int as uint32_t;
                        i_6 += 1;
                        i_6;
                    }
                    return;
                }
                i_type_0 = B_L0_L0 as libc::c_int;
                i_partition_0 = D_16x16 as libc::c_int;
                i_cost = analysis.l0.me16x16.cost;
                if analysis.l1.me16x16.cost < i_cost {
                    i_cost = analysis.l1.me16x16.cost;
                    i_type_0 = B_L1_L1 as libc::c_int;
                }
                if analysis.i_cost16x16bi < i_cost {
                    i_cost = analysis.i_cost16x16bi;
                    i_type_0 = B_BI_BI as libc::c_int;
                }
                if analysis.i_cost16x16direct < i_cost {
                    i_cost = analysis.i_cost16x16direct;
                    i_type_0 = B_DIRECT as libc::c_int;
                }
                if analysis.i_mbrd != 0 && analysis.b_early_terminate != 0
                    && analysis.i_cost16x16direct
                        <= i_cost * 33 as libc::c_int / 32 as libc::c_int
                {
                    mb_analyse_b_rd(h, &mut analysis, i_cost);
                    if i_bskip_cost < analysis.i_rd16x16direct
                        && i_bskip_cost < analysis.i_rd16x16bi
                        && i_bskip_cost < analysis.l0.i_rd16x16
                        && i_bskip_cost < analysis.l1.i_rd16x16
                    {
                        (*h).mb.i_type = B_SKIP as libc::c_int;
                        analyse_update_cache(h, &mut analysis);
                        return;
                    }
                }
                if flags_0 & 0x100 as libc::c_uint != 0 {
                    if (*h).param.analyse.b_mixed_references != 0 {
                        mb_analyse_inter_b8x8_mixed_ref(h, &mut analysis);
                    } else {
                        mb_analyse_inter_b8x8(h, &mut analysis);
                    }
                    if analysis.i_cost8x8bi < i_cost {
                        i_cost = analysis.i_cost8x8bi;
                        i_type_0 = B_8x8 as libc::c_int;
                        i_partition_0 = D_8x8 as libc::c_int;
                    }
                    let mut i_cost_est16x8bi_total: libc::c_int = 0 as libc::c_int;
                    let mut i_cost_est8x16bi_total: libc::c_int = 0 as libc::c_int;
                    let mut i_mb_type: libc::c_int = 0;
                    let mut i_partition16x8: [libc::c_int; 2] = [0; 2];
                    let mut i_partition8x16: [libc::c_int; 2] = [0; 2];
                    let mut i_7: libc::c_int = 0 as libc::c_int;
                    while i_7 < 2 as libc::c_int {
                        let mut avg_l0_mv_ref_cost: libc::c_int = 0;
                        let mut avg_l1_mv_ref_cost: libc::c_int = 0;
                        let mut i_l0_satd: libc::c_int = 0;
                        let mut i_l1_satd: libc::c_int = 0;
                        let mut i_bi_satd: libc::c_int = 0;
                        let mut i_best_cost: libc::c_int = 0;
                        i_best_cost = (1 as libc::c_int) << 28 as libc::c_int;
                        i_l0_satd = analysis
                            .i_satd8x8[0 as libc::c_int
                            as usize][(i_7 * 2 as libc::c_int) as usize]
                            + analysis
                                .i_satd8x8[0 as libc::c_int
                                as usize][(i_7 * 2 as libc::c_int + 1 as libc::c_int)
                                as usize];
                        i_l1_satd = analysis
                            .i_satd8x8[1 as libc::c_int
                            as usize][(i_7 * 2 as libc::c_int) as usize]
                            + analysis
                                .i_satd8x8[1 as libc::c_int
                                as usize][(i_7 * 2 as libc::c_int + 1 as libc::c_int)
                                as usize];
                        i_bi_satd = analysis
                            .i_satd8x8[2 as libc::c_int
                            as usize][(i_7 * 2 as libc::c_int) as usize]
                            + analysis
                                .i_satd8x8[2 as libc::c_int
                                as usize][(i_7 * 2 as libc::c_int + 1 as libc::c_int)
                                as usize];
                        avg_l0_mv_ref_cost = analysis
                            .l0
                            .me8x8[(i_7 * 2 as libc::c_int) as usize]
                            .cost_mv
                            + analysis
                                .l0
                                .me8x8[(i_7 * 2 as libc::c_int) as usize]
                                .i_ref_cost
                            + analysis
                                .l0
                                .me8x8[(i_7 * 2 as libc::c_int + 1 as libc::c_int) as usize]
                                .cost_mv
                            + analysis
                                .l0
                                .me8x8[(i_7 * 2 as libc::c_int + 1 as libc::c_int) as usize]
                                .i_ref_cost + 1 as libc::c_int >> 1 as libc::c_int;
                        avg_l1_mv_ref_cost = analysis
                            .l1
                            .me8x8[(i_7 * 2 as libc::c_int) as usize]
                            .cost_mv
                            + analysis
                                .l1
                                .me8x8[(i_7 * 2 as libc::c_int) as usize]
                                .i_ref_cost
                            + analysis
                                .l1
                                .me8x8[(i_7 * 2 as libc::c_int + 1 as libc::c_int) as usize]
                                .cost_mv
                            + analysis
                                .l1
                                .me8x8[(i_7 * 2 as libc::c_int + 1 as libc::c_int) as usize]
                                .i_ref_cost + 1 as libc::c_int >> 1 as libc::c_int;
                        if i_l0_satd + avg_l0_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l0_satd + avg_l0_mv_ref_cost;
                            i_partition16x8[i_7 as usize] = D_L0_8x8 as libc::c_int;
                        }
                        if i_l1_satd + avg_l1_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l1_satd + avg_l1_mv_ref_cost;
                            i_partition16x8[i_7 as usize] = D_L1_8x8 as libc::c_int;
                        }
                        if i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost
                            < i_best_cost
                        {
                            i_best_cost = i_bi_satd + avg_l0_mv_ref_cost
                                + avg_l1_mv_ref_cost;
                            i_partition16x8[i_7 as usize] = D_BI_8x8 as libc::c_int;
                        }
                        analysis.i_cost_est16x8[i_7 as usize] = i_best_cost;
                        i_best_cost = (1 as libc::c_int) << 28 as libc::c_int;
                        i_l0_satd = analysis
                            .i_satd8x8[0 as libc::c_int as usize][i_7 as usize]
                            + analysis
                                .i_satd8x8[0 as libc::c_int
                                as usize][(i_7 + 2 as libc::c_int) as usize];
                        i_l1_satd = analysis
                            .i_satd8x8[1 as libc::c_int as usize][i_7 as usize]
                            + analysis
                                .i_satd8x8[1 as libc::c_int
                                as usize][(i_7 + 2 as libc::c_int) as usize];
                        i_bi_satd = analysis
                            .i_satd8x8[2 as libc::c_int as usize][i_7 as usize]
                            + analysis
                                .i_satd8x8[2 as libc::c_int
                                as usize][(i_7 + 2 as libc::c_int) as usize];
                        avg_l0_mv_ref_cost = analysis.l0.me8x8[i_7 as usize].cost_mv
                            + analysis.l0.me8x8[i_7 as usize].i_ref_cost
                            + analysis
                                .l0
                                .me8x8[(i_7 + 2 as libc::c_int) as usize]
                                .cost_mv
                            + analysis
                                .l0
                                .me8x8[(i_7 + 2 as libc::c_int) as usize]
                                .i_ref_cost + 1 as libc::c_int >> 1 as libc::c_int;
                        avg_l1_mv_ref_cost = analysis.l1.me8x8[i_7 as usize].cost_mv
                            + analysis.l1.me8x8[i_7 as usize].i_ref_cost
                            + analysis
                                .l1
                                .me8x8[(i_7 + 2 as libc::c_int) as usize]
                                .cost_mv
                            + analysis
                                .l1
                                .me8x8[(i_7 + 2 as libc::c_int) as usize]
                                .i_ref_cost + 1 as libc::c_int >> 1 as libc::c_int;
                        if i_l0_satd + avg_l0_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l0_satd + avg_l0_mv_ref_cost;
                            i_partition8x16[i_7 as usize] = D_L0_8x8 as libc::c_int;
                        }
                        if i_l1_satd + avg_l1_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l1_satd + avg_l1_mv_ref_cost;
                            i_partition8x16[i_7 as usize] = D_L1_8x8 as libc::c_int;
                        }
                        if i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost
                            < i_best_cost
                        {
                            i_best_cost = i_bi_satd + avg_l0_mv_ref_cost
                                + avg_l1_mv_ref_cost;
                            i_partition8x16[i_7 as usize] = D_BI_8x8 as libc::c_int;
                        }
                        analysis.i_cost_est8x16[i_7 as usize] = i_best_cost;
                        i_7 += 1;
                        i_7;
                    }
                    i_mb_type = B_L0_L0 as libc::c_int
                        + (i_partition16x8[0 as libc::c_int as usize]
                            >> 2 as libc::c_int) * 3 as libc::c_int
                        + (i_partition16x8[1 as libc::c_int as usize]
                            >> 2 as libc::c_int);
                    analysis.i_cost_est16x8[1 as libc::c_int as usize]
                        += analysis.i_lambda
                            * i_mb_b16x8_cost_table[i_mb_type as usize] as libc::c_int;
                    i_cost_est16x8bi_total = analysis
                        .i_cost_est16x8[0 as libc::c_int as usize]
                        + analysis.i_cost_est16x8[1 as libc::c_int as usize];
                    i_mb_type = B_L0_L0 as libc::c_int
                        + (i_partition8x16[0 as libc::c_int as usize]
                            >> 2 as libc::c_int) * 3 as libc::c_int
                        + (i_partition8x16[1 as libc::c_int as usize]
                            >> 2 as libc::c_int);
                    analysis.i_cost_est8x16[1 as libc::c_int as usize]
                        += analysis.i_lambda
                            * i_mb_b16x8_cost_table[i_mb_type as usize] as libc::c_int;
                    i_cost_est8x16bi_total = analysis
                        .i_cost_est8x16[0 as libc::c_int as usize]
                        + analysis.i_cost_est8x16[1 as libc::c_int as usize];
                    let mut try_16x8_first: libc::c_int = (i_cost_est16x8bi_total
                        < i_cost_est8x16bi_total) as libc::c_int;
                    if try_16x8_first != 0
                        && (analysis.b_early_terminate == 0
                            || i_cost_est16x8bi_total < i_cost)
                    {
                        mb_analyse_inter_b16x8(h, &mut analysis, i_cost);
                        if analysis.i_cost16x8bi < i_cost {
                            i_cost = analysis.i_cost16x8bi;
                            i_type_0 = analysis.i_mb_type16x8;
                            i_partition_0 = D_16x8 as libc::c_int;
                        }
                    }
                    if analysis.b_early_terminate == 0 || i_cost_est8x16bi_total < i_cost
                    {
                        mb_analyse_inter_b8x16(h, &mut analysis, i_cost);
                        if analysis.i_cost8x16bi < i_cost {
                            i_cost = analysis.i_cost8x16bi;
                            i_type_0 = analysis.i_mb_type8x16;
                            i_partition_0 = D_8x16 as libc::c_int;
                        }
                    }
                    if try_16x8_first == 0
                        && (analysis.b_early_terminate == 0
                            || i_cost_est16x8bi_total < i_cost)
                    {
                        mb_analyse_inter_b16x8(h, &mut analysis, i_cost);
                        if analysis.i_cost16x8bi < i_cost {
                            i_cost = analysis.i_cost16x8bi;
                            i_type_0 = analysis.i_mb_type16x8;
                            i_partition_0 = D_16x8 as libc::c_int;
                        }
                    }
                }
                if !(analysis.i_mbrd != 0 || (*h).mb.i_subpel_refine == 0) {
                    if i_partition_0 == D_16x16 as libc::c_int {
                        analysis.l0.me16x16.cost
                            -= analysis.i_lambda
                                * i_mb_b_cost_table[B_L0_L0 as libc::c_int as usize]
                                    as libc::c_int;
                        analysis.l1.me16x16.cost
                            -= analysis.i_lambda
                                * i_mb_b_cost_table[B_L1_L1 as libc::c_int as usize]
                                    as libc::c_int;
                        if i_type_0 == B_L0_L0 as libc::c_int {
                            x264_8_me_refine_qpel(h, &mut analysis.l0.me16x16);
                            i_cost = analysis.l0.me16x16.cost
                                + analysis.i_lambda
                                    * i_mb_b_cost_table[B_L0_L0 as libc::c_int as usize]
                                        as libc::c_int;
                        } else if i_type_0 == B_L1_L1 as libc::c_int {
                            x264_8_me_refine_qpel(h, &mut analysis.l1.me16x16);
                            i_cost = analysis.l1.me16x16.cost
                                + analysis.i_lambda
                                    * i_mb_b_cost_table[B_L1_L1 as libc::c_int as usize]
                                        as libc::c_int;
                        } else if i_type_0 == B_BI_BI as libc::c_int {
                            x264_8_me_refine_qpel(h, &mut analysis.l0.bi16x16);
                            x264_8_me_refine_qpel(h, &mut analysis.l1.bi16x16);
                        }
                    } else if i_partition_0 == D_16x8 as libc::c_int {
                        let mut i_8: libc::c_int = 0 as libc::c_int;
                        while i_8 < 2 as libc::c_int {
                            if analysis.i_mb_partition16x8[i_8 as usize]
                                != D_L1_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel(
                                    h,
                                    &mut *(analysis.l0.me16x8).as_mut_ptr().offset(i_8 as isize),
                                );
                            }
                            if analysis.i_mb_partition16x8[i_8 as usize]
                                != D_L0_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel(
                                    h,
                                    &mut *(analysis.l1.me16x8).as_mut_ptr().offset(i_8 as isize),
                                );
                            }
                            i_8 += 1;
                            i_8;
                        }
                    } else if i_partition_0 == D_8x16 as libc::c_int {
                        let mut i_9: libc::c_int = 0 as libc::c_int;
                        while i_9 < 2 as libc::c_int {
                            if analysis.i_mb_partition8x16[i_9 as usize]
                                != D_L1_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel(
                                    h,
                                    &mut *(analysis.l0.me8x16).as_mut_ptr().offset(i_9 as isize),
                                );
                            }
                            if analysis.i_mb_partition8x16[i_9 as usize]
                                != D_L0_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel(
                                    h,
                                    &mut *(analysis.l1.me8x16).as_mut_ptr().offset(i_9 as isize),
                                );
                            }
                            i_9 += 1;
                            i_9;
                        }
                    } else if i_partition_0 == D_8x8 as libc::c_int {
                        let mut i_10: libc::c_int = 0 as libc::c_int;
                        while i_10 < 4 as libc::c_int {
                            let mut m: *mut x264_me_t = 0 as *mut x264_me_t;
                            let mut i_part_cost_old: libc::c_int = 0;
                            let mut i_type_cost: libc::c_int = 0;
                            let mut i_part_type: libc::c_int = (*h)
                                .mb
                                .i_sub_partition[i_10 as usize] as libc::c_int;
                            let mut b_bidir: libc::c_int = (i_part_type
                                == D_BI_8x8 as libc::c_int) as libc::c_int;
                            if !(i_part_type == D_DIRECT_8x8 as libc::c_int) {
                                if x264_mb_partition_listX_table[0 as libc::c_int
                                    as usize][i_part_type as usize] != 0
                                {
                                    m = &mut *(analysis.l0.me8x8)
                                        .as_mut_ptr()
                                        .offset(i_10 as isize) as *mut x264_me_t;
                                    i_part_cost_old = (*m).cost;
                                    i_type_cost = analysis.i_lambda
                                        * i_sub_mb_b_cost_table[D_L0_8x8 as libc::c_int as usize]
                                            as libc::c_int;
                                    (*m).cost -= i_type_cost;
                                    x264_8_me_refine_qpel(h, m);
                                    if b_bidir == 0 {
                                        analysis.i_cost8x8bi
                                            += (*m).cost + i_type_cost - i_part_cost_old;
                                    }
                                }
                                if x264_mb_partition_listX_table[1 as libc::c_int
                                    as usize][i_part_type as usize] != 0
                                {
                                    m = &mut *(analysis.l1.me8x8)
                                        .as_mut_ptr()
                                        .offset(i_10 as isize) as *mut x264_me_t;
                                    i_part_cost_old = (*m).cost;
                                    i_type_cost = analysis.i_lambda
                                        * i_sub_mb_b_cost_table[D_L1_8x8 as libc::c_int as usize]
                                            as libc::c_int;
                                    (*m).cost -= i_type_cost;
                                    x264_8_me_refine_qpel(h, m);
                                    if b_bidir == 0 {
                                        analysis.i_cost8x8bi
                                            += (*m).cost + i_type_cost - i_part_cost_old;
                                    }
                                }
                            }
                            i_10 += 1;
                            i_10;
                        }
                    }
                }
                i_satd_inter_0 = i_cost;
                if analysis.i_mbrd != 0 {
                    mb_analyse_b_rd(h, &mut analysis, i_satd_inter_0);
                    i_type_0 = B_SKIP as libc::c_int;
                    i_cost = i_bskip_cost;
                    i_partition_0 = D_16x16 as libc::c_int;
                    if analysis.l0.i_rd16x16 < i_cost {
                        i_cost = analysis.l0.i_rd16x16;
                        i_type_0 = B_L0_L0 as libc::c_int;
                    }
                    if analysis.l1.i_rd16x16 < i_cost {
                        i_cost = analysis.l1.i_rd16x16;
                        i_type_0 = B_L1_L1 as libc::c_int;
                    }
                    if analysis.i_rd16x16bi < i_cost {
                        i_cost = analysis.i_rd16x16bi;
                        i_type_0 = B_BI_BI as libc::c_int;
                    }
                    if analysis.i_rd16x16direct < i_cost {
                        i_cost = analysis.i_rd16x16direct;
                        i_type_0 = B_DIRECT as libc::c_int;
                    }
                    if analysis.i_rd16x8bi < i_cost {
                        i_cost = analysis.i_rd16x8bi;
                        i_type_0 = analysis.i_mb_type16x8;
                        i_partition_0 = D_16x8 as libc::c_int;
                    }
                    if analysis.i_rd8x16bi < i_cost {
                        i_cost = analysis.i_rd8x16bi;
                        i_type_0 = analysis.i_mb_type8x16;
                        i_partition_0 = D_8x16 as libc::c_int;
                    }
                    if analysis.i_rd8x8bi < i_cost {
                        i_cost = analysis.i_rd8x8bi;
                        i_type_0 = B_8x8 as libc::c_int;
                        i_partition_0 = D_8x8 as libc::c_int;
                    }
                    (*h).mb.i_type = i_type_0;
                    (*h).mb.i_partition = i_partition_0;
                }
                if (*h).mb.b_chroma_me != 0 {
                    if (*((*h).sps).as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as libc::c_int
                    {
                        mb_analyse_intra(h, &mut analysis, i_satd_inter_0);
                        mb_analyse_intra_chroma(h, &mut analysis);
                    } else {
                        mb_analyse_intra_chroma(h, &mut analysis);
                        mb_analyse_intra(
                            h,
                            &mut analysis,
                            i_satd_inter_0 - analysis.i_satd_chroma,
                        );
                    }
                    analysis.i_satd_i16x16 += analysis.i_satd_chroma;
                    analysis.i_satd_i8x8 += analysis.i_satd_chroma;
                    analysis.i_satd_i4x4 += analysis.i_satd_chroma;
                } else {
                    mb_analyse_intra(h, &mut analysis, i_satd_inter_0);
                }
                if analysis.i_mbrd != 0 {
                    mb_analyse_transform_rd(
                        h,
                        &mut analysis,
                        &mut i_satd_inter_0,
                        &mut i_cost,
                    );
                    intra_rd(
                        h,
                        &mut analysis,
                        i_satd_inter_0 * 17 as libc::c_int / 16 as libc::c_int
                            + 1 as libc::c_int,
                    );
                }
                if analysis.i_satd_i16x16 < i_cost {
                    i_cost = analysis.i_satd_i16x16;
                    i_type_0 = I_16x16 as libc::c_int;
                }
                if analysis.i_satd_i8x8 < i_cost {
                    i_cost = analysis.i_satd_i8x8;
                    i_type_0 = I_8x8 as libc::c_int;
                }
                if analysis.i_satd_i4x4 < i_cost {
                    i_cost = analysis.i_satd_i4x4;
                    i_type_0 = I_4x4 as libc::c_int;
                }
                if analysis.i_satd_pcm < i_cost {
                    i_cost = analysis.i_satd_pcm;
                    i_type_0 = I_PCM as libc::c_int;
                }
                (*h).mb.i_type = i_type_0;
                (*h).mb.i_partition = i_partition_0;
                if analysis.i_mbrd >= 2 as libc::c_int
                    && (i_type_0 == I_4x4 as libc::c_int
                        || i_type_0 == I_8x8 as libc::c_int
                        || i_type_0 == I_16x16 as libc::c_int
                        || i_type_0 == I_PCM as libc::c_int)
                    && i_type_0 != I_PCM as libc::c_int
                {
                    intra_rd_refine(h, &mut analysis);
                }
                if (*h).mb.i_subpel_refine >= 5 as libc::c_int {
                    refine_bidir(h, &mut analysis);
                }
                if analysis.i_mbrd >= 2 as libc::c_int
                    && i_type_0 > B_DIRECT as libc::c_int
                    && i_type_0 < B_SKIP as libc::c_int
                {
                    let mut i_biweight: libc::c_int = 0;
                    analyse_update_cache(h, &mut analysis);
                    if i_partition_0 == D_16x16 as libc::c_int {
                        if i_type_0 == B_L0_L0 as libc::c_int {
                            analysis.l0.me16x16.cost = i_cost;
                            x264_8_me_refine_qpel_rd(
                                h,
                                &mut analysis.l0.me16x16,
                                analysis.i_lambda2,
                                0 as libc::c_int,
                                0 as libc::c_int,
                            );
                        } else if i_type_0 == B_L1_L1 as libc::c_int {
                            analysis.l1.me16x16.cost = i_cost;
                            x264_8_me_refine_qpel_rd(
                                h,
                                &mut analysis.l1.me16x16,
                                analysis.i_lambda2,
                                0 as libc::c_int,
                                1 as libc::c_int,
                            );
                        } else if i_type_0 == B_BI_BI as libc::c_int {
                            i_biweight = (*((*h).mb.bipred_weight)
                                .offset(
                                    analysis.l0.bi16x16.i_ref as isize,
                                ))[analysis.l1.bi16x16.i_ref as usize] as libc::c_int;
                            x264_8_me_refine_bidir_rd(
                                h,
                                &mut analysis.l0.bi16x16,
                                &mut analysis.l1.bi16x16,
                                i_biweight,
                                0 as libc::c_int,
                                analysis.i_lambda2,
                            );
                        }
                    } else if i_partition_0 == D_16x8 as libc::c_int {
                        let mut i_11: libc::c_int = 0 as libc::c_int;
                        while i_11 < 2 as libc::c_int {
                            (*h)
                                .mb
                                .i_sub_partition[(i_11 * 2 as libc::c_int
                                + 1 as libc::c_int)
                                as usize] = analysis.i_mb_partition16x8[i_11 as usize]
                                as uint8_t;
                            (*h)
                                .mb
                                .i_sub_partition[(i_11 * 2 as libc::c_int)
                                as usize] = (*h)
                                .mb
                                .i_sub_partition[(i_11 * 2 as libc::c_int
                                + 1 as libc::c_int) as usize];
                            if analysis.i_mb_partition16x8[i_11 as usize]
                                == D_L0_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel_rd(
                                    h,
                                    &mut *(analysis.l0.me16x8)
                                        .as_mut_ptr()
                                        .offset(i_11 as isize),
                                    analysis.i_lambda2,
                                    i_11 * 8 as libc::c_int,
                                    0 as libc::c_int,
                                );
                            } else if analysis.i_mb_partition16x8[i_11 as usize]
                                == D_L1_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel_rd(
                                    h,
                                    &mut *(analysis.l1.me16x8)
                                        .as_mut_ptr()
                                        .offset(i_11 as isize),
                                    analysis.i_lambda2,
                                    i_11 * 8 as libc::c_int,
                                    1 as libc::c_int,
                                );
                            } else if analysis.i_mb_partition16x8[i_11 as usize]
                                == D_BI_8x8 as libc::c_int
                            {
                                i_biweight = (*((*h).mb.bipred_weight)
                                    .offset(
                                        analysis.l0.me16x8[i_11 as usize].i_ref as isize,
                                    ))[analysis.l1.me16x8[i_11 as usize].i_ref as usize]
                                    as libc::c_int;
                                x264_8_me_refine_bidir_rd(
                                    h,
                                    &mut *(analysis.l0.me16x8)
                                        .as_mut_ptr()
                                        .offset(i_11 as isize),
                                    &mut *(analysis.l1.me16x8)
                                        .as_mut_ptr()
                                        .offset(i_11 as isize),
                                    i_biweight,
                                    i_11 * 2 as libc::c_int,
                                    analysis.i_lambda2,
                                );
                            }
                            i_11 += 1;
                            i_11;
                        }
                    } else if i_partition_0 == D_8x16 as libc::c_int {
                        let mut i_12: libc::c_int = 0 as libc::c_int;
                        while i_12 < 2 as libc::c_int {
                            (*h)
                                .mb
                                .i_sub_partition[(i_12 + 2 as libc::c_int)
                                as usize] = analysis.i_mb_partition8x16[i_12 as usize]
                                as uint8_t;
                            (*h)
                                .mb
                                .i_sub_partition[i_12
                                as usize] = (*h)
                                .mb
                                .i_sub_partition[(i_12 + 2 as libc::c_int) as usize];
                            if analysis.i_mb_partition8x16[i_12 as usize]
                                == D_L0_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel_rd(
                                    h,
                                    &mut *(analysis.l0.me8x16)
                                        .as_mut_ptr()
                                        .offset(i_12 as isize),
                                    analysis.i_lambda2,
                                    i_12 * 4 as libc::c_int,
                                    0 as libc::c_int,
                                );
                            } else if analysis.i_mb_partition8x16[i_12 as usize]
                                == D_L1_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel_rd(
                                    h,
                                    &mut *(analysis.l1.me8x16)
                                        .as_mut_ptr()
                                        .offset(i_12 as isize),
                                    analysis.i_lambda2,
                                    i_12 * 4 as libc::c_int,
                                    1 as libc::c_int,
                                );
                            } else if analysis.i_mb_partition8x16[i_12 as usize]
                                == D_BI_8x8 as libc::c_int
                            {
                                i_biweight = (*((*h).mb.bipred_weight)
                                    .offset(
                                        analysis.l0.me8x16[i_12 as usize].i_ref as isize,
                                    ))[analysis.l1.me8x16[i_12 as usize].i_ref as usize]
                                    as libc::c_int;
                                x264_8_me_refine_bidir_rd(
                                    h,
                                    &mut *(analysis.l0.me8x16)
                                        .as_mut_ptr()
                                        .offset(i_12 as isize),
                                    &mut *(analysis.l1.me8x16)
                                        .as_mut_ptr()
                                        .offset(i_12 as isize),
                                    i_biweight,
                                    i_12,
                                    analysis.i_lambda2,
                                );
                            }
                            i_12 += 1;
                            i_12;
                        }
                    } else if i_partition_0 == D_8x8 as libc::c_int {
                        let mut i_13: libc::c_int = 0 as libc::c_int;
                        while i_13 < 4 as libc::c_int {
                            if (*h).mb.i_sub_partition[i_13 as usize] as libc::c_int
                                == D_L0_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel_rd(
                                    h,
                                    &mut *(analysis.l0.me8x8)
                                        .as_mut_ptr()
                                        .offset(i_13 as isize),
                                    analysis.i_lambda2,
                                    i_13 * 4 as libc::c_int,
                                    0 as libc::c_int,
                                );
                            } else if (*h).mb.i_sub_partition[i_13 as usize]
                                as libc::c_int == D_L1_8x8 as libc::c_int
                            {
                                x264_8_me_refine_qpel_rd(
                                    h,
                                    &mut *(analysis.l1.me8x8)
                                        .as_mut_ptr()
                                        .offset(i_13 as isize),
                                    analysis.i_lambda2,
                                    i_13 * 4 as libc::c_int,
                                    1 as libc::c_int,
                                );
                            } else if (*h).mb.i_sub_partition[i_13 as usize]
                                as libc::c_int == D_BI_8x8 as libc::c_int
                            {
                                i_biweight = (*((*h).mb.bipred_weight)
                                    .offset(
                                        analysis.l0.me8x8[i_13 as usize].i_ref as isize,
                                    ))[analysis.l1.me8x8[i_13 as usize].i_ref as usize]
                                    as libc::c_int;
                                x264_8_me_refine_bidir_rd(
                                    h,
                                    &mut *(analysis.l0.me8x8)
                                        .as_mut_ptr()
                                        .offset(i_13 as isize),
                                    &mut *(analysis.l1.me8x8)
                                        .as_mut_ptr()
                                        .offset(i_13 as isize),
                                    i_biweight,
                                    i_13,
                                    analysis.i_lambda2,
                                );
                            }
                            i_13 += 1;
                            i_13;
                        }
                    }
                }
            }
        }
        current_block = 17193116482801528934;
    }
    match current_block {
        10193120697285822987 => {
            if analysis.i_mbrd != 0 {
                mb_init_fenc_cache(
                    h,
                    (analysis.i_mbrd >= 2 as libc::c_int) as libc::c_int,
                );
            }
            mb_analyse_intra(h, &mut analysis, (1 as libc::c_int) << 28 as libc::c_int);
            if analysis.i_mbrd != 0 {
                intra_rd(h, &mut analysis, (1 as libc::c_int) << 28 as libc::c_int);
            }
            i_cost = analysis.i_satd_i16x16;
            (*h).mb.i_type = I_16x16 as libc::c_int;
            if analysis.i_satd_i4x4 < i_cost {
                i_cost = analysis.i_satd_i4x4;
                (*h).mb.i_type = I_4x4 as libc::c_int;
            }
            if analysis.i_satd_i8x8 < i_cost {
                i_cost = analysis.i_satd_i8x8;
                (*h).mb.i_type = I_8x8 as libc::c_int;
            }
            if analysis.i_satd_pcm < i_cost {
                (*h).mb.i_type = I_PCM as libc::c_int;
            } else if analysis.i_mbrd >= 2 as libc::c_int {
                intra_rd_refine(h, &mut analysis);
            }
        }
        _ => {}
    }
    analyse_update_cache(h, &mut analysis);
    if analysis.i_mbrd >= 2 as libc::c_int {
        static mut check_mv_lists: [uint8_t; 19] = [
            0,
            0,
            0,
            0,
            1 as libc::c_int as uint8_t,
            0,
            0,
            0,
            1 as libc::c_int as uint8_t,
            0,
            0,
            0,
            2 as libc::c_int as uint8_t,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        let mut list: libc::c_int = check_mv_lists[(*h).mb.i_type as usize]
            as libc::c_int - 1 as libc::c_int;
        if list >= 0 as libc::c_int && (*h).mb.i_partition != D_16x16 as libc::c_int
            && (*(&mut *(*((*h).mb.cache.mv).as_mut_ptr().offset(list as isize))
                .as_mut_ptr()
                .offset(*x264_scan8.as_ptr().offset(0 as libc::c_int as isize) as isize)
                as *mut [int16_t; 2] as *mut x264_union32_t))
                .i
                == (*(&mut *(*((*h).mb.cache.mv).as_mut_ptr().offset(list as isize))
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8.as_ptr().offset(12 as libc::c_int as isize) as isize,
                    ) as *mut [int16_t; 2] as *mut x264_union32_t))
                    .i
            && (*h)
                .mb
                .cache
                .ref_0[list as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                as libc::c_int
                == (*h)
                    .mb
                    .cache
                    .ref_0[list
                    as usize][x264_scan8[12 as libc::c_int as usize] as usize]
                    as libc::c_int
        {
            (*h).mb.i_partition = D_16x16 as libc::c_int;
        }
    }
    if analysis.i_mbrd == 0 {
        mb_analyse_transform(h);
    }
    if analysis.i_mbrd == 3 as libc::c_int
        && !((*h).mb.i_type == P_SKIP as libc::c_int
            || (*h).mb.i_type == B_SKIP as libc::c_int)
    {
        mb_analyse_qp_rd(h, &mut analysis);
    }
    (*h).mb.b_trellis = (*h).param.analyse.i_trellis;
    (*h)
        .mb
        .b_noise_reduction = ((*h).mb.b_noise_reduction != 0
        || (*h).param.analyse.i_noise_reduction != 0
            && !((*h).mb.i_type == I_4x4 as libc::c_int
                || (*h).mb.i_type == I_8x8 as libc::c_int
                || (*h).mb.i_type == I_16x16 as libc::c_int
                || (*h).mb.i_type == I_PCM as libc::c_int)) as libc::c_int;
    if !((*h).mb.i_type == P_SKIP as libc::c_int
        || (*h).mb.i_type == B_SKIP as libc::c_int) && (*h).mb.i_psy_trellis != 0
        && (*h).param.analyse.i_trellis == 1 as libc::c_int
    {
        psy_trellis_init(h, 0 as libc::c_int);
    }
    if (*h).mb.b_trellis == 1 as libc::c_int || (*h).mb.b_noise_reduction != 0 {
        (*h).mb.i_skip_intra = 0 as libc::c_int;
    }
}
unsafe extern "C" fn analyse_update_cache(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    match (*h).mb.i_type {
        0 => {
            let mut i: libc::c_int = 0 as libc::c_int;
            while i < 16 as libc::c_int {
                (*h)
                    .mb
                    .cache
                    .intra4x4_pred_mode[x264_scan8[i as usize]
                    as usize] = (*a).i_predict4x4[i as usize] as int8_t;
                i += 1;
                i;
            }
            mb_analyse_intra_chroma(h, a);
        }
        1 => {
            let mut i_0: libc::c_int = 0 as libc::c_int;
            while i_0 < 4 as libc::c_int {
                x264_macroblock_cache_intra8x8_pred(
                    h,
                    2 as libc::c_int * (i_0 & 1 as libc::c_int),
                    2 as libc::c_int * (i_0 >> 1 as libc::c_int),
                    (*a).i_predict8x8[i_0 as usize],
                );
                i_0 += 1;
                i_0;
            }
            mb_analyse_intra_chroma(h, a);
        }
        2 => {
            (*h).mb.i_intra16x16_pred_mode = (*a).i_predict16x16;
            mb_analyse_intra_chroma(h, a);
        }
        3 => {}
        4 => {
            match (*h).mb.i_partition {
                16 => {
                    x264_macroblock_cache_ref(
                        h,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        4 as libc::c_int,
                        4 as libc::c_int,
                        0 as libc::c_int,
                        (*a).l0.me16x16.i_ref as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        4 as libc::c_int,
                        4 as libc::c_int,
                        0 as libc::c_int,
                        (*(((*a).l0.me16x16.mv).as_mut_ptr() as *mut x264_union32_t)).i,
                    );
                }
                14 => {
                    x264_macroblock_cache_ref(
                        h,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        4 as libc::c_int,
                        2 as libc::c_int,
                        0 as libc::c_int,
                        (*a).l0.me16x8[0 as libc::c_int as usize].i_ref as int8_t,
                    );
                    x264_macroblock_cache_ref(
                        h,
                        0 as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        2 as libc::c_int,
                        0 as libc::c_int,
                        (*a).l0.me16x8[1 as libc::c_int as usize].i_ref as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        4 as libc::c_int,
                        2 as libc::c_int,
                        0 as libc::c_int,
                        (*(((*a).l0.me16x8[0 as libc::c_int as usize].mv).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        2 as libc::c_int,
                        0 as libc::c_int,
                        (*(((*a).l0.me16x8[1 as libc::c_int as usize].mv).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i,
                    );
                }
                15 => {
                    x264_macroblock_cache_ref(
                        h,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        0 as libc::c_int,
                        (*a).l0.me8x16[0 as libc::c_int as usize].i_ref as int8_t,
                    );
                    x264_macroblock_cache_ref(
                        h,
                        2 as libc::c_int,
                        0 as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        0 as libc::c_int,
                        (*a).l0.me8x16[1 as libc::c_int as usize].i_ref as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        0 as libc::c_int,
                        (*(((*a).l0.me8x16[0 as libc::c_int as usize].mv).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        2 as libc::c_int,
                        0 as libc::c_int,
                        2 as libc::c_int,
                        4 as libc::c_int,
                        0 as libc::c_int,
                        (*(((*a).l0.me8x16[1 as libc::c_int as usize].mv).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i,
                    );
                }
                _ => {
                    x264_8_log(
                        h,
                        0 as libc::c_int,
                        b"internal error P_L0 and partition=%d\n\0" as *const u8
                            as *const libc::c_char,
                        (*h).mb.i_partition,
                    );
                }
            }
        }
        5 => {
            x264_macroblock_cache_ref(
                h,
                0 as libc::c_int,
                0 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[0 as libc::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as libc::c_int,
                0 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[1 as libc::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                0 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[2 as libc::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                (*a).l0.me8x8[3 as libc::c_int as usize].i_ref as int8_t,
            );
            let mut i_1: libc::c_int = 0 as libc::c_int;
            while i_1 < 4 as libc::c_int {
                mb_cache_mv_p8x8(h, a, i_1);
                i_1 += 1;
                i_1;
            }
        }
        6 => {
            (*h).mb.i_partition = D_16x16 as libc::c_int;
            x264_macroblock_cache_ref(
                h,
                0 as libc::c_int,
                0 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                0 as libc::c_int,
                0 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                0 as libc::c_int,
                (*(((*h).mb.cache.pskip_mv).as_mut_ptr() as *mut x264_union32_t)).i,
            );
        }
        18 | 7 => {
            (*h).mb.i_partition = (*h).mb.cache.direct_partition;
            mb_load_mv_direct8x8(h, 0 as libc::c_int);
            mb_load_mv_direct8x8(h, 1 as libc::c_int);
            mb_load_mv_direct8x8(h, 2 as libc::c_int);
            mb_load_mv_direct8x8(h, 3 as libc::c_int);
        }
        17 => {
            let mut i_2: libc::c_int = 0 as libc::c_int;
            while i_2 < 4 as libc::c_int {
                mb_cache_mv_b8x8(h, a, i_2, 1 as libc::c_int);
                i_2 += 1;
                i_2;
            }
        }
        _ => {
            match (*h).mb.i_partition {
                16 => {
                    match (*h).mb.i_type {
                        8 => {
                            x264_macroblock_cache_ref(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                0 as libc::c_int,
                                (*a).l0.me16x16.i_ref as int8_t,
                            );
                            x264_macroblock_cache_mv(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                0 as libc::c_int,
                                (*(((*a).l0.me16x16.mv).as_mut_ptr()
                                    as *mut x264_union32_t))
                                    .i,
                            );
                            x264_macroblock_cache_ref(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                1 as libc::c_int,
                                -(1 as libc::c_int) as int8_t,
                            );
                            x264_macroblock_cache_mv(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                1 as libc::c_int,
                                0 as libc::c_int as uint32_t,
                            );
                            x264_macroblock_cache_mvd(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                1 as libc::c_int,
                                0 as libc::c_int as uint16_t,
                            );
                        }
                        12 => {
                            x264_macroblock_cache_ref(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                0 as libc::c_int,
                                -(1 as libc::c_int) as int8_t,
                            );
                            x264_macroblock_cache_mv(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                0 as libc::c_int,
                                0 as libc::c_int as uint32_t,
                            );
                            x264_macroblock_cache_mvd(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                0 as libc::c_int,
                                0 as libc::c_int as uint16_t,
                            );
                            x264_macroblock_cache_ref(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                1 as libc::c_int,
                                (*a).l1.me16x16.i_ref as int8_t,
                            );
                            x264_macroblock_cache_mv(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                1 as libc::c_int,
                                (*(((*a).l1.me16x16.mv).as_mut_ptr()
                                    as *mut x264_union32_t))
                                    .i,
                            );
                        }
                        16 => {
                            x264_macroblock_cache_ref(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                0 as libc::c_int,
                                (*a).l0.bi16x16.i_ref as int8_t,
                            );
                            x264_macroblock_cache_mv(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                0 as libc::c_int,
                                (*(((*a).l0.bi16x16.mv).as_mut_ptr()
                                    as *mut x264_union32_t))
                                    .i,
                            );
                            x264_macroblock_cache_ref(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                1 as libc::c_int,
                                (*a).l1.bi16x16.i_ref as int8_t,
                            );
                            x264_macroblock_cache_mv(
                                h,
                                0 as libc::c_int,
                                0 as libc::c_int,
                                4 as libc::c_int,
                                4 as libc::c_int,
                                1 as libc::c_int,
                                (*(((*a).l1.bi16x16.mv).as_mut_ptr()
                                    as *mut x264_union32_t))
                                    .i,
                            );
                        }
                        _ => {}
                    }
                }
                14 => {
                    mb_cache_mv_b16x8(h, a, 0 as libc::c_int, 1 as libc::c_int);
                    mb_cache_mv_b16x8(h, a, 1 as libc::c_int, 1 as libc::c_int);
                }
                15 => {
                    mb_cache_mv_b8x16(h, a, 0 as libc::c_int, 1 as libc::c_int);
                    mb_cache_mv_b8x16(h, a, 1 as libc::c_int, 1 as libc::c_int);
                }
                _ => {
                    x264_8_log(
                        h,
                        0 as libc::c_int,
                        b"internal error (invalid MB type)\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
        }
    }
    if (*h).i_thread_frames > 1 as libc::c_int
        && !((*h).mb.i_type == I_4x4 as libc::c_int
            || (*h).mb.i_type == I_8x8 as libc::c_int
            || (*h).mb.i_type == I_16x16 as libc::c_int
            || (*h).mb.i_type == I_PCM as libc::c_int)
    {
        let mut l: libc::c_int = 0 as libc::c_int;
        while l <= ((*h).sh.i_type == SLICE_TYPE_B as libc::c_int) as libc::c_int {
            let mut completed: libc::c_int = 0;
            let mut ref_0: libc::c_int = (*h)
                .mb
                .cache
                .ref_0[l as usize][x264_scan8[0 as libc::c_int as usize] as usize]
                as libc::c_int;
            if !(ref_0 < 0 as libc::c_int) {
                completed = x264_8_frame_cond_wait(
                    (*(*h).fref[l as usize][(ref_0 >> (*h).mb.b_interlaced) as usize])
                        .orig,
                    -(1 as libc::c_int),
                );
                if ((*h)
                    .mb
                    .cache
                    .mv[l
                    as usize][x264_scan8[15 as libc::c_int as usize]
                    as usize][1 as libc::c_int as usize] as libc::c_int
                    >> 2 as libc::c_int - (*h).mb.b_interlaced)
                    + (*h).mb.i_mb_y * 16 as libc::c_int > completed
                {
                    x264_8_log(
                        h,
                        1 as libc::c_int,
                        b"internal error (MV out of thread range)\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    x264_8_log(
                        h,
                        3 as libc::c_int,
                        b"mb type: %d \n\0" as *const u8 as *const libc::c_char,
                        (*h).mb.i_type,
                    );
                    x264_8_log(
                        h,
                        3 as libc::c_int,
                        b"mv: l%dr%d (%d,%d) \n\0" as *const u8 as *const libc::c_char,
                        l,
                        ref_0,
                        (*h)
                            .mb
                            .cache
                            .mv[l
                            as usize][x264_scan8[15 as libc::c_int as usize]
                            as usize][0 as libc::c_int as usize] as libc::c_int,
                        (*h)
                            .mb
                            .cache
                            .mv[l
                            as usize][x264_scan8[15 as libc::c_int as usize]
                            as usize][1 as libc::c_int as usize] as libc::c_int,
                    );
                    x264_8_log(
                        h,
                        3 as libc::c_int,
                        b"limit: %d \n\0" as *const u8 as *const libc::c_char,
                        (*h).mb.mv_max_spel[1 as libc::c_int as usize],
                    );
                    x264_8_log(
                        h,
                        3 as libc::c_int,
                        b"mb_xy: %d,%d \n\0" as *const u8 as *const libc::c_char,
                        (*h).mb.i_mb_x,
                        (*h).mb.i_mb_y,
                    );
                    x264_8_log(
                        h,
                        3 as libc::c_int,
                        b"completed: %d \n\0" as *const u8 as *const libc::c_char,
                        completed,
                    );
                    x264_8_log(
                        h,
                        1 as libc::c_int,
                        b"recovering by using intra mode\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    mb_analyse_intra(h, a, (1 as libc::c_int) << 28 as libc::c_int);
                    (*h).mb.i_type = I_16x16 as libc::c_int;
                    (*h).mb.i_intra16x16_pred_mode = (*a).i_predict16x16;
                    mb_analyse_intra_chroma(h, a);
                }
            }
            l += 1;
            l;
        }
    }
}
